<h2>Rdzeń</h2><h3>Opcje linii poleceń</h3><p>Możliwe jest zrezygnowanie z interfejsu UI i rozpoczęcie pracy z web2py bezpośrednio z linii poleceń przez wpisanie czegoś takiego:</p><div class="inxx">hasło</div><pre><code class="code">python web2py.py -a 'your password' -i 127.0.0.1 -p 8000</code></pre><p>Podczas uruchomienia web2py tworzony jest plik o nazwie "parameters_8000.py", w którym zapisywane jest szyfrowane hasło. Jeśli użyje się "&lt;ask&gt;" jako hasła, web2py poprosi o podanie hasła.</p><p>Dla dodatkowego bezpieczeństwa można wystartować web2py poleceniem:</p><pre><code class="code">python web2py.py -a '&lt;recycle&gt;' -i 127.0.0.1 -p 8000</code></pre><p>W tym przypadku web2py ponownie wykorzystuje przechowywane zaszyfrowane hasło. Jeśli hasło nie zostało podane lub jeśli plik "parameters_8000.py" został usunięty, nie jest dostępny internetowy interfejs administracyjny.</p><div class="inxx">PAM</div><p>W niektórych systemach Unix/Linux, jeśli hasło to</p><pre><code class="code">&lt;pam_user:some_user&gt;</code></pre><p>web2py używa hasła PAM konta systemu operacyjnego <code>some_user</code> do uwierzytelniania administratora, chyba że jest zablokowany przez konfigurację PAM.</p><blockquote>Platforma web2py zwykle działa z CPython (implementaja C interpretera Python stworzona
przez Guido van Rossum), ale również może działać z PyPy i Jython. Ta ostatnia
implementacja umożliwia używanie web2py w kontekście infrastruktury Java EE.
W celu umożliwienia stosowania Jythona, wystarczy zamienić wyrażenie "python web2py.py ..."
na "jython web2py.py". Szczegółowe informacje o instalacji Jython, modułu zxJDBC
wymaganego do dostępu do bazy danych można znaleźć w rozdziale 14.</blockquote><p>Skrypt "web2py.py" może przyjmować wiele argumentów linii poleceń określających maksymalną liczbę wątków, udostępniających SSL itd. W celu uzyskania pełnego wykazu wpisz:</p><div class="inxx">linia poleceń</div><pre><code class="code">&gt;&gt;&gt; python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "&lt;recycle&gt;" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        location of the applications folder (also known as directory) 
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests</code></pre><blockquote>Uwaga: Opcja <code>-W</code>, używana do instalacji usługi Windows, została usunięta.
Proszę zobaczyć <a href="../13/#markmin_nssm">nssm w rozdziale Deployment Recipes</a></blockquote><p>Opcje pisane małymi literami są używane do konfiguracji serwera internetowego. Opcja <code>-L</code> powiadamia web2py aby czytał opcje konfiguracyjne z pliku, <code>-W</code> instaluje web2py jako usługę Windows, podczas gdy opcje <code>-S</code>, <code>-P</code> i <code>-M</code> uruchamiają interaktywną powłokę Pythona. Opcja <code>-T</code> wyszukuje i uruchamia kontroler doctests w środowisku wykonawczym web2py. Poniższy przykład uruchamia doctests ze wszystkich kontrolerów w aplikacji "welcome":</p><pre><code class="code">python web2py.py -vT welcome</code></pre><p>jeśli uruchomi się web2py jako usługę Windows przez opcję <code>-W</code>, to nie jest wygodne przekazywanie konfiguracji przy użyciu argumentów linii poleceń. Z tego powodu w folderze web2py znajduje się prosty plik konfiguracyjny "options_std.py" dla wewnętrznego serwera internetowego:</p><pre><code class="code">import socket
import os

ip = '0.0.0.0'
port = 80
interfaces = [('0.0.0.0', 80)]
               #,('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem')]
password = '&lt;recycle&gt;'  # ## &lt;recycle&gt; means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
ssl_certificate = None  # 'ssl_certificate.pem'  # ## path to certificate file
ssl_private_key = None  # 'ssl_private_key.pem'  # ## path to private key file
#numthreads = 50 # ## deprecated; remove
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None</code></pre><p>Plik ten zawiera wartości domyślne web2py. Jeśli edytuje się ten plik, to musi się go importować jawnie z użyciem opcji <code>-L</code> linii poleceń. Działa to tylko gdy uruchomi się web2py jako usługę Windows.</p><h3>Proces przetwarzania</h3><p>Proces przetwarzania danych w web2py jest następujący:</p><ul><li>Żądanie HTTP dociera do serwera internetowego (wbudowanego serwera Rocket lub innego serwera połączonego z web2py poprzez WSGI lub inny adapter). Serwer internetowy obsługuje każde żądanie w oddzielnym wątku, równolegle.</li><li>Nagłówek żądania HTTP jest parsowany i przekazywany do dyspozytora (<em>ang. dispatcher</em>) (wyjaśnionego dalej w tym rozdziale).</li><li>Dyspozytor decyduje, która z zainstalowanych aplikacji będzie obsługiwać żądanie i odwzorowuje PATH_INFO z adresu URL na wywołanie funkcji. Każdy adres URL odpowiada jednemu wywołaniu funkcji.</li><li>Żądania dla plików w folderze statycznym są obsługiwane bezpośrednio a większe pliki są automatycznie strumieniowane do klienta.</li><li>Żądania pozostałe (nie dotyczące plików statycznych) są odwzorowywane do akcje (tj. funkcji w pliku kontrolera z żądanej aplikacji).</li><li>Przed wywołaniem akcji dzieje się kilka rzeczy: jeśli żądanie zawiera nagłówek ciasteczka dla aplikacji, pobierany jest obiekt sesji; jeśli nie, tworzony jest id sesji (ale plik sesji jest zapisywany później); tworzone jest środowisko dla żądania; w tym środowisku wykonywane są modele.</li><li>Na koniec, we wstępnie zbudowanym środowisku wykonywana jest akcja kontrolera.</li><li>Jeśli akcja zwraca ciąg znakowy, to jest on zwracany klientowi (lub jeśli akcja zwraca obiekt helpera HTML web2py, to jest on serializowany i zwracany klientowi).</li><li>Jeśli akcja zwraca element iterowalny, to zostaje na nim zastosowana pętla i strumień danych przesyłany klientowi.</li><li>Jeśli akcja zwraca słownik, web2py próbuje zlokalizować widok do renderowana słownika. Widok musi mieć tą sama nazwę co akcja (chyba, że określono to inaczej) i to samo rozszerzenie, co żądana strona (domyślnie .html); w przypadku błędu web2py może zastosować widok ogólny (jeśli jest dostępny i włączony). Widok widzi każdą zmienną zdefiniowana w modelach, jak również te zmienne w słowniku zwracane przez akcje, ale nie ma tu zmiennych globalnych zdefiniowanych w kontrolerze.</li><li>Cały kod wykonywany jest w pojedynczej transakcji bazy danych, chyba że określono to inaczej.</li><li>Jeśli kod użytkownika powiedzie się, transakcja jest zatwierdzana.</li><li>Jeśli kod użytkownika nie powiedzie się, w bilecie zostaje jest zapisany komunikat z ostatniego wywołania (<em>ang. traceback</em>) i uzytkownikowi zostaje wysłany identyfikator biletu. Tylko administrator systemu może wyszukiwać i odczytywać w bilecie komunikat z ostatniego wywołania.</li></ul><p>Istnieje kilka uwag, o których warto pamiętać:</p><ul><li>Modele w tym samym folderze (podfolderze) są wykonywane w alfabetycznej kolejności.</li><li>Każda zmienna zdefiniowana w modelu będzie widoczna dla innych modeli w kolejności alfabetycznej, dla kontrolerów i widoków.</li></ul><div class="inxx">models_to_run</div><ul><li>Modele w podfolderach są wykonywane warunkowo . Na przykład, jeśli użytkownik wysyła żądanie "/a/c/f", gdzie "a" to aplikacja, "c" to kontroler a "f" to funkcja</li></ul><p>(akcja), to następnie wykonywane są następujące modele:</p><pre><code>applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py</code></pre><p>Zachowanie takie jest wymuszane domyślnie. Zmieniając listę wyrażeń regularnych <code>response.models_to_run</code> można wymusić takie zachowanie, jakie się chce (zobacz do <a href="#markmin_response_models_to_run">response</a> w celu poznania szczegółów)</p><ul><li>Wykonywany jest żądany kontroler i wywoływana jest potrzebna funkcja. Oznacza to, że dla każdego żądania  dla określonego kontrolera wykonywany jest również cały kod na najwyższym poziomie w tym kontrolerze.</li><li>Widok jest wywoływany tylko wtedy, gdy akcja zwraca słownik.</li><li>Jeżeli widok nie zostanie znaleziony, web2py spróbuje użyć widoku ogólnego. Domyślnie, widok ogólne są wyłączone, lecz aplikacja 'welcome' zawiera linię w /models/db.py do ich włączenie, ale tylko na localhost. Mogą one być włączone dla każdego typu i każdej akcji (za pomocą <code>response.generic_patterns</code>). Ogólnie, ogólne widoki są narzędziem programistycznym i zazwyczaj nie powinny być wykorzystywane w środowisku produkcyjnym. Jeśli chce się aby jakieś akcje wykorzystywały widok ogólny, trzeba umieścić je na liście <code>response.generic_patterns</code> (omówionej w rozdziale Usługi).</li></ul><p>Możliwe zachowania akcji są następujące:</p><p><strong>Zwracanie ciąga znakowego</strong></p><pre><code>def index(): return 'data'</code></pre><p><strong>Zwracanie słownika dla widoku</strong>:</p><pre><code>def index(): return dict(key='value')</code></pre><p><strong>Zwracanie wszystkich lokalnych zmiennych</strong>:</p><pre><code>def index(): return locals()</code></pre><p><strong>Przekierowanie użytkowników do innej strony</strong>:</p><pre><code>def index(): redirect(URL('other_action'))</code></pre><p><strong>Zwracanie strony HTTP innej niż "200 OK"</strong>:</p><pre><code>def index(): raise HTTP(404)</code></pre><p><strong>Zwracanie helpera</strong> (na przykład FORM):</p><pre><code>def index(): return FORM(INPUT(_name='test'))</code></pre><p>(jest to najczęściej stosowane dla wywołań zwrotnych Ajax i komentarzy, patrz rozdział 12)</p><p>Gdy akcja zwraca słownik, to może zawierać kod generowany przez helpery, w tym formularze oparte na tabelach bazy danych lub formularze z fabryki, na przykład:</p><pre><code>def index(): return dict(form=SQLFORM.factory(Field('name')).process())</code></pre><p>(Wszystkie formularze generowane przez web2py wykorzystują zgłoszenia zwrotne (<em>ang. postback</em>), patrz rozdział 3)</p><h3>Rozdzielanie</h3><p><div class="inxx">mapowanie url</div> <div class="inxx">odwzorowywanie url</div> <div class="inxx">rozdzielanie</div></p><p>Platforma web2py odwzorowuje adres URL formularza o postaci:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html</code></pre><p>do funkcji <code>f()</code> w kontrolerze "c.py" w aplikacji "a". Jeśli <code>f</code> nie jest podana, web2py stosuje domyślnie funkcję <code>index</code> kontrolera. Jeśli <code>c</code> nie jest podany, web2py stosuje domyślnie kontroler "default.py" a przy braku <code>a</code>, web2py wykorzystuje domyślnie aplikację <code>init</code>. Jeśli nie ma aplikacji <code>init</code>, web2py próbuje uruchomić aplikację <code>welcome</code>. Jest to pokazane na poniższym obrazie:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5700.png" alt="image" style="width:480px" /></p></p><p>Domyślnie, każde nowe żądanie tworzy nową sesję. Ponadto, ciasteczko sesji jest zwracane do przeglądarki klienta w celu śledzenia sesji.</p><p>Rozszerzenie <code>.html</code> jest opcjonalne i jest rozszerzeniem domyślnym. Rozszerzenie determinuje rozszerzenie widoku, który renderuje wyjście funkcji kontrolera <code>f()</code>. Pozwala aby ta sama zawartość była serwowana w wielu formatach (html, xml, json, rss itd.).</p><blockquote>Funkcje posiadające argumenty lub rozpoczynające się dwoma znakami podkreślenia
nie są publicznie widoczne i mogą tylko być wywoływane przez inne funkcje.</blockquote><div class="inxx">pliki statyczne</div><p>Istnieje wyjątek zrobiony dla adresów URL formularzy o postaci:</p><pre><code class="code">http://127.0.0.1:8000/a/static/filename</code></pre><p>Nie ma kontrolera o nazwie "static". web2py interpretuje to jako żądanie dla pliku o nazwie "filename" w podfolderze "static" aplikacji "a".</p><p><div class="inxx">PARTIAL CONTENT</div> <div class="inxx">IF_MODIFIED_SINCE</div> Po pobraniu plików statycznych, web2py nie tworzy sesji, ani nie wystawia ciasteczka lub wykonuje modele. web2py zawsze strumieniuje pliki statyczne kawałkami o rozmiarze 1MB i wysyła PARTIAL CONTENT, gdy klient wysyła żądanie RANGE dla podzbioru pliku.</p><p>Platforma web2py również obsługuje protokół IF_MODIFIED_SINCE i nie wysyła pliku, jeśli jest on już przechowywany w pamięci podręcznej przeglądarki i jeśli plik ten nie został zmieniony od czasu przesłania go do przeglądarki.</p><p>Podczas linkowania do plików audio lub wideo w folderze statycznym, jeśli chce się wymusić na przeglądarce aby pobierała pliki audio lub wideo, a nie je strumieniowała w odtwarzaczu medialnym, trzeba dodać <code>?attachment</code> do adresu URL. To poinformuje web2py aby ustawił nagłówek <code>Content-Disposition</code> odpowiedzi HTTP na "attachment". Na przykład:</p><pre><code class="code">&lt;a href="/app/static/my_audio_file.mp3?attachment"&gt;Download&lt;/a&gt;</code></pre><p>Po kliknięciu powyższego odnośnika, przeglądarka poprosi użytkownika aby pobrał plik MP3 zamiast go strumieniować w odtwarzaczu audio. Tak jak opisano <a href="#markmin_response">poniżej</a>, można również bezpośrednio ustawiać nagłówki odpowiedzi HTTP przypisując <code>dict</code> nazw nagłówków i ich wartości do <code>response.headers</code>.</p><p><div class="inxx">request.application</div> <div class="inxx">request.controller</div> <div class="inxx">request.function</div> <div class="inxx">GET</div> <div class="inxx">POST</div> <div class="inxx">request.args</div> web2py odwzorowuje żądania GET i POST formularza:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&amp;q=2</code></pre><p>do funkcji <code>f</code> w kontrolerze "c.py" w aplikacji <code>a</code> i przechowuje parametry adresu URL w zmiennej <code>request</code> jak niżej:</p><pre><code class="code">request.args = ['x', 'y', 'z']</code></pre><p>i:</p><pre><code class="code">request.vars = {'p':1, 'q':2}</code></pre><p>i:</p><pre><code class="code">request.application = 'a'
request.controller = 'c'
request.function = 'f'</code></pre><p>W powyższym przykładzie zarówno <code>request.args[i]</code> jak i <code>request.args(i)</code> mogą być używane do pobrania i-tego elementu <code>request.args</code>, ale gdy pierwszy zgłasza wyjątek jeśli na liście nie występuje index, to drugi zwraca w takim przypadku None.</p><div class="inxx">request.url</div><pre><code class="code">request.url</code></pre><p>przechowuje pełny adres URL bieżącego żądania (nie dołączając zmiennych GET).</p><p><div class="inxx">request.ajax</div> <div class="inxx">request.cid</div></p><pre><code class="code">request.ajax</code></pre><p>domyślnie wartość False, ale True jeśli web2py stwierdzi, że akcja została wywołana przez żądanie Ajax.</p><p>Jeśli żądanie jest żądaniem Ajax i jeśli zostało zainicjowane przez komponent web2py, nazwę komponentu można znaleźć w:</p><pre><code class="code">request.cid</code></pre><p>Komponenty omówione są bardziej szczegółowo w rozdziale 12.</p><p><div class="inxx">request.get_vars</div> <div class="inxx">request.post_vars</div> <div class="inxx">request.vars</div> Jeśli żądanie HTTP jest typu GET, to <code>request.env.request_method</code> zostaje ustawiona na "GET", jeśli natomiast typu POST, to na "POST". Parametry zapytania z adresu URL są przechowywane w zmiennej <code>request.get_vars</code>. Zmienna <code>request.post_vars</code> zawiera wszystkie parametry przekazane do ciała żądania (zazwyczaj POST, PUT lub DELETE). Słownik <code>request.vars</code> zawiera je oba (<code>get_vars</code> i <code>post_vars</code>)</p><p>Platforma web2py przechowuje zmienne środowiskowe WSGI i web2py w zmiennej <code>request.env</code>, na przykład:</p><pre><code class="code">request.env.path_info = 'a/c/f'</code></pre><p>a nagłówki HTTP w zmiennych środowiskowych, na przykład:</p><pre><code class="code">request.env.http_host = '127.0.0.1:8000'</code></pre><blockquote>Proszę zwrócić uwagę, że web2py sprawdza wszystkie adresy URL, aby zapobiegać
atakom z przeglądaniem katalogów.</blockquote><p>Adresy URL mogą zawierać tylko znaki alfanumeryczne, znaki podkreślenia i ukośniki. Parametr <code>args</code> nie może zawierać występujących po sobie kropek. Spacje są zamieniane na znaki podkreślenia przed walidacją. Jeśli składnia adresu URL jest nieprawidłowa, web2py zwraca komunikat błędu 400 HTTP<sup>[<a href="/book/default/reference/42/http-w" target="_blank">http-w</a>]</sup> <sup>[<a href="/book/default/reference/42/http-o" target="_blank">http-o</a>]</sup> .</p><p>Jeśli adres URL zgodny jest z żądaniem dla plików statycznych, web2py po prostu czyta  i zwraca (strumieniuje) żądany plik.</p><p>Jeśli adres URL nie żąda pliku statycznego, web2py przetwarza żądanie w następującej kolejności:</p><ul><li>Analizuje ciasteczka.</li><li>Tworzy środowisko.</li><li>Inicjuje obiekty  <code>request</code>, <code>response</code>, <code>cache</code>.</li><li>Otwiera isteniejący obiekt  <code>session</code> lub tworzy nowy.</li><li>Wykonuje modele należące do żądanej aplikacji.</li><li>Wykonuje żądaną funkcję akcji kontrolera.</li><li>Jeśli funkcja zwraca słownik, wykonuje związany widok.</li><li>W razie sukcesu zatwierdza wszystkie otwarte transakcje.</li><li>Zapisuje sesję.</li><li>Zwraca odpowiedź HTTP.</li></ul><p>Proszę zauważyć, że kontroler i widok są wykonywane w różnych kopiach tego samego środowiska, dlatego widok nie widzi kontrolera, ale widzi modele i zmienne zwracane przez funkcje akcji kontrolera.</p><p>Jeśli zostaje wywołany wyjątek (inny niż HTTP), web2py wykonuje następujące rzeczy:</p><ul><li>Zapisuje komunikat z ostatniego wywołania (traceback) w pliku błędu i przypisuje mu numer biletu.</li><li>Wycofuje wszystkie otwarte transakcje bazy danych.</li><li>Zwraca stronę błędu raportującą numer biletu.</li></ul><p>Jeśli wyjątek jest wyjątkiem <code>HTTP</code>, to zakłada się, że zamierzone zachowanie (na przykład, przekierowanie <code>HTTP</code>) i wszystkie otwarte transakcje bazy danych zostały zatwierdzone. Zachowanie późniejsze jest określone przez sam wyjątek <code>HTTP</code>. Klasa wyjątku <code>HTTP</code> nie jest standardowym wyjątkiem Pythona – jest zdefiniowana przez web2py.</p><h3>Biblioteki</h3><p>Biblioteki web2py są dostępne dla aplikacji użytkownika jako obiekty globalne. Na przykład obiekty <code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>, klasy helperów, walidatorów, API DAL oraz  funkcje <code>T</code> i <code>redirect</code>.</p><p>Obiekty te sa zdefiniowane w nastęþujacych plikach rdzenia:</p><pre><code class="code">web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py</code></pre><blockquote>Proszę zauważyć, że wiele z tych modułów, w szczególności <code>dal</code> (warstwa abstrakcji
bazy danych), <code>template</code> (język szablonowania), <code>rocket</code> (serwer internetowy)
i <code>html</code> (helpery) nie mają zależności i mogą być używane poza web2py.</blockquote><p>Skompresowane przez gzip archiwum tar aplikacji dostarczane wraz z web2py to</p><pre><code class="code">welcome.w2p</code></pre><p>Aplikacja ta jest tworzona podczas instalacji i nadpisywana podczas aktualizacji.</p><blockquote>Podczas pierwszego uruchomienia web2py tworzy dwa nowe foldery: deposit i applications.
Folder deposit jest używany jako tymczasowy magazyn dla instalowania i odinstalowywania
aplikacji.

Podczas pierwszego uruchomienia web2py i po aktualizacji, aplikacja "welcome" jest
pakowana do pliku "welcome.w2p" aby mogła być używana jako aplikacja szkieletowa.</blockquote><p>Kiedy web2py zostaje uaktualniany, to dostarczany jest wraz z plikiem o nazwie "NEWINSTALL". Jeśli web2py odnajdzie ten plik, to rozumie, że uaktualnienie zostało zrealizowane, dlatego usuwa plik "welcome.w2p" i tworzy w jego miejsce nowy, o tej samej nazwie.</p><p>Aktualna wersja web2py jest zapisywana w polu "VERSION" i spełnia standardową notację wersjonowania, wg której identyfikator budowania jest znacznikiem czasowym budowania.</p><p>Jednostkowe testy web2py znajduja się w</p><pre><code class="code">gluon/tests/</code></pre><p>Istnieją handlery  do połączeń z różnymi serwerami internetowymi:</p><pre><code class="code">cgihandler.py       # nie zalecany
gaehandler.py       # dla Google App Engine
fcgihandler.py      # dla FastCGI
wsgihandler.py      # dla WSGI
isapiwsgihandler.py # dla IIS
modpythonhandler.py # przestarzały</code></pre><p>("fcgihandler" wywołuje "gluon/contrib/gateways/fcgi.py" stworzony przez Allana Saddi) i</p><pre><code>anyserver.py</code></pre><p>który jest skryptem do współdziałania z wieloma serwerami internetowymi, co opisane zostało w rozdziale 13.</p><p>W katalogu "examples" znajdują się trzy przykładowe pliki:</p><pre><code class="code">options_std.py
routes.parametric.example.py
routes.patterns.example.py</code></pre><p>Wszystkie te pliki trzeba skopiować do głównego katalogu (tam gdzie jest plik web2py.py lub web2py.exe) i można je edytować, zgodnie ze swoimi potrzebami. Pierwszy jest opcjonalnym plikiem konfiguracyjnym, który może być przekazany do web2py.py przy pomocy opcji <code>-L</code>. Drugi jest przykładem pliku mapującego adres URL. Będzie ładowany automatycznie, jeśli zmieni się jego nazwę na "routes.py". Trzeci jest alternatywna składnią dla mapowania adresów URL i może być też przemianowany na "routes.py" (lub skopiowany do tego pliku).</p><p>Pliki</p><pre><code class="code">app.example.yaml
queue.example.yaml</code></pre><p>są przykładowymi plikami konfiguracyjnymi używanymi do wdrożeń na Google App Engine. Można przeczytać więcej na ten temat w rozdziale "Receptury wdrożeniowe" i na stronach dokumentacji Google.</p><p>Istnieją również dodatkowe biblioteki, niektóre opracowane przez osoby trzecie:</p><p><strong>feedparser</strong><sup>[<a href="/book/default/reference/42/feedparser" target="_blank">feedparser</a>]</sup>  opracowana przez by Marka Pilgrima dla odczytu kanałów RSS i Atom:</p><pre><code class="code">gluon/contrib/__init__.py
gluon/contrib/feedparser.py</code></pre><p><strong>markdown2</strong><sup>[<a href="/book/default/reference/42/markdown2" target="_blank">markdown2</a>]</sup>  opracowana przez Trenta Micka dla znaczników wiki:</p><pre><code class="code">gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py</code></pre><p><strong>markmin</strong> język znaczników:</p><pre><code class="code">gluon/contrib/markmin</code></pre><p>(patrz <a href="../05/#markmin_markmin_syntax">składnia MARKMIN</a> w celu uzyskania wiecej informacji)</p><p><strong>fpdf</strong> stworzona przez Mariano Reingart dla generowania dokumentów PDF:</p><pre><code>gluon/contrib/fpdf</code></pre><p>Nie są one udokumentowane w tej książce, ale są hostowane i udokumentowane tutaj:</p><pre><code>http://code.google.com/p/pyfpdf/</code></pre><p><strong>pysimplesoap</strong> jest implementacją lekkiego serwerem SOAP stworzona przez  Mariano Reingarta:</p><pre><code class="code">gluon/contrib/pysimplesoap/</code></pre><p><strong>simplejsonrpc</strong> jest lekkim klientem JSON-RPC stworzonym przez Mariano Reingarta: <div class="inxx">jsonrpc</div></p><pre><code>gluon/contrib/simplejsonrpc.py</code></pre><p><strong>memcache</strong><sup>[<a href="/book/default/reference/42/memcache" target="_blank">memcache</a>]</sup>  API Pythona stworzone przez Evana Martina:</p><pre><code>gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py</code></pre><p><strong>redis_cache</strong> <div class="inxx">redis</div> jest modułem pamięci podręcznej dla bazy danych redis:</p><pre><code>gluon/contrib/redis_cache.py</code></pre><p><strong>gql</strong>, port DAL dla Google App Engine:</p><pre><code class="code">gluon/contrib/gql.py</code></pre><p><strong>memdb</strong>, port DAL górnej części memcache:</p><pre><code class="code">gluon/contrib/memdb.py</code></pre><p><strong>gae_memcache</strong> to API wykorzystujące memcache dla Google App Engine:</p><pre><code class="code">gluon/contrib/gae_memcache.py</code></pre><p><strong>pyrtf</strong><sup>[<a href="/book/default/reference/42/pyrtf" target="_blank">pyrtf</a>]</sup>  do generowania dokumentów Rich Text Format (RTF), opracowana przez Simona Cusacka i  poprawiona przez Granta Edwardsa:</p><pre><code class="code">gluon/contrib/pyrtf/</code></pre><p><strong>PyRSS2Gen</strong><sup>[<a href="/book/default/reference/42/pyrss2gen" target="_blank">pyrss2gen</a>]</sup>  opracowana przez Dalke Scientific Software do generowania kanałów RSS:</p><pre><code class="code">gluon/contrib/rss2.py</code></pre><p><strong>simplejson</strong><sup>[<a href="/book/default/reference/42/simplejson" target="_blank">simplejson</a>]</sup>  standardowa biblioteka do paesowania i pisania obiektów JSON opracowana przez Boba Ippolito:</p><pre><code class="code">gluon/contrib/simplejson/</code></pre><p><strong>Google Wallet</strong> <sup>[<a href="/book/default/reference/42/googlewallet" target="_blank">googlewallet</a>]</sup> dostarcza przyciski "pay now" linkujący Google jako procesor płatności:</p><pre><code class="code">gluon/contrib/google_wallet.py</code></pre><p><strong>Stripe.com</strong> <sup>[<a href="/book/default/reference/42/stripe" target="_blank">stripe</a>]</sup> dostarcza proste API do przyjmowania płatności kartami kredytowymi::</p><pre><code class="code">gluon/contrib/stripe.py</code></pre><p><strong>AuthorizeNet</strong> <sup>[<a href="/book/default/reference/42/authorizenet" target="_blank">authorizenet</a>]</sup> dostarcza API do przyjmowania płatności kartami kredytowymi poprzez sieć Authorize.net</p><pre><code class="code">gluon/contrib/AuthorizeNet.py</code></pre><p><strong>Dowcommerce</strong> <sup>[<a href="/book/default/reference/42/dowcommerce" target="_blank">dowcommerce</a>]</sup> API przetwarzania kart kredytowych:</p><pre><code class="code">gluon/contrib/DowCommerce.py</code></pre><p><strong>PaymentTech</strong> API przetwarzania kart kredytowych::</p><pre><code class="code">gluon/contrib/paymentech.py</code></pre><p><strong>PAM</strong><sup>[<a href="/book/default/reference/42/PAM" target="_blank">PAM</a>]</sup>  API uwierzytelniania stworzone przez Chrisa AtLee:</p><pre><code class="code">gluon/contrib/pam.py</code></pre><p>Klasyfikator Bayesian do wypełniania bazy danych danymi fikcyjnymi w celach testowych:</p><pre><code class="code">gluon/contrib/populate.py</code></pre><p>Plik z API do uruchamiania na Heroku.com : <div class="inxx">heroku</div></p><pre><code class="code">gluon/contrib/heroku.py</code></pre><p>Plik umożliwiający interakcje z paskiem zadań w Windows, gdy web2py jest uruchomiony jako usługa:</p><pre><code class="code">gluon/contrib/taskbar_widget.py</code></pre><p>Opcjonalne <strong>login_methods</strong> i login_forms używane do uwierzytelniania:</p><pre><code class="code">gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py</code></pre><p>Paltforma web2py zawiera również folder z przydatnymi skryptami, w tym</p><pre><code class="code">scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py</code></pre><p>Skrypty <code>setup-web2py-*</code> są szczególnie przydatne, ponieważ próbują realizować od podstaw pełną instalację i konfigurację środowiska produkcyjnego web2py. Niektóre z nich zostały omówione w rozdziale 14, ale wszystkie z nich zawierają wewnątrz opis dokumentacyjny, który wyjaśnia ich przeznaczenie i używanie.</p><p>Wreszcie web2py zawiera pliki wymagane do budowy dystrybucji binarnej.</p><pre><code class="code">Makefile
setup_exe.py
setup_app.py</code></pre><p>Są to skrypty konfiguracyjne odpowiednio dla <strong>py2exe</strong> i <strong>py2app</strong> i są tylko wymagane przy budowaniu dystrybucji binarnej web2py. NIGDY NIE ZAJDZIE POTRZEBA ICH URUCHOMIENIA.</p><p>Aplikacje web2py zawierają dodatkowe pliki, zwłaszcza biblioteki JavaScript osób trzecich, takie jak jQuery, calendar i Codemirror. Ich autorzy są wymienieniu w plikach tych bibliotek.</p><h3>Aplikacje</h3><p>Aplikacje stworzone w web2py są złożone z następujących części (znajdujących sie w swoich katalogach):</p><ul><li><strong>models</strong> (modele) opisuje reprezentację danych w tabelach bazy danych i relacje pomiędzy tabelami;</li><li><strong>controllers</strong> (kontrolery) opisuje logikę aplikację i proces przetwarzania;</li><li><strong>views</strong> (widoki) opisuje jak dane powinny być prezentowane użytkownikowi przy użyciu HTML i JavaScript;</li><li><strong>languages</strong> (języki) opisują jak przetłumaczyć ciągy tekstowe w aplikacji na różne obsługiwane języki;</li><li><strong>static files</strong> (pliki statyczne) nie wymagają przetwarzania (np. obrazy, arkusze stylów CSS itd.);</li><li><strong>ABOUT</strong> i <strong>README</strong> - te pliki są oczywiste;</li><li><strong>errors</strong> (błędy) przechowuje sie tu raporty o błędach wygenerowane przez aplikację;</li><li><strong>sessions</strong> (sesje) przechowuje się tu informacje odnoszące się do każdego określonego użytkownika;</li><li><strong>databases</strong> (bazy danych) przechowuje się tu bazy danych SQLite i dodatkowe tabelaryczne informacje;</li><li><strong>cache</strong> (pamięc podręczna) przechowuje się tu buforowane elementy aplikacje;</li><li><strong>modules</strong> (moduły) są tu opcjonalne moduły Pythona;</li><li><strong>private</strong> (prywatne) pliki, które są dostępne dla kontrolerów ale nie bezpośrednio dla programisty;</li><li><strong>uploads</strong> (przesłane) pliki są dostępne dla modeli ale nie bezpośrednio dla programisty (np. pliki przesłane na serwer przez użytkowników aplikacji).</li><li><strong>tests</strong> (testy) jest katalogiem do przechowywania skrytów testów, wyposażenia i makiet.</li></ul><p>Modele, widoki, kontrolery, języki i pliki statyczne są dostępne poprzez interfejs administracyjny [design]. Pliki ABOUT i README oraz katalog errors są również dostępne przez interfejs administracyjny za pośrednictwem odpowiednich elementów menu. Pliki sesji, pamięci podręcznej, modułów i pliki prywatne są dostępne przez aplikacje, ale nie za pomocą interfejsu administracyjnego.</p><p>Wszystko jest uporządkowane w jasne struktury katalogów, które są replikowane dla każdej zainstalowanej aplikacji web2py, choć użytkownik nie potrzebuje bezpośredniego dostępu do systemu plików:</p><p><div class="inxx">o aplikacji</div> <div class="inxx">licecja</div> <div class="inxx">pamięć podręczna</div> <div class="inxx">kontrolery</div> <div class="inxx">bazy danych</div> <div class="inxx">błedy</div> <div class="inxx">języki</div> <div class="inxx">modele</div> <div class="inxx">moduły</div> <div class="inxx">prywatne pliki</div> <div class="inxx">sesje</div> <div class="inxx">pliki statyczne</div> <div class="inxx">testy</div> <div class="inxx">pliki przesłane</div> <div class="inxx">widoki</div> <div class="inxx">__init__.py</div></p><pre><code class="code">__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static</code></pre><p>Plik "__init__.py" to pusty plik wymagany w celu umożliwienia Pythonowi (i web2py) importowanie modułów w katalogu <code>modules</code>.</p><p>Proszę zwrócić uwagę, że aplikacja <strong>admin</strong> po prostu dostarcza interfejs internetowy dla aplikacji web2py w systemie plików serwera. Aplikacje web2py mogą być również tworzone i programowane z poziomu linii poleceń lub poprzez wybrany edytor tekstowy (np. w IDE) – nie jest konieczne korzystanie z interfejsu <strong>admin</strong> w przeglądarce. Nową aplikację można utworzyć ręcznie przez replikowanie powyższej struktury katalogów, np. "applications/newapp/" (lub po prostu rozpakowanie pliku <code>welcome.w2p</code> do katalogu nowej aplikacji). Pliki aplikacji mogą być również stworzone i edytowane z poziomu linii poleceń bez konieczności korzystania z interfejsu <strong>admin</strong>.</p><h3>API</h3><p>Modele, kontrolery i widoki są wykonywane w środowisku, w którym następujące obiekty są już za nas zaimportowane:</p><p><strong>Obiekty globalne:</strong> <div class="inxx">request</div> <div class="inxx">response</div> <div class="inxx">session</div> <div class="inxx">cache</div></p><pre><code class="code">request, response, session, cache</code></pre><p><strong>Umiędzynarodowienie :</strong> <div class="inxx">T</div> <div class="inxx">umiędzynarodowienie</div></p><pre><code class="code">T</code></pre><p><strong>Nawigacja:</strong> <div class="inxx">redirect</div> <div class="inxx">HTTP</div></p><pre><code class="code">redirect, HTTP</code></pre><p><strong>Helpery:</strong> <div class="inxx">helpery</div></p><pre><code class="code">XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON</code></pre><p><strong>Formularze i tabele</strong></p><pre><code>SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)</code></pre><p><strong>Walidatory:</strong> <div class="inxx">walidatory</div></p><pre><code class="code">CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL</code></pre><p><strong>Baza danych:</strong> <div class="inxx">DAL</div></p><pre><code class="code">DAL, Field</code></pre><p>W celu zachowania wstecznej kompatybilności <code>SQLDB=DAL</code> i <code>SQLField=Field</code>. Zachęcamy do stosowania nowej składni <code>DAL</code> i <code>Field</code>, zamiast starej.</p><p>W bibliotekach są zdefiniowane inne obiekty i moduły, ale nie są one importowane automatycznie, ponieważ używane są rzadko.</p><p>Podstawowe encje API w środowisku wykonawczym web2py, to <code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>, <code>URL</code>, <code>HTTP</code>, <code>redirect</code> i <code>T</code>. Są one omówione niżej.</p><p>Kilka obiektów i funkcji, w tym <strong>Auth</strong>, <strong>Crud</strong> i <strong>Service</strong> są zdefiniowane w "gluon/tools.py" i jeśli są potrzebne, to muszą zostać zaimportowane:</p><pre><code class="code">from gluon.tools import Auth, Crud, Service</code></pre><p>Są one importowane w <code>db.py</code> w aplikacji szkieletowej.</p><h4>Dostęp do API z modułów Pythona</h4><p>Twoje modele lub kontrolery mogą importować moduły Pythona, które do działania wymagają zastosowania jakichś interfejsów API web2py API. Sposobem na to jest ich zaimportowanie:</p><pre><code>from gluon import *</code></pre><p>W rzeczywistości, każdy moduł Pythona, jeśli nawet nie został zaimportowany przez aplikację web2py, może importować API web2py, jeśli web2py jest w <code>sys.path</code>.</p><p>Choć jest jedno zastrzeżenie. Web2py definiuje niektóre obiekty globalne (request, response, session, cache, T), które mogą istnieć tylko wtedy, gdy obecne jest żądanie HTTP (lub zostało ono sfałszowane). Dlatego moduły mogą z nich korzystać tylko wtedy, gdy są wywoływane z aplikacji. Z tego powodu są one umieszczane w kontenerze wywołującym <code>current</code>, który jest obiektem lokalnego wątku. Oto przykład.</p><p>Utwórz moduł "/myapp/modules/test.py" zawierający:</p><pre><code>from gluon import *
def ip(): return current.request.client</code></pre><p>Teraz w kontrolerze "myapp" możesz napisać</p><pre><code>import test
def index():
    return "Twój ip to " + test.ip()</code></pre><p>Zwróć uwagę na kilka rzeczy:</p><ul><li>Wyrażenie <code>import test</code> wyszukuje moduł najpierw w folderze bieżącej aplikacji, następnie w folderach wykazanych w <code>sys.path</code>. Dlatego moduły poziomu aplikacji zawsze mają pierwszeństwo przed modułami Pythona. Umożliwia to, aby różne aplikacje korzystały bez konfliktu z różnych wersji swoich modułów.</li><li>Różni użytkownicy mogą wywoływać równocześnie tą sama akcję <code>index</code>, która wywołuje funkcję w module bez powodowania konfliktu, ponieważ obiekt <code>current.request</code> jest innym obiektem w każdym wątku. Wystarczy zachować ostrożność, aby nie przejść do <code>current.request</code> poza funkcjami lub klasami w module (czyli na najwyższym poziomie).</li><li>Wyrażenie <code>import test</code> jest skrótem wyrażenia <code>from applications.appname.modules import test</code>. Używając dłuższej składni można zaimportować moduły z innej aplikacji.</li></ul><p>W celu jednolitości z normalnym zachowaniem Pythona, web2py domyślnie nie przeładowuje modułów po wprowadzeniu zmian. Lecz można to zmienić. Aby włączyć możliwość automatycznego przeładowywania modułów, trzeba użyć funkcję <code>track_changes</code> w sposób następujący (zwykle w pliku modelu, przed jakimkolwiek wyrażeniem import):</p><pre><code class="code">from gluon.custom_import import track_changes; track_changes(True)</code></pre><p>Od teraz, za każdym razem, moduł jest importowany, importer sprawdza, czy plik źródłowy Pythona (.py) został zmieniony. Jeśli tak, to moduł zostanie przeładowany.</p><blockquote>Nie wywołuj track_changes w samych modułach.</blockquote><p>Śledzenie zmian obywa się tylko dla modułów, które są przechowywane w aplikacji. Moduły importujące <code>current</code> uzyskują dostęp do:</p><ul><li><code>current.request</code></li><li><code>current.response</code></li><li><code>current.session</code></li><li><code>current.cache</code></li><li><code>current.T</code></li></ul><p>oraz każdej innej zmiennej aplikacji wybranej do przechowywania w current. Na przykład. możnaby zrobić taki model</p><pre><code>auth = Auth(db)
from gluon import current
current.auth = auth</code></pre><p>co spowoduje, że teraz wszystkie moduły mogą mieć dostęp do <code>current.auth</code>.</p><p>Wyrażenia <code>current</code> i <code>import</code> tworzą pełnowartościowy mechanizm do budowania rozszerzalnych i mogących być wielokrotnie używanych modułów dla aplikacji.</p><blockquote>Uważaj! Biorąc <code>from gluon import current</code>, dobrze jest użyć <code>current.request</code>
i którykolwiek z innych obiektów lokalnego wątku, ale nigdy nie należy przypisywać
go do zmiennych globalnych w module, tak jak tu
<pre><code>request = current.request # ŹLE! NIEBEZPIECZNIE!</code></pre>
ani też nie należy przypisywać go do atrybutu klasy
<pre><code>class MyClass:
    request = current.request # ŹLE! NIEBEZPIECZNIE!</code></pre>
To dlatego, że obiekt lokalnego wątku musi być ekstrahowany w czasie wykonania.
Natomiast zmienne globalne są definiowane tylko raz, podczas importowania modelu
po raz pierwszy.</blockquote><p>Inne zastrzeżenie dotyczy operacji z pamięcią podręczną. Nie można używać obiektu <code>cache</code> do dekorowania funkcji w modułach, dlatego że nie zachowuje się on zgodnie z oczekiwaniami. Aby buforować funkcje <code>f</code> w module musi się użyć <code>lazy_cache</code>:</p><pre><code class="code">from gluon.cache import lazy_cache

@lazy_cache('key', time_expire=60, cache_model='ram')
def f(a,b,c,): ....</code></pre><p>Pamiętaj, że klucz jest określany przez użytkownika, ale musi on być jednoznacznie powiązany z funkcją. Jeśli zostanie pominięty, to web2py określi go automatycznie.</p><h3>Obiekt <code>request</code></h3><p><div class="inxx">request</div> <div class="inxx">Storage</div> <div class="inxx">request.cookies</div> <div class="inxx">user_agent</div></p><p>Obiekt <code>request</code> jest instancją wszechobecnej klasy web2py o nazwie <code>gluon.storage.Storage</code>, która rozszerza klasę <code>dict</code> Pythona. W zasadzie jest to słownik, ale wartości jego elementów mogą być również dostępne jako atrybuty:</p><pre><code class="code">request.vars</code></pre><p>jest tym samym, co:</p><pre><code class="code">request['vars']</code></pre><p>W przeciwieństwie do słownika, jeśli atrybut (lub klucz) nie istnieje, to nie jest zgłaszany wyjątek. Zamiast tego zwracane jest <code>None</code>.</p><blockquote>Czasem jest to przydatne do tworzenia własnych obiektów Storage. Można to zrobić
następująco:
<pre><code class="code">from gluon.storage import Storage
my_storage = Storage() # pusty obket storage
my_other_storage = Storage(dict(a=1, b=2)) # konwersja słownika do Storage</code></pre></blockquote><p>Obiekt <code>request</code> ma następujące elementy (atrybuty), z których niektóre również są dostępne w instancji klasy <code>Storage</code>:</p><ul><li><code>request.cookies</code>: obiekt <code>Cookie.SimpleCookie()</code> zawierający ciasteczka przekazywane przez żądania HTTP. Działa on jak słownik ciasteczek. Każde ciasteczko jest obiektem Morsel <sup>[<a href="/book/default/reference/42/morsel" target="_blank">morsel</a>]</sup>;</li><li><code>request.env</code>: obiekt <code>Storage</code> zawierający zmienne środowiskowe przekazywane do kontrolera, w tym zmienne nagłówka HTTP z żądania HTTP i standardowe parametry WSGI. Wszystkie zmienne środowiskowe są konwertowane na małe litery a kropki na znaki podkreślenia w celi łatwiejszego zapamiętania;</li><li><code>request.application</code>: nazwa żądanej aplikacji;</li><li><code>request.controller</code>: nazwa żądanego kontrolera;</li><li><code>request.function</code>: nazwa żądanej funkcji;</li><li><code>request.extension</code>: rozszerzenie żądanej akcji. Domyślną wartością jest "html". Jeśli kontroler zwraca słownik i nie określa widoku, to jest używany do określenia rozszerzenia pliku widoku, który będzie renderował słownik (parsowany w <code>request.env.path_info</code>);</li><li><code>request.folder</code>: słownik aplikacji. Na przykład, jeśli aplikacją jest "welcome", <code>request.folder</code> zostaje ustawione na ścieżkę bezwzględną "/path/to/welcome". W programie należy zawsze używać tej zmiennej oraz funkcji <code>os.path.join</code> do budowy ścieżek do plików, do których potrzeba uzyskać dostęp. Chociaż web2py zawsze używa ścieżek bezwzględnych, to dobrą praktyką jest niezmienianie nigdy jawnie bieżącego folderu roboczego (cokolwiek nim jest) ponieważ nie jest to bezpieczne dla wątku;</li><li><code>request.now</code>: obiekt <code>datetime.datetime</code> przechowujący datę i czas bieżącego żądania;</li><li><code>request.utcnow</code>: obiekt <code>datetime.datetime</code> przechowujący datę i czas UTC bieżącego żądania;</li><li><code>request.args</code>: lista parametrów ścieżki URL występujących po nazwie funkcji kontrolera; ekwiwalent <code>request.env.path_info.split('/')[3:]</code></li><li><code>request.vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający wszystkie parametry żądania;</li><li><code>request.get_vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający tylko parametry przekazane do ciąga zapytania (żądanie dla <code>/a/c/f?var1=1&amp;var2=2</code> będzie się kończyć ciągiem <code>{var1: "1", var2: "2"}</code>);</li><li><code>request.post_vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający tylko parametry przekazane do ciała żądania (zwykle w żądaniach POST, PUT, DELETE);</li><li><code>request.client</code>: adres IP klienta, zgodnie z ustaleniem <code>request.env.http_x_forwarded_for</code>, jeśli obecne, a jeśli nie to przez <code>request.env.remote_addr</code>. Chociaż jest to użyteczne, to jednak nie należy temu ufać, ponieważ <code>http_x_forwarded_for</code> może być sfałszowane;</li><li><code>request.is_local</code>: <code>True</code> jeśli klientem jest localhost, w przeciwnym razie <code>False</code>. Powinno działać na proxy, jeśli proxy obsługuje <code>http_x_forwarded_for</code>;</li><li><code>request.is_https</code>: <code>True</code> jeśli żądanie używa protokołu HTTPS, w przeciwnym razie <code>False</code>;</li><li><code>request.body</code>: strumień plikowy tylko do odczytu zawierający ciało żądania HTTP. Jest on automatycznie parsowany w celu pobrania <code>request.post_vars</code> i następnie przewinięty. Można go odczytać poprzez <code>request.body.read()</code>;</li><li><code>request.ajax</code> True jeśli funkcja jest wywoływana poprzez żądanie Ajax;</li><li><code>request.cid</code> jest to identyfikator komponentu, który wygenerował żądanie Ajax (jeśli miało to miejsce). Więcej informacji na ten temat znajduje się w rozdziale 12;</li><li><code>request.requires_https()</code> uniemożliwia dalsze wykonywanie kodu, jeśli żądanie nie jest realizowane poprzez HTTPS i przekierowuje odwiedzającego do bieżącej strony poprzez HTTPS.</li><li><code>request.restful</code> jest to nowy i bardzo przydatny dekorator, który może być wykorzystany do zmiany zachowania akcji web2py przez oddzielne żądania GET/POST/PUSH/DELETE. Jest to omówione w rozdziale 10.</li><li><code>request.user_agent()</code> analizuje pole user_agent w nagłówku żądania i zwraca informację w formie słownika. Jest to przydatne do wykrywania urządzeń mobilnych. Wykorzystuje kod "gluon/contrib/user_agent_parser.py" stworzony przez Rossa Peoples. Aby zobaczyć jak to działa, spróbuj osadzić w widoku następujący kod:</li></ul><pre><code class="code">{{=BEAUTIFY(request.user_agent())}}</code></pre><ul><li><code>request.global_settings</code> <div class="inxx">request.global_settings</div> zawiera ustawienia ogólnosystemowe web2py. Są one ustawiane automatycznie i nie ma potrzeby zmieniania ich. Na przykład <code>request.global_settings.gluon_parent</code> zawiera pełną ścieżkę do folderu web2py, <code>request.global_settings.is_pypy</code> określa czy web2py jest uruchomiony na PyPy;</li><li><code>request.wsgi</code> jest to hak, który umożliwia wywołanie aplikacji WSGI osób trzecich z poziomu akcji.</li></ul><p>Ostatnio dołączono:</p><ul><li><code>request.wsgi.environ</code></li><li><code>request.wsgi.start_response</code></li><li><code>request.wsgi.middleware</code></li></ul><p>ich użycie jest omówione na końcu tego rozdziału.</p><p>Jako przykład, następujące adres na typowym systemie:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&amp;q=2</code></pre><p>da w wyniku następujący obiekt <code>request</code>: <div class="inxx">request</div> <div class="inxx">env</div></p><table><tbody><tr class="first"><td><strong>variable</strong></td><td><strong>value</strong></td></tr><tr class="even"><td><code>request.application</code></td><td><code>examples</code></td></tr><tr><td><code>request.controller</code></td><td><code>default</code></td></tr><tr class="even"><td><code>request.function</code></td><td><code>status</code></td></tr><tr><td><code>request.extension</code></td><td><code>html</code></td></tr><tr class="even"><td><code>request.view</code></td><td><code>status</code></td></tr><tr><td><code>request.folder</code></td><td><code>applications/examples/</code></td></tr><tr class="even"><td><code>request.args</code></td><td><code>['x', 'y', 'z']</code></td></tr><tr><td><code>request.vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr class="even"><td><code>request.get_vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr><td><code>request.post_vars</code></td><td><code>&lt;Storage {}&gt;</code></td></tr><tr class="even"><td><code>request.is_local</code></td><td><code>False</code></td></tr><tr><td><code>request.is_https</code></td><td><code>False</code></td></tr><tr class="even"><td><code>request.ajax</code></td><td><code>False</code></td></tr><tr><td><code>request.cid</code></td><td><code>None</code></td></tr><tr class="even"><td><code>request.wsgi</code></td><td><code>&lt;hook&gt;</code></td></tr><tr><td><code>request.env.content_length</code></td><td><code>0</code></td></tr><tr class="even"><td><code>request.env.content_type</code></td><td></td></tr><tr><td><code>request.env.http_accept</code></td><td><code>text/xml,text/html;</code></td></tr><tr class="even"><td><code>request.env.http_accept_encoding</code></td><td><code>gzip, deflate</code></td></tr><tr><td><code>request.env.http_accept_language</code></td><td><code>en</code></td></tr><tr class="even"><td><code>request.env.http_cookie</code></td><td><code>session_id_examples=127.0.0.1.119725</code></td></tr><tr><td><code>request.env.http_host</code></td><td><code>127.0.0.1:8000</code></td></tr><tr class="even"><td><code>request.env.http_referer</code></td><td><code>http://web2py.com/</code></td></tr><tr><td><code>request.env.http_user_agent</code></td><td><code>Mozilla/5.0</code></td></tr><tr class="even"><td><code>request.env.path_info</code></td><td><code>/examples/simple_examples/status</code></td></tr><tr><td><code>request.env.query_string</code></td><td><code>remote_addr:127.0.0.1</code></td></tr><tr class="even"><td><code>request.env.request_method</code></td><td><code>GET</code></td></tr><tr><td><code>request.env.script_name</code></td><td></td></tr><tr class="even"><td><code>request.env.server_name</code></td><td><code>127.0.0.1</code></td></tr><tr><td><code>request.env.server_port</code></td><td><code>8000</code></td></tr><tr class="even"><td><code>request.env.server_protocol</code></td><td><code>HTTP/1.1</code></td></tr><tr><td><code>request.env.server_software</code></td><td><code>Rocket 1.2.6</code></td></tr><tr class="even"><td><code>request.env.web2py_path</code></td><td><code>/Users/mdipierro/web2py</code></td></tr><tr><td><code>request.env.web2py_version</code></td><td><code>Version 2.4.1</code></td></tr><tr class="even"><td><code>request.env.wsgi_errors</code></td><td><code>&lt;open file, mode 'w' at &gt;</code></td></tr><tr><td><code>request.env.wsgi_input</code></td><td></td></tr><tr class="even"><td><code>request.env.wsgi_url_scheme</code></td><td><code>http</code></td></tr></tbody></table><p>To jakie zmienne środowiskowe zostaną zdefiniowane zależy od serwera internetowego. Tutaj założyliśmy użycie wbudowanego serwera WSGI Rocket. Ten zestaw zmiennych nie różni zbyt od tego, jaki otrzymuje się przy użyciu serwera internetowego Apache.</p><p>Zmienne <code>request.env.http_*</code> z nagłówka żądania HTTP są parsowane.</p><p>Zmienne <code>request.env.web2py_*</code> ze środowiska serwera internetowego nie są parsowane, ale są tworzone przez web2py. W przypadku naszej aplikacji trzeba znać lokalizację i wersję oraz czy jest ona uruchomiona na Google App Engine (ponieważ może być konieczna specyficzna optymalizacja).</p><p>Warto również zwrócić uwagę na zmienne <code>request.env.wsgi_*</code>. Są one specyficzne dla adaptera wsgi.</p><h3>Obiekt <code>response</code></h3><div class="inxx">response</div><div class="inxx">response.body</div><div class="inxx">response.cookies</div><div class="inxx">response.download</div><div class="inxx">response.files</div><div class="inxx">response.flash</div><div class="inxx">response.headers</div><div class="inxx">response.meta</div><div class="inxx">response.menu</div><div class="inxx">response.postprocessing</div><div class="inxx">response.render</div><div class="inxx">response.static_version</div><div class="inxx">response.status</div><div class="inxx">response.stream</div><div class="inxx">response.subtitle</div><div class="inxx">response.title</div><div class="inxx">response.toolbar</div><div class="inxx">response.view</div><div class="inxx">response.delimiters</div><div class="inxx">response.js</div><div class="inxx">response.write</div><div class="inxx">response.include_files</div><div class="inxx">response.include_meta</div><div class="inxx">response.optimize_css</div><div class="inxx">response.optimize_js</div><div class="inxx">response._caller</div><div class="inxx">response.models_to_run</div><p>Obiekt <code>response</code> jest inną instancją klasy <code>Storage</code>. Zawiera co następuje:</p><ul><li><code>response.body</code>: obiekt <code>StringIO</code> w którym web2py zapisuje ciało strony wyjściowej. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.cookies</code>: podobne do <code>request.cookies</code> z tą różnicą, że zamiast ciasteczek przesłanych od klienta zawiera ciasteczka ciasteczka wysłane przez serwer do klienta. Ciasteczko sesji jest obsługiwane automatycznie.</li><li><code>response.download(request, db)</code>: metoda używana do implementowania funkcji kontrolera umożliwiającej pobieranie przesyłanych plików. Metoda <code>response.download</code> oczekuje aby ostatni <code>arg</code> w <code>request.args</code> był zakodowaną nazwą pliku (np. nazwą pliku generowaną w czasie przesyłania i zapisana w polu upload). Ekstrahuje ona nazwę przesyłanego pliku oraz nazwę tabeli, jak również oryginalną nazwę pliku. Metoda <code>response.download</code> pobiera dwa opcjonalne argumenty: <code>chunk_size</code> ustawia rozmiar w bajtach dla pakietowego przesyłania strumieniowego (domyślnie to 64K) a <code>attachments</code> określa czy pobrany plik powinien być traktowany jako załącznik czy też nie (domyślnie to <code>True</code>). Trzeba mieć na uwadze, że <code>response.download</code> jest specjalnie przeznaczony dla pobieranie plików związanych z polami upload w <code>db</code>. Używaj <code>response.stream</code> (patrz niżej) dla innych typów pobieranych plików i strumieniowania. Proszę również zwrócić uwagę, że nie jest konieczne użycie <code>response.download</code> w celu uzyskania dostępu do plików przesyłanych do folderu /static – pliki statyczne mogą (i na ogół powinny) być dostępne bezpośrednio poprzez adres URL (np. /app/static/files/myfile.pdf);</li><li><code>response.files</code>: lista plików <code>.css</code>, <code>.js</code>, <code>.coffee</code> i <code>.less</code> wymaganych przez stronę. Będą one automatycznie linkowane w sekcji standardowego widoku "layout.html" za pomocą "web2py_ajax.html". W celu dołączenia nowych plików CSS, JS, COFFEE lub LESS wystarczy je dołączyć do tej listy. Będą obsługiwane duplikaty. Kolejność jest ważna;</li><li><code>response.include_files()</code> generuje znaczniki sekcji head pliku html w celu dołączenia wszystkich <code>response.files</code> (używanych w "views/web2py_ajax.html");</li><li><code>response.flash</code>: opcjonalny parametr, który może zostać zawarty w widokach. Zwykle używany do powiadamiania użytkownika o czymś co się stało.</li><li><code>response.headers</code>: słownik dla nagłówków odpowiedzi HTTP. Platforma web2py ustawia domyślnie kilka nagłówków, w tym "Content-Length", "Content-Type" i "X-Powered-By" (ustawiany na <code>web2py</code>). Platforma web2py ustawia również nagłówki "Cache-Control", "Expires" i "Pragma" w celu zapobiegania buforowaniu po stronie klienta, z wyjątkiem żądań dla plików statycznych, dla których buforowanie po stronie klienta jest włączone. Nagłówki ustawiane przez web2py mogą być nadpisywane lub usuwane oraz mogą być dodawane nowe nagłówki (np. <code>response.headers['Cache-Control'] = 'private'</code>). Nagłówek może zostać usunięty przez usunięcie jego klucza ze słownika, np. <code>del response.headers['Custom-Header']</code>, jednak domyślne nagłówki web2py zostaną po prostu dodane ponownie przed zwróceniem odpowiedzi. Aby uniknąć tego problemu, potrzeba ustawić wartość nagłówka na None, np. w celu usunięcia domyśłnego nagłówka Content-Type, trzeba ustawić <code>response.headers['Content-Type'] = None</code>;</li><li><code>response.menu</code>: opcjonalny parametr, który może być zawarty w widokach, zwykle używany do przekazania nawigacyjnego drzewa menu do widoku. Może być renderowany przez helper MENU;</li><li><code>response.meta</code>: obiekt klasy Storage, który zawiera opcjonalne informacje <code>&lt;meta&gt;</code>, takie jak <code>response.meta.author</code>, <code>.description</code> lub <code>.keywords</code>. Zawartość każdej zmiennej meta jest automatycznie umieszczana w odpowiednim znaczniku <code>META</code> przez kod w widoku "views/web2py_ajax.html", który jest dołączany przez domyślny widok "views/layout.html";</li><li><code>response.include_meta()</code> generuje ciąg znakowy zawierający wszystkie serializowane nagłówki <code>response.meta</code> (używane w widoku "views/web2py_ajax.html");</li><li><code>response.postprocessing</code>: jest to lista funkcji, domyślnie pusta. Funkcje te są wykorzystywane do filtrowania obiektu odpowiedzi na wyjściu akcji, zanim wyjście zostanie zrenderowane przez widok. Listę ta można wykorzystać do implementacji innych języków szablonowania;</li><li><code>response.render(view, vars)</code>: metoda używana do wywołania widoku w sposób jawny wewnątrz kontrolera. Opcjonalny parametr <code>view</code> jest nazwą pliku widoku, <code>vars</code> jest słownikiem nazwanych wartości przekazywanych do widoku;</li><li><code>response.session_file</code>: plik strumienia zawierający sesję;</li><li><code>response.session_file_name</code>: nazwa pliku w którym będą zapisywane sesje;</li><li><code>response.session_id</code>: identyfikator bieżącej sesji. Jest ustalany automatycznie. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.session_id_name</code>: nazwa ciasteczka sesji dla tej aplikacji. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.static_version</code>: numer wersji dla zarządzania statycznymi aktywami;</li><li><code>response.status</code>: kod stanu HTTP, który ma być przekazany do odpowiedzi. Domyślnie, to 200 (OK);</li><li><code>response.stream(file, chunk_size, request=request, attachment=False, filename=None)</code>: gdy kontroler to zwraca, web2py strumieniuje z powrotem zawartość pliku do klienta w blokach o wielkości określonej w <code>chunk_size</code>. Parametr <code>request</code> jest wymagany do korzystania z początku fragmentu w nagłówku HTTP. Parametr <code>file</code>powinien być ścieżką do pliku (z powodu wstecznej kompatybilności, może to być również obiekt otwartego pliku, lecz nie jest to zalecane). Jak wspomniano powyżej, metoda <code>response.download</code> powinna być używana do pobierania przechowywanych plików poprzez pole upload. Metodę <code>response.stream</code> można wykorzystywać w innych przypadkach, takich jak zwracanie pliku tymczasowego lub obiektu StringIO utworzonego przez kontroler. Jeśli parametr <code>attachment</code> to True, nagłówek Content-Disposition zostanie ustawiony na "attachment", a jeśli <code>filename</code> jest też dostarczone, to zostanie dodany również nagłówek Content-Disposition (ale tylko wtedy, gdy <code>attachment</code> ma wartość True). Jeśli nic nie zawarto w <code>response.headers</code>, to następujące nagłówki odpowiedzi zostaną automatycznie ustawione: Content-Type, Content-Length, Cache-Control, Pragma i Last-Modified (trzy ostatnie będą ustawione w celu umożliwienia przeglądarce buforowania pliku). Aby nadpisać któryś z tych automatycznych ustawień, wystarczy ustawić go w <code>response.headers</code> przed wywołaniem <code>response.stream</code>;</li><li><code>response.subtitle</code>: opcjonalny parametr, który może zostać zawarty w widokach. Powinien zawierać podtytuł strony;</li><li><code>response.title</code>: opcjonalny parametr, który może zostać zawarty w widokach. Powinien zawierać tytuł strony i powinien być renderowany wewnątrz znacznika title HTML w sekcji header.</li><li><code>response.toolbar</code>: funkcja umożliwiająca osadzenie paska narzędziowego na stronie do celów debugowania <code>{{=response.toolbar()}}</code>. Ten pasek narzędziowy wyświetla żądania, odpowiedzi, zmienne sesji oraz czas dostępu do bazy danych w każdym zapytaniu;</li><li><code>response._vars</code>: ta zmienna jest dostępna tylko w widoku, nie w akcji. Zawiera wartości zwracane przez akcję do widoku;</li><li><code>response._caller</code>: jest to funkcja opakowująca wszystkie wywołania akcji. Domyślnie jest to funkcja identyczna, ale może zostać zmodyfikowana w celu wyłapania specjalnych typów wyjątków i ich dodatkowym zarejestrowaniu w dzienniku; <code>  response._caller = lambda f: f()
  </code></li><li><code>response.optimize_css</code>: można ustawić na "concat,minify,inline" w celu łączenia, minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py;</li><li><code>response.optimize_js</code>: można ustawić na "concat,minify,inline" w celu łączenia, minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py;</li><li><code>response.view</code>: nazwa szablonu widoku, który musi renderować stronę. Domyślnie ustawione jest na: <code class="code">  "%s/%s.%s" % (request.controller, request.function, request.extension)
  </code> lub jeżeli powyższy plik nie może zostać zlokalizowany, to na <code class="code">  "generic.%s" % (request.extension)
  </code> Można zmienić wartość tej zmiennej w celu zmodyfikowania pliku widoku związanego z określona akcją.</li><li><code>response.delimiters</code> domyślnie to <code>('{{','}}')</code>. Pozwala to na zmianę separatora kodu osadzanego w widokach;</li><li><code>response.xmlrpc(request, methods)</code>: gdy kontroler to zwraca, funkcja udostępnia metody poprzez XML-RPC<sup>[<a href="/book/default/reference/42/xmlrpc" target="_blank">xmlrpc</a>]</sup> . Funkcja ta jest przestarzała ponieważ dostępne są lepsze mechanizmy opisane w rozdziale 10;</li><li><code>response.write(text)</code>: metoda do wpisywania tekstu do ciała strony wyjściowej;</li><li><code>response.js</code> może zawierać kod JavaScript. Kod ten będzie wykonywany tylko jeśli odpowiedź jest odbierana przez komponent web2py, tak jak opisano to w rozdziale 12;</li><li><code>response.models_to_run</code> <span class="anchor" id="markmin_response_models_to_run"></span> zawiera listę wyrażeń regularnych wybierających to co modele uruchamiają;<ul><li>Domyślnie jest ustawiane dla ładowania plików /a/models/*.py, /a/models/c/*.py i /a/models/c/f/*.py gdy żądany jest <code>/a/c/f</code>. Można ustawić np. <code>response.models_to_run = ['myfolder/']</code> aby wymuszać tylko modele wewnątrz podfolderu <code>models/myfolder</code> aplikacji;</li><li>NB: <code>response.models_to_run</code> jest listą wyrażeń regularnych a nie listą ścieżek do pliku. Wyrażenia regularne są względne w stosunku do folderu models/, tak więc każdemu plikowi modelu odpowiada jedna ścieżka do pliku, który ma być wykonany. Należy również zwrócić uwagę, że to nie może wpływać na żadne modele które zostały już ewaluowane, ponieważ zostały wcześniej posortowane alfabetycznie. Tak jest, jeśli warunkowy model dla kontrolera orange to orange/orange_model.py i ustawiono wyrażenie regularne na [.*], którego zmiany nie wpływają na żaden poprzednio odrzucony model do załadowania, taki jak apple/apple_model.py – dopasowuje to nowe wyrażenie regularne, ale będzie to ewaluowane i odrzucane zanim orange/orange_model.py zmieni wyrażenie regularne;</li><li>Oznacza to, że jeśli chce się użyć models_to_run w celu udostępnienia warunkowych modeli pomiędzy kontrolerami, to trzeba umieścić model w podfolderze, w którym elementy są sortowane malejąco, taki jak zzz i następnie użycie wyrażenia regularnego 'zzz'.</li></ul></li></ul><p>Ponieważ <code>response</code> jest obiektem <code>gluon.storage.Storage</code>, to może być zastosowane do przechowywania innych atrybutów, które chce się przekazać do widoku. Chociaż nie ma technicznych ograniczeń, naszym zaleceniem jest przechowywanie tylko zmiennych, które mają być renderowane przez wszystkie strony z ogólnym układem ("layout.html").</p><p>W każdym razie, zdecydowanie sugerujemy aby utrzymywać zmienne wymienione tutaj:</p><pre><code class="code">response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*</code></pre><p>ponieważ w ten sposób łatwiej jest zamienić standardowy plik "layout.html", na taki, który stosuje ten sam zestaw zmiennych.</p><p>W starszych wersjach web2py używano <code>response.author</code> zamiast <code>response.meta.author</code> i podobne do innych meta atrybutów.</p><h3>Obiekt <code>session</code></h3><p><div class="inxx">session</div> <div class="inxx">session.connect</div> <div class="inxx">session.forget</div> <div class="inxx">session.secure</div> Obiekt <code>session</code> jest jedną z instancji klasy <code>Storage</code>. Cokolwiek zostanie zapisywane w <code>session</code>, na przykład:</p><pre><code class="code">session.myvariable = "hello"</code></pre><p>może być odzyskane w późniejszym czasie:</p><pre><code class="code">a = session.myvariable</code></pre><p>tak długo, jak kod jest wykonywany w ramach tej samej sesji przez tego samego użytkownika (o ile użytkownik nie usunie ciasteczek sesji a sesja nie wygasła). Ponieważ <code>session</code> jest obiektem <code>Storage</code>, próba uzyskania dostępu do atrybutu (klucza), który nie został ustawiony nie zgłasza wyjątku, zamiast tego zwraca <code>None</code>.</p><p>Obiekt sesji ma trzy ważne metody. Jedna z nich, to <code>forget</code>:</p><pre><code class="code">session.forget(response)</code></pre><p>Informuje ona web2py, aby nie zapisywał sesji. Powinna być stosowana w tych kontrolerach, których akcje są wywoływane często i nie ma potrzeby śledzenia aktywności użytkownika. Metoda <code>session.forget()</code> zapobiega przed przepisywaniem pliku sesji niezależnie od tego czy był on modyfikowany. Metoda <code>session.forget(response)</code> dodatkowo otwiera i zamyka plik sesji. Rzadko trzeba korzystać z tej metody, ponieważ sesje nie są zapisywana, gdy nie zostały zmienione. Jednakże, jeśli strona wykonuje wiele jednoczesnych żądań Ajax, to dobrym pomysłem na wywoływanie akcji poprzez Ajax jest wywołanie <code>session.forget(response)</code> (zakładając, że sesja nie jest potrzebna dla akcji). W przeciwnym razie każda akcja Ajax będzie musiała czekać na zakończenie poprzedniej akcji (i odblokowanie pliku sesji) przed kontynuowaniem, co spowalnia ładowanie strony. Należy mieć na uwadze, że sesje nie zostają zablokowane, gdy są przechowywane w bazie danych.</p><p>Inna metoda to:</p><pre><code class="code">session.secure()</code></pre><p>który powiadamia web2py, aby ustawił ciasteczko sesji jako bezpieczne ciasteczko. Powinno się to ustawiać, jeśli aplikacja używa połączenia https. Przez ustawienie ciasteczka sesji jako bezpiecznego, serwer prosi przeglądarkę aby nie odsyłał z powrotem ciasteczka do serwera, chyba że przez połączenie https.</p><p>Następną metodą jest <code>connect</code>. Domyślnie sesje są przechowywane w systemie plików a ciasteczko jest używane do przechowywania i pobierania <code>session.id</code>. Używając metody connect jest możliwe poinformowanie web2y aby przechowywał sesje w bazie danych albo w ciasteczkach, eliminując konieczność dostępu do systemu plików w zarządzaniu sesją.</p><p>Na przykład, aby <strong>przechować sesje w bazie danych</strong>:</p><pre><code class="code">session.connect(request, response, db, masterapp=None)</code></pre><p>gdzie <code>db</code> jest nazwą otwartego połączenia z bazą danych (tak jak zwrócił to DAL). Powiadamia to web2py, że chce się przechować sesje w bazie danych a nie w systemie plików. Metoda <code>session.connect</code> musi być wywołana po <code>db=DAL(...)</code>, ale przed jakąkolwiek logika wymagajacą sesji, na przykład, konfiguracją <code>Auth</code>.</p><p>web2py tworzy tabelę:</p><pre><code class="code">db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))</code></pre><p>i zapisze speklowane sesje w polu <code>session_data</code>.</p><p>Opcja <code>masterapp=None</code> (domyślnie) powiadamia web2py aby próbował odzyskać istniejącą sesję z nazwą w <code>request.application</code>, w uruchomionej aplikacji.</p><p>Jeśli chce się aby dwie lub więcej aplikacji współdzieliły sesje, trzeba ustawić <code>masterapp</code> na nazwę głównej aplikacji.</p><p>Aby zamiast tego <strong>zapisać sesje w ciasteczkach</strong> można zrobić:</p><pre><code class="code">session.connect(request,response,cookie_key='yoursecret',compression_level=None)</code></pre><p>Tutaj <code>cookie_key</code> to symetryczny klucz szyfrowania. <code>compression_level</code> jest opcjonalnym poziomem szyfrowania <code>zlib</code>.</p><p>Natomiast sesje w ciasteczku są często zalecane z powodu skalowalności, gdyż mają ograniczoną wielkość. Duże sesje będą powodować załamanie się ciasteczek.</p><p>Można sprawdzić stan swojej aplikacji w dowolnym momencie przez wydrukowanie zmiennych systemowych  <code>request</code>, <code>session</code> i <code>response</code>. Jednym sposobem na wykonanie tego jest utworzenie dedykowanej akcji:</p><pre><code class="code">def status():
    return dict(request=request, session=session, response=response)</code></pre><p>W widoku "generic.html" osiąga się to używając <code>{{=response.toolbar()}}</code>.</p><h4>Nie przechowuj w sesji klas zdefiniowanych przez użytkownika</h4><p>Zmienne przechowywane w sesji są zachowywane pomiędzy żądaniami dzięki  serializacji.</p><p>Sesje są pobierane przed wykonaniem kodu modułu, a więc przed zdefiniowaniem klas. Dlatego klasy zdefiniowane przez użytkownika nie mogą zostać speklowane.</p><p>Klasy zdefiniowane w modułach są również szarą strefą i nie powinny być umieszczane w pamięci. Będą one działać przez większość czasu ale w końcu mogą załamać sesję. Tak jest ponieważ, na przykład, jeśli zrestartuje się serwer internetowy w chwili pobierania sesji przez użytkownika, to może się zdarzyć, że moduł zostanie zaimportowany. Ten sam problem wystąpi podczas uruchamiania przez serwer internetowy nowego procesu roboczego oraz w środowisku rozproszonym.</p><h4>Oddzielne sesje</h4><p>Jeśli sesje są przechowywane w systemie plików i ma się ich wiele, to system plików może stać się wąskim gardłem. Jedno z rozwiązań jest następujące:</p><pre><code class="code">session.connect(request, response, separate=True)</code></pre><p>Ustawiając <code>separate=True</code> web2py będzie przechowywał sesje nie w folderze "sessions/" ale w podfolderze folderu "sessions/". Podfolder będzie tworzony automatycznie. Sesje z tym samym przedrostkiem będą zapisywane w tym samym podfolderze. Znowu trzeba mieć na uwadze, że powyższe wyrażenie musi być wywołane przed jakąkolwiek logiką, którą może wymagać sesja.</p><h3>Obiekt <code>cache</code></h3><p><div class="inxx">cache</div> <div class="inxx">cache.ram</div> <div class="inxx">cache.disk</div> Globalny obiekt <code>cache</code> jest również dostępny w środowisku uruchomieniowym web2py. Ma on dwa atrybuty:</p><ul><li><code>cache.ram</code>: pamięć podręczna aplikacji w głównej pamięci;</li><li><code>cache.disk</code>: pamięć podręczna aplikacji na dysku.</li></ul><p>Atrybut <code>cache</code> jest wywoływalny, co pozwala na stosowanie go jako dekoratora akcji lub widoków.</p><p>Powyższy przykład buforuje funkcję <code>time.ctime()</code> w RAM:</p><pre><code class="code">def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>Wyjście funkcji <code>lambda: time.ctime()</code> jest buforowane w RAM przez 5 sekund. Ciąg <code>'time'</code> został tu użyty jako klucz.</p><p>Poniższy przykład buforuje funkcję <code>time.ctime()</code> na dysku:</p><pre><code class="code">def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>Wyjście funkcji <code>lambda: time.ctime()</code> jest buforowane na dysku (z wykorzystaniem modułów shelve) na 5 sekund.</p><p>Trzeba mieć na uwadze, że drugi argument <code>cache.ram</code> i <code>cache.disk</code> musi być funkcją lub wywoływalnym obiektem. Jeśli chce się buforować istniejący obiekt, a nie wyjście funkcji, można po prostu zwrócić to przez funkcję lambda:</p><pre><code class="code">cache.ram('myobject', lambda: myobject, time_expire=60*60*24)</code></pre><p>Następny przykład buforuje funkcję <code>time.ctime()</code> zarówno w RAM jak i na dysku:</p><pre><code class="code">def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>Wyjście <code>lambda: time.ctime()</code> jest buforowane na dysku (z wykorzystaniem moduły shelve) a następnie w RAM na 5 sekund. Najpierw web2py przeszukuje pamięć RAM i jeśli nic tam nie znajdzie, to przeszukuje dysk. Jeśli nie ma tego co potrzeba ani w pamieci RAM ani na dysku, to wykonywana jest funkcja <code>lambda: time.ctime()</code> i pamięć podręczna zostaje zaktualizowana. Technika ta jest użyteczna w środowisku wieloprocesorowym. Dwa czasy nie muszą być takie same.</p><p>W poniższym przykładzie buforowane jest wyjście kontrolera funkcji (ale nie widoku) w pamięci RAM:</p><div class="inxx">buforowanie kontrolera</div><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>Słownik zwracany przez <code>cache_controller_in_ram</code> jest buforowany w RAM na 5 sekund. Proszę zwrócić uwagę, że wynik wyboru bazy danych nie może być buforowany bez wykonania najpierw serializacji. Lepszym sposobem jest buforowanie wybranej bazy danych bezpośrednio przy wykorzystaniu argumentu <code>select</code> metody <code>cache</code>.</p><p>Poniższy przykład buforuje wyjście funkcji kontrolera (ale nie widoku) na dysk:</p><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))</code></pre><p>Słownik zwracany przez <code>cache_controller_on_disk</code> jest buforowany na dysku przez 5 sekund. Trzeba pamiętać, że web2py nie może buforować słownika, który zawiera niepeklowane obiekty.</p><p>Możliwe jest również buforowanie widoku. Renderowanie widoku w funkcji kontrolera to trik polegający na tym, aby kontroler zwracał ciąg znakowy. Jest to realizowane przez zwracanie <code>response.render(d)</code> gdzie <code>d</code> jest słownikiem, który chcemy przekazać do widoku. Poniższy przykład buforuje w RAM wyjście funkcji kontrolera (łącznie z renderowanym widokiem):</p><div class="inxx">buforowanie widoku</div><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)</code></pre><p>Funkcja <code>response.render(d)</code> zwraca zrenderowany widok jako ciąg znakowy, który jest teraz buforowany przez 5 sekund. Jest to najlepszy i najszybszy sposób buforowania.</p><blockquote>Zalecamy stosowanie <a href="#markmin_cache_action">@cache.action</a> obsługiwane w web2py &gt; 2.4.6 </blockquote><p>Proszę zwrócić uwagę, że <code>time_expire</code> jest używany do porównania bieżącego czasu z czasem żądanego obiektu, który był ostatnio zapisany w pamięci podręcznej. Nie ma to wpływu na przyszłe żądania. Umożliwia aby <code>time_expire</code> był ustawiany dynamicznie podczas żądania obiektu, a nie ustalany podczas zapisywania obiektu. Na przykład:</p><pre><code class="code">message = cache.ram('message', lambda: 'Hello', time_expire=5)</code></pre><p>Załóżmy teraz, że następujące wywołanie jest wykonane na 10 sekund przed powyższym wywołaniem:</p><pre><code class="code">message = cache.ram('message', lambda: 'Goodbye', time_expire=20)</code></pre><p>Ponieważ <code>time_expire</code> jest ustawione na 20 sekund w drugim wywołaniu i tylko 10 sekund upłynęło od komunikaty, który był zapisany pierwszy, wartość "Hello" będzie pobierana z pamięci podręcznej i nie zostanie zaktualizowana na "Goodbye". 5 sekundowa wartość <code>time_expire</code> w pierwszym wywołaniu nie ma wpływu na drugie wywołanie.</p><p>Ustawienie <code>time_expire=0</code> (lub na wartość ujemną) wymusza, aby buforowana pozycja była odświeżana  (ponieważ czas jaki upłynął od ostatniego zapisu zawsze będzie &gt; 0) a ustawienie <code>time_expire=None</code> wymusza pobieranie wartości buforowanej, niezależnie od czasu jaki upłynął od ostatnie zapisu (jeśli <code>time_expire</code> ma zawsze wartość <code>None</code>, to element buforowany będzie nigdy nie wygasający).</p><p>Z pamięci podręcznej można usunąć jedna lub więcej zmiennych poleceniem</p><div class="inxx">cache clear</div><pre><code class="code">cache.ram.clear(regex='...')</code></pre><p>gdzie <code>regex</code> jest wyrażeniem regularnym dopasowującym wszystkie klucze, jakie chce się usunąć z pamięci podręcznej. Można również usunąć pojedynczy element stosując:</p><pre><code class="code">cache.ram(key, None)</code></pre><p>gdzie <code>key</code> jest kluczem buforowanego elementu.</p><p>Możliwe jest również określenie innych mechanizmów buforowania, takie jak memcache. Memcache jest dostępny poprzez <code>gluon.contrib.memcache</code> i został omówiony w rozdziale 14.</p><blockquote>Bądź ostrożny podczas buforowania, pamiętając, że buforowanie jest zwykle dokonywane
na poziomie aplikacji, a nie na poziomie użytkownika. Jeśli potrzeba, na przykład,
buforować zawartość specyficzną dla użytkownika, to trzeba wybrać klucz, który zawiera
identyfikator użytkownika.</blockquote><blockquote>Aplikacja interfejsu administracyjnego aplikacji umożliwia wyświetlanie przycisków
pamięci podręcznej (i czyszczenia pamięci podręcznej). Dostęp do nich można uzyskać
z poziomu ekranu zarządzania bazą danych.</blockquote><p><span class="anchor" id="markmin_cache_action"></span></p><h4><code>cache.action</code></h4><p>W web2py domyślnie zakłada się, że zwracana zawartość nie będzie buforowana, gdyż zmniejsza to złe skutki niewłaściwego buforowania po stronie klienta.</p><p>Na przykład, gdy wyświetla się formularz użytkownikowi lub listę rekordów, strona internetowa nie powinna być buforowana, gdyż inni użytkownicy mogą w tym czasie wprowadzać nowe rekordy do tabeli, która się wyświetla.</p><p>Zamiast tego, jeśli wyświetlana jest strona, której zawartość nie będzie się nigdy zmieniać (lub zmieniać rzadko, np. raz na tydzień), to warto tą strona przechować, ale jeszcze lepiej jest powiadomić klienta, że strona ta jest niezmienna.</p><p>Osiąga się to przez wysyłanie wraz ze stroną kilku specjalnych nagłówków. Gdy przeglądarka klienta odbierze taką zawartość, to przechowa ją w pamięci podręcznej przeglądarki i nie będzie żądać ponownie takiej strony od serwera. Jest to <strong>główny</strong> mechanizm przyśpieszania witryn o dostępie publicznym.</p><p>W wersjach web2py &gt; 2.4.6 wprowadzono nowy dekortor <code>cache.action</code> umożliwiający bardziej inteligentną obsługę takich sytuacji. Dekorator <code>cache.action</code> może zostać użyty do:</p><ul><li>ustawiania inteligentnych nagłówków buforowania;</li><li>odpowiedniego buforowania wyników.</li></ul><blockquote>NB: Jest stosowane dla jednego lub drugiego celu albo obu naraz.</blockquote><p>Użycie request.env.path_info jako klucza w buforowaniu widoku poprzez <code>@cache(request.env.path_info, time_expire=300, cache_model=cache.ram)</code> sprawia kilka problemów, np.:</p><ol><li>Zmienne URL nie są obsługiwane<ul><li>Buforowanie wyniku <em>/app/default/index?<strong>search=foo</strong></em> : przez następne 300 sekund <em>/app/default/index?<strong>search=bar</strong></em> zwróci dokładnie ta samą rzecz co <em>/app/default/index?<strong>search=foo</strong></em>;</li></ul></li><li>Użytkownik nie jest obsługiwany<ul><li>Jakiś użytkownik uzyskuje często dostęp do strony i wybiera ją z pamięci podręcznej. Jednakże, buforowany był wynik <em>/app/default/index</em> przy wykorzystaniu request.env.path_info jako klucz, tak więc inny użytkownik będzie widział stronę, która nie była przeznaczona dla niego;</li><li>Buforowana została strona użytkownika "Bill", gdy "Bill" uzyskał dostęp do strony z pulpitu. Teraz próbuje on uzyskać dostęp z telefonu komórkowego: jeśli przygotowany był szablon dla użytkowników mobilnych, który jest inny od standardowego, to "Joe" nie zobaczy go;</li></ul></li><li>Język nie jest obsługiwany<ul><li>Podczas buforowania strony, jeśli użyje się funkcji T() dla tych samych elementów, strona zostanie zapisana wraz z ustalonym tłumaczeniem;</li></ul></li><li>Metoda żądania nie jest obsługiwana<ul><li>Gdy buforuje się stronę, to należy je buforować tylko wtedy, gdy jest ona wynikiem operacji GET</li></ul></li><li>Kod stan strony nie jest obsługiwany<ul><li>Gdy buforuje się stronę po raz pierwszy, czasami może pójść coś nie tak i zwracana jest piękna strona 404. Przecież nie chcesz buforować błędów.</li></ul></li></ol><p>Zamiast pisać dużo kodu szablonowego rozwiązującego te wszystkie problemy, wystarczy utworzyć <code>cache.action</code>. Inteligentnie używa to nagłówki buforowania pozwalając przeglądarce buforować wynik: jeśli przekaże się do buforowania model, to rozwiązany zostanie automatycznie klucz, w najlepszy sposób, tak że różne wersje tej samej strony mogą być przechowywane i pobierane odpowiednio (np. jedna w języku angielskim a druga w polskim).</p><p>Pobiera to kilka parametrów, z inteligentnymi wartościami domyślnymi:</p><ul><li>time_expire : domyślnie 300 sekund;</li><li>cache_model : domyślnie None. Oznacza to, że @cache.action będzie <strong>tylko</strong> zmieniał nagłówki, aby pozwolić przeglądarce klienta buforować tą zawartość;<ul><li>jeśli przekaże się, np., <code>cache.ram</code>, to wynik zostanie też zapisany w pamięci podręcznej;</li></ul></li><li>prefix : jeśli chce się poprzedzić klucz auto-generated przedrostkiem (przydatne przy usuwaniu go później przez np. <code>cache.ram.clear(prefix*)</code>);</li><li>session : jeśli chce się wziąść po uwagę sesję, domyślnie False;</li><li>vars : jeśli chce się wziąć pod uwagę zmienne URL, domyślnie True;</li><li>lang : jeśli chce się wziąć pod język, domyślnie True;</li><li>user_agent : jeśli chce się wziąć pod uwagę rodzaj przeglądarki użytkownika (<em>ang. user agent</em>), domyślnie False;</li><li>public : jeśli chce się buforować tą samą stronę dla wszystkich odwiedzających, tak że będzie zawsze dostępna, domyślnie True;</li><li>valid_statuses : domyślnie None. cache.client będzie buforował tylko strony z metodą GET, których kod stanu rozpoczyna się os 1,2 lub 3; Można przekazać listę kodów stanu (jeśli chce się aby strony były buforowane z tymi stanami, np. status_codes=[200] spowoduje buforowanie tylko strony, których kod stanu wynosi 200)</li><li>quick : domyślnie None, ale można przekazać listę liter w celu ustawienia właściwej  funkcjonalności:<ul><li><strong>S</strong>ession, <strong>V</strong>ars, <strong>L</strong>ang, <strong>U</strong>ser_agent, <strong>P</strong>ublic np. <code>     @cache.action(time_expire=300, cache_model=cache.ram, quick='SVP')
     </code> jest tym samym co <code>     @cache.action(time_expire=300, cache_model=cache.ram, session=True, vars=True, public=True)
     </code></li></ul></li></ul><p><strong>Obsługiwanie</strong>, opisane wyżej, oznacza np. dla <strong>zmiennych</strong>, że chcąc buforować różne strony, gdy <strong>zmienne</strong> są różne, to <em>/app/default/index?<strong>search=foo</strong></em> nie będzie takie samo jak <em>/app/default/index?<strong>search=bar</strong></em>. To zachowanie jest nadpisywane przez kilka ustawień, tak więc np., jeśli ustawi się <code>session=True, public=True</code>, to drugie wyrazenie zostanie odrzucone.</p><p>Stosuj to mądrze!</p><p><span class="anchor" id="markmin_URL"></span></p><h3>Funkcja <code>URL</code></h3><p><div class="inxx">URL</div> <div class="inxx">funkcja URL</div> Funkcja <code>URL</code> jest jedna z najważniejszych funkcji w web2py. Generuje wewnętrzne ścieżki URL dla akcji i plików statycznych.</p><p>Oto przykład:</p><pre><code class="code">URL('f')</code></pre><p>jest mapowane na</p><pre><code class="code">/[application]/[controller]/f</code></pre><p>Proszę zwrócić uwagę, że wyjście funkcji <code>URL</code> zależy od nazwy bieżącej aplikacji, wywoływanego kontrolera i innych parametrów. Platforma web2py obsługuje mapowanie URL i odwrotne mapowanie URL. Mapowanie URL pozwala przedefiniować format zewnętrznych adresów URL. Jeśli używa się funkcji <code>URL</code> do generowania wszystkich zewnętrznych adresów URL, to następnie trzeba dodać lub zmienić mapowania URL, co zabezpieczy nie działającym linkom w aplikacji web2py.</p><p>Do funkcji <code>URL</code> można przekazać dodatkowe parametry, tj. dodatkowe warunki w ścieżce adresu URL (args) i zmienne zapytań URL (vars):</p><pre><code class="code">URL('f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>jest mapowane na</p><pre><code class="code">/[application]/[controller]/f/x/y?z=t</code></pre><p>Atrybuty <code>args</code> są automatycznie parsowane, dekodowane i w końcu zapisywane w <code>request.args</code>. Podobnie <code>vars</code> są parsowane, dekodowane i zapisywane w <code>request.vars</code>. <code>args</code> i <code>vars</code> dostarczają podstawowe mechanizmy, przy pomocy których web2py wymienia informację z przeglądarką klienta.</p><p>Jeśli <code>args</code> zawiera tylko jeden element, to nie ma potrzeby przekazywania go w liście.</p><p>Można również użyć funkcji <code>URL</code> do generowania adresów URL dla akcji w innych kontrolerach i aplikacjach:</p><pre><code class="code">URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>jest mapowane na</p><pre><code>/a/c/f/x/y?z=t</code></pre><p>Możliwe jest też określenie aplikacji, kontrolera i funkcji przy użyciu nazwanych argumentów:</p><pre><code class="code">URL(a='a', c='c', f='f')</code></pre><p>Jeśli brak jest nazwy aplikacji <em>a</em>, to przyjmowana jest bieżąca aplikacja.</p><pre><code class="code">URL('c', 'f')</code></pre><p>Jeśli brak jest nazwy kontrolera <em>c</em>, to przyjmowany jest bieżący kontroler.</p><pre><code class="code">URL('f')</code></pre><p>Zamiast przekazywania nazwy funkcji kontrolera możliwe jest przekazywanie samej funkcji</p><pre><code class="code">URL(f)</code></pre><p>Z wyżej omówionych powodów, należy zawsze używać funkcji <code>URL</code> do generowania adresów URL plików statycznych aplikacji. Pliki statyczne przechowywane są w podfolderze <code>static</code> (tam kierowane są pliki podczas przesyłania ich za pośrednictwem interfejsu administracyjnego). Platforma web2py udostępnia wirtualny kontroler 'static', którego zadaniem jest pobieranie plików z podfolderu <code>static</code>, ustalenie typu zawartości i strumieniowanie pliku dla klienta. Poniższy przykład generuje adres URL dla pliku statycznego "image.png":</p><pre><code class="code">URL('static', 'image.png')</code></pre><p>jest mapowane na</p><pre><code class="code">/[application]/static/image.png</code></pre><p>Jeśli plik statyczny znajduje się w podfolderze folderu <code>static</code>, można dołączyć podfolder (podfoldery) jako część atrybutu filename. Na przykład, aby wygenerować:</p><pre><code>/[application]/static/images/icons/arrow.png</code></pre><p>trzeba użyć:</p><pre><code class="code">URL('static', 'images/icons/arrow.png')</code></pre><p>Nie ma potrzeby kodowania (zabezpieczania znakami ucieczki) argumentów <code>args</code> i <code>vars</code> - jest to czynione automatycznie.</p><p>Domyślnie rozszerzenie odpowiadające bieżącemu żądaniu (które można znaleźć w <code>request.extension</code>) jest dołączane do funkcji, chyba że request.extension to html (domyślnie). Można to przesłonić dołączając jawnie rozszerzenie jako część nazwy funkcji <code>URL(f='name.ext')</code> lub jako wartość argumentu extension:</p><pre><code class="code">URL(..., extension='css')</code></pre><p>Bieżące rozszerzenie może być zmazane:</p><pre><code class="code">URL(..., extension=False)</code></pre><h4>Bezwzględne adresy URL</h4><p>Domyślnie funkcja <code>URL</code> generuje względne adresy URL. Jednakże, można również generować bezwzględne adresy URL określając argumenty <code>scheme</code> i <code>host</code> (jest to przydatne, na przykład, przy wstawianiu adresów URL w wiadomościach email):</p><pre><code class="code">URL(..., scheme='http', host='www.mysite.com')</code></pre><p>Można automatycznie dołączyć schemat i host bieżącego żądania przez ustawienie tych argumentów na <code>True</code>.</p><pre><code class="code">URL(..., scheme=True, host=True)</code></pre><p>Funkcja <code>URL</code> akceptuje również argument <code>port</code> do określania portu serwera, jeśli to konieczne.</p><h4>Adresy URL z podpisem cyfrowym</h4><div class="inxx">adresy URL z podpisem cfrowym</div><p>Podczas generowania adresu URL, ma się możliwość jego cyfrowego podpisania. Dołącza to zmienną GET <code>_signature</code>, która może być zweryfikowana przez serwer. Można to zrobić w dwojaki sposób.</p><p>Można przekazać do funkcji URL następujące argumenty:</p><ul><li><code>hmac_key</code>: klucz do podpisania adresu URL (ciąg znakowy);</li><li><code>salt</code>: opcjonalny ciąg znakowy będący solą (ciągiem zaburzającym) haszowanie podpisu;</li><li><code>hash_vars</code>: opcjonalna lista nazw zmiennych z ciąga zapytania URL (czyli zmiennych GET), które będą dołączone do sygnatury. Można to również ustawić na <code>True</code> (wartość domyślna) aby dołączać wszystkie zmienne lub na <code>False</code> aby nie dołączać żadnych zmiennych.</li></ul><p>Oto przykład zastosowania:</p><pre><code class="code">KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()</code></pre><p>Sprawia to, że akcja <code>two</code> jest dostępna tylko poprzez adres URL podpisany cyfrowo. Adres URL podpisany cyfrowo wygląda podobnie do tego:</p><pre><code>'/welcome/default/two?a=123&amp;_signature=4981bc70e13866bb60e52a09073560ae822224e9'</code></pre><p>Trzeba mieć na uwadze, że podpis cyfrowy jest weryfikowany przez funkcje <code>URL.verify</code>. Funkcja <code>URL.verify</code> również pobiera argumenty <code>hmac_key</code>, <code>salt</code> i <code>hash_vars</code> opisane powyżej a ich wartości muszą pasować do wartości, które zostały przekazane do funkcji <code>URL</code> podczas tworzenia podpisu cyfrowego.</p><p>Druga i bardziej zaawansowana i bardziej powszechna metoda cyfrowego podpisywania adresów URL to powiązanie tego z uwierzytelnianiem. Najlepiej wyjaśnić to na przykładzie:</p><pre><code class="code">@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()</code></pre><p>W tym przypadku <code>hmac_key</code> jest generowany automatycznie i udostępniany w sesji. Umożliwia to, aby akcja <code>two</code> delegowała kontrole dostępu do akcji <code>one</code>. Jeśli odnośnik został wygenerowany i podpisany, to jest prawidłowy, w innym razie nie. Jeśli odnośnik zostanie skradziony przez innego użytkownika, to będzie nieprawidłowy.</p><p>Dobrą praktyka jest podpisywanie cyfrowo zawsze wywołań zwrotnych Ajax. Jeśli używa się funkcji <code>LOAD</code> web2py, to ma się do dyspozycji argument <code>user_signature</code> służący temu celowi:</p><pre><code>{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}</code></pre><h3><code>HTTP</code> i <code>redirect</code></h3><p><div class="inxx">HTTP</div> <div class="inxx">redirect</div></p><p>Platforma web2py definiuje tylko jeden nowy wyjątek o nazwie <code>HTTP</code>. Ten wyjątek może być wywołany gdziekolwiek w modelu, kontrolerze lub widoku poleceniem:</p><pre><code class="code">raise HTTP(400, "my message")</code></pre><p>Powoduje to, że przepływ sterowania przechodzi z kodu użytkownika z powrotem do web2py i zwraca odpowiedź HTTP podobną do tego:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message</code></pre><p>Pierwszy argument funkcji <code>HTTP</code> to kod stanu HTTP. Drugi argument to ciąg znakowy, który będzie zwracany jako ciało odpowiedzi. Dodatkowe nazwane argumenty są używane do budowy nagłówka odpowiedzi HTTP. Na przyklad:</p><pre><code class="code">raise HTTP(400, 'my message', test='hello')</code></pre><p>generuje:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message</code></pre><p>Jeśli nie chce się zatwierdzić transakcji otwartej bazy danych, to należy ją wycofać przed wywołaniem wyjątku.</p><p>Wszystkie wyjątki inne niż <code>HTTP</code> powodują, że web2py cofa wszystkie otwarte transakcje bazy danych, rejestruje komunikat dotyczący ostatniego wywołania (<em>ang. traceback</em>), wydaje bilet odwiedzającemu i zwraca standardową stronę błędu.</p><p>Oznacza to, że dla przepływu sterowania między stronami może zostać użyty tylko wyjątek <code>HTTP</code>. Inne wyjątki muszą zostać wyłapane przez aplikację, w przeciwnym razie są one biletowane przez web2py.</p><p>Polecenie:</p><pre><code class="code">redirect('http://www.web2py.com')</code></pre><p>jest po prostu skrótem dla:</p><pre><code class="code">raise HTTP(303,
           'Nastąpi przekierowanie &lt;a href="%s"&gt;tutaj&lt;/a&gt;' % location,
           Location='http://www.web2py.com')</code></pre><p>Nazwane argumenty metody inicjatora <code>HTTP</code> są tłumaczone na dyrektywy nagłówka HTTP, w tym przypadku, docelowe miejsce przekierowania. Wyrażenie <code>redirect</code> pobiera drugi opcjonalny argument, który jest kodem stanu HTTP dla przekierowania (domyślnie 303). Zmień ten numer na 307 dla tymczasowego przekierowania lub na 301 dla stałego przekierowania.</p><p>Najczęstszym sposobem użycia przekierowania jest przekierowanie do innej strony tej samej aplikacji i (opcjonalnie) przekazanie parametrów:</p><pre><code class="code">redirect(URL('index', args=(1,2,3), vars=dict(a='b')))</code></pre><p>W rozdziale 12 omówimy komponenty web2py. Wykonują one żądania Ajax dla akcji web2py. Jeśli wywoływana akcja wykonuje przekierowanie, to można spowodować, że żądanie Ajax nastąpi po przekierowaniu albo że cała strona wykona przekierowanie żądania Ajax. W tym drugim przypadku można ustawić:</p><pre><code class="code">redirect(...,client_side=True)</code></pre><h3>Umiędzynarodowienie i pluralizacja za pomocą <code>T</code></h3><p><div class="inxx">T</div> <div class="inxx">umiędzynarodowienie</div></p><p>Obiekt <code>T</code> jest tłumaczem językowym. Stanowi pojedynczą globalną instancję klasy <code>gluon.language.translator</code> web2py. Wszystkie stałe łańcuchowe (i tylko stałe łańcuchowe) powinny być oznaczone przez <code>T</code>, na przykład:</p><pre><code class="code">a = T("hello world")</code></pre><p>Ciągi znakowe oznaczone przez <code>T</code> są identyfikowane przez web2py jako wymagające tłumaczenia i będą tłumaczone gdy kod (w modelu, kontrolerze lub widoku) będzie wykonywany. Jeśli ciąg znakowy do tłumaczenia nie jest stała lecz zmienną, to będzie dodany do pliku tłumaczenia w czasie wykonania (z wyjątkiem GAE)w celu późniejszego przetłumaczenia.</p><p>Obiekt <code>T</code> może również zawierać zmienne interpolowane i obsługiwać wiele równoważnych składni:</p><pre><code class="code">a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')</code></pre><p>Zalecana jest ostatnia składnia ponieważ czyni tłumaczenie najłatwiejszym. Pierwszy ciąg jest tłumaczony zgodnie z żądanym plikiem językowym, a zmienna <code>name</code> jest zamieniana niezależnie od języka.</p><p>Można łączyć tłumaczone ciągi ze zwykłymi ciągami znakowymi:</p><pre><code class="code">T("blah ") + name + T(" blah")</code></pre><p>Poniższy kod jest również dozwolony i często stosowany:</p><pre><code class="code">T("blah %(name)s blah", dict(name='Tim'))</code></pre><p>lub alternatywna składnia</p><pre><code class="code">T("blah %(name)s blah") % dict(name='Tim')</code></pre><p>W obu przypadkach ciąg tłumaczony występujący przed nazwą zmiennej jest podstawiany w wyrażeniu "%(name)s". Poniższej alternatywy NIE NALEŻY STOSOWAĆ:</p><pre><code class="code">T("blah %(name)s blah" % dict(name='Tim'))</code></pre><p>ponieważ ciąg tłumaczony będzie występował po podstawieniu.</p><h4>Ustalenie języka</h4><p>Żądany język jest określany w polu "Accept-Language" nagłówka HTTP, ale ten wybór może być zastąpiony programowo przez żądanie określonego pliku, na przykład:</p><pre><code class="code">T.force('pl-pl')</code></pre><p>który czyta plik językowy "languages/pl-pl.py". Pliki językowe mogą być tworzone i edytowane poprzez interfejs administracyjny.</p><p>Można też wymusić język w każdym tłumaczonym ciągu:</p><pre><code class="code">T("Hello World", language="pl-pl")</code></pre><blockquote>W przypadku wielu wymaganych języków, na przykład "pl-pl, fr-ft", web2py próbuje
zlokalizować pliki tłumaczeń "pl-pl.py" i "fr-fr.py". Jeżeli żaden z wymaganych
plików nie zostanie znaleziony, to następuje próba odnalezienia plików "pl.py"
i "pl.py". Jeżeli te pliki nie będą odnalezione, to wybrany zostanie domyślny plik
"default.py". Jeżeli i ten plik nie będzie odnaleziony, to tłumaczenie nie nastąpi.
Bardziej ogólna zasada jest taka, że web2py próbuje dopasować kolejno nazwy plików
"xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" dla każdego z akceptowanych języków
"xx-xy-yy", próbując znaleźć najbardziej zbliżona nazwę do preferencji językowej
odwiedzającego.</blockquote><p>Tłumaczenie można całkowicie wyłączyć poprzez</p><pre><code class="code">T.force(None)</code></pre><p>Zwykle, ciąg tłumaczenia jest ewaluowany leniwie podczas renderowania widoku. Dlatego metoda <code>force</code> translatora nie będzie wywoływana wewnątrz widoku.</p><p>Możliwe jest wyłączenie leniwej ewaluacji poprzez</p><pre><code class="code">T.lazy = False</code></pre><p>W ten sposób ciągi są tłumaczone natychmiast przez operator <code>T</code> na podstawie aktualnie akceptowanego lub wymuszanego języka.</p><p>Możliwe jest też wyłączenie leniwej ewaluacji dla pojedynczych ciągów:</p><pre><code class="code">T("Hello World", lazy=False)</code></pre><p>Powszechnie spotykany problem jest następujący. Oryginalna aplikacja jest w języku angielskim. Załóżmy, że jest plik tłumaczenia (na przykład polski, "pl-pl.py") a klient HTTP deklaruje, że jego akceptowanym językiem jest zarówno angielski (en) jak i polski (pl-pl) w tej kolejności. Ma miejsce niepożądana sytuacja: web2py nie wie, że domyślny plik tłumaczenia ("default.py") został napisany w języku  angielskim (en). Dlatego preferować będzie dla wszystkiego tłumaczenie polskie  (pl-pl) ponieważ może znaleźć tylko plik "pl-pl.py". Gdyby nie znalazł tego pliku, to wybrałby domyślny plik językowy d"default.py" (angielski).</p><p>Istnieją dwa rozwiązania tego problemu: utworzenie tłumaczenia dla języka angielskiego, co byłoby powtórzeniem istniejącego pliku "default.py" albo rozwiązanie lepsze – powiadomienie web2py o tym, że powinien zostać zastosowany język angielski (język w którym zakodowano aplikację). Można to zrobić tak:</p><pre><code class="code">T.set_current_languages('en', 'en-en')</code></pre><p>Wyrażenie to przechowuje w <code>T.current_languages</code> listę języków, które nie wymagają tłumaczenia i wymusza przeładowanie plików językowych.</p><p>Trzeba pamiętać, że "pl" i "pl-pl" są różnymi językami z punktu widzenia web2py. Do obsługi obydwu potrzeba dwóch różnych plików językowych, o nazwach zawsze pisanych małymi literami. To samo odnosi się do innych języków.</p><p>Aktualnie akceptowany język jest przechowywany w</p><pre><code class="code">T.accepted_language</code></pre><h4>Tłumaczenie zmiennych</h4><p>T(...) tłumaczy nie tylko łańcuchy tekstowe ale też może tłumaczyć wartości przechowywane w zmiennych:</p><pre><code class="code">&gt;&gt;&gt; a="test"
&gt;&gt;&gt; print T(a)</code></pre><p>W tym przypadku słowo "test" jest tłumaczone ale, jeśli jego tłumaczenie nie zostanie znalezione i jeśli system plików jest zapisywalny, to zostanie ono dodane w pliku językowym do listy słów w celu przetłumaczenia.</p><p>Proszę zauważyć, że może to dać w wyniku wiele plików IO i że można to wyłączyć:</p><pre><code class="code">T.is_writable = False</code></pre><p>zabezpieczając T przed dynamiczną aktualizacją plików językowych.</p><h4>Komentarze i tłumaczenia złożone</h4><p>Zdarza się, że ten sam łańcuch tekstowy występujący w różnych kontekstach w aplikacji, wymaga różnych tłumaczeń opartych na kontekście. Aby to umożliwić, można dodać komentarze do oryginalnego łańcucha tekstowego. Komentarze nie będą renderowane ale zostaną wykorzystane przez web2py do określenia najbardziej właściwego tłumaczenia. Na przykład:</p><pre><code class="code">T("hello world ## first occurrence")
T("hello world ## second occurrence")</code></pre><p>Tekst występujący po znakach <code>##</code>, to komentarz.</p><h4>Silnik liczby mnogiej</h4><p>Począwszy od wersji 2.0, web2py zawiera zaawansowany system pluralizacji (PS). Oznacza to, że gdy tekst oznaczony do tłumaczenia zależy od zmiennej numerycznej, to może zostać przetłumaczony na podstawie wartości numerycznej. Na przykład w angielskim możemy zrenderować:</p><pre><code>x book(s)</code></pre><p>z</p><pre><code>a book (x==1)
5 books (x==5)</code></pre><p>W języku angielskim jest jedna liczba pojedyncza i jedna liczba mnoga. Formę liczby mnogiej tworzy się przez dodanie końcówki "-s" lub "-es" albo używając formy wyjątkowej. web2py dostarcza sposób definiowania zasad liczby mnogiej dla każdego języka, jak również wyjątków od domyślnych reguł. W rzeczywistości web2py już zna zasady tworzenia liczby mnogiej dla wielu języków. Wie, na przykład, że w języku słoweńskim są 3 formy liczby mnogiej (dla x==1, x==3 albo x==4 i x&gt;4). Zasady te są zakodowane w pliku "gluon/contrib/plural_rules/*.py" i można tworzyć nowe pliki. Jawne zasady tworzenia liczby mnogiej dla słów są tworzone przez edytowanie plików pluralizacyjnych w interfejsie administracyjnym.</p><p>Domyślnie PS nie jest aktywowany. Jest on wywoływany przez argument <code>symbols</code> funkcji <code>T</code>. Na przykład:</p><pre><code class="code">T("You have %s %%{book}", symbols=10)</code></pre><p>Teraz PS jest aktywowany dla słowa "book" i dla liczby 10. W wyniku w języku angielskim otrzyma się: "You have 10 books". Proszę zwrócić uwagę, że "books" to liczba mnoga rzeczownika "book".</p><p>PS składa się z 3 elementów:</p><ul><li>wyrażenia zastępczego <code>%%{}</code> do zaznaczania słów na wejściu funkcji <code>T</code>;</li><li>reguły rozstrzygająca, którą formę słowa należy zastosować ("rules/plural_rules/*.py");</li><li>słownika z formami liczby mnogiej danego słowa ("app/languages/plural-*.py").</li></ul><p>Wartością symboli może być pojedyncza zmienna, lista (krotka) zmiennych lub słownik.</p><p>Wyrażenie zastępcze <code>%%{}</code> składa sie z 3 elementów:</p><pre><code>%%{[&lt;modifier&gt;]&lt;word&gt;[&lt;parameter&gt;]},</code></pre><p>gdzie:</p><pre><code>&lt;modifier&gt;::= ! | !! | !!!
&lt;word&gt; ::= każde słowo lub fraza w liczbie pojedynczej pisane małymi literami (!)
&lt;parameter&gt; ::= [index] | (key) | (number)</code></pre><p>Na przykład:</p><ul><li><code>%%{word}</code> jest równoważne <code>%%{word[0]}</code> (jeśli nie zostały zastosowane jakieś modyfikatory);</li><li><code>%%{word[index]}</code> stosuje się gdy parametr symbols jest krotką. Wyrażenie symbols[index] daje liczbę używaną do podejmowania decyzji o tym, która forma słowa ma być wybrana;</li><li><code>%%{word(key)}</code> jest używane do pobierania parametru numerycznego z wyrażenia symbols[key];</li><li><code>%%{word(number)}</code> umożliwia bezpośrednie ustawienie <code>number</code> (np.: <code>%%{word(%i)}</code>);</li><li><code>%%{?word?number}</code> zwraca "word" jeśli <code>number==1</code>, w przeciwnym razie zwraca <code>number</code>;</li><li><code>%%{?number} or %%{??number}</code> zwraca <code>number</code> jeśli <code>number!=1</code>, w przeciwnym razie zwraca nothing</li></ul><code>T("blabla %s %%{word}", symbols=var)</code><p><code>%%{word}</code> domyślnie oznacza <code>%%{word[0]}</code>, gdzie <code>[0]</code> jest indeksem elementu w krotce symbols.</p><code>T("blabla %s %s %%{word[1]}", (var1, var2))</code><p>PS zostaje zastosowany odpowiednio do "word" i "var2".</p><p>Można użyć kilka wyrażeń zastępczych <code>%%{}</code> o tym samym indeksie:</p><code>T("%%{this} %%{is} %s %%{book}", var)</code><p>lub</p><code>T("%%{this[0]} %%{is[0]} %s %%{book[0]}", var)</code><p>Jest generowane na:</p><pre><code>var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books</code></pre><p>Podobnie można przekazać słownik do parametru symbols:</p><pre><code>T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))</code></pre><p>co wytworzy:</p><pre><code>blabla tututu 20 words</code></pre><p>Można zamienić "1" na każde słowo, które chce się okreśłic w wyrażeniu zastępczym <code>%%{?word?number}</code>. Na przykład:</p><code>T("%%{this} %%{is} %%{?a?%s} %%{book}", var)</code><p>wytworzy:</p><pre><code>var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...</code></pre><p>Wenątrz <code>%%{...}</code> można też użyć następujące modyfikatory:</p><ul><li><code>!</code> aby kapitalizować tekst (odpowiednik <code>string.capitalize</code>);</li><li><code>!!</code> aby kapitalizować każde słowo (odpowiednik <code>string.title</code>)</li><li><code>!!!</code> aby kapitalizować każdy znak (odpowiednik <code>string.upper</code>)</li></ul><p>Trzeba pamiętać, że można użyć znak ukośnika jako znak ucieczki dla znaków <code>!</code> i <code>?</code>.</p><h4>Tłumaczenia i pluralizacja a MARKMIN</h4><p>Można również użyć zaawansowanej składni MARKMIN wewnątrz ciągów tłumaczeń przez zamienienie</p><pre><code class="code">T("hello world")</code></pre><p>na</p><pre><code>T.M("hello world")</code></pre><p>Teraz łańcuch tekstowy akceptuje znaczniki MARKMIN, jak opisano to w <a href="../05#markmin_markmin_syntax">rozdziale 5</a></p><h3>Ciasteczka</h3><div class="inxx">cookies</div><p>Do obsługi ciasteczek web2py wykorzystuje moduły ciasteczek Pythona.</p><p>Ciasteczka z przeglądarki przechowywane są w <code>request.cookies</code> a ciasteczka przesłane przez serwer znajdują się w <code>response.cookies</code>.</p><p>Ciasteczka można ustawić w następujący sposób:</p><pre><code class="code">response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'</code></pre><p>Druga linia informuje przeglądarkę aby zachowała ciasteczko przez 24 godziny. Trzecia linia informuje przeglądarkę, aby przesłała ciasteczko z powrotem do jakiejś aplikacji (ścieżka URL) w bieżącej domenie. Trzeba pamiętać, że jeśli nie określa się ścieżki do ciasteczka, to przeglądarka przyjmie ścieżkę URL z żądania HTTP, tak więc ciasteczko zwracane jest tylko do serwera, gdy żądana jest ta sama ścieżka URL.</p><p>Ciasteczko można zabezpieczyć przez:</p><pre><code class="code">response.cookies['mycookie']['secure'] = True</code></pre><p>Informuje to przeglądarkę aby wysłała ciasteczko z powrotem do serwera tylko poprzez HTTPS a nie HTTP.</p><p>Ciasteczko można pobrać w ten sposób:</p><pre><code class="code">if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value</code></pre><p>Jeżeli sesje są włączone, web2py w tle ustawia następujące ciasteczko i używa go do obsługi sesji:</p><pre><code class="code">response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"</code></pre><p>Proszę zwrócić uwagę, że jeśli pojedyncza aplikacja zawiera wiele poddomen i chce się udostępnić sesję pomiędzy wszystkimi poddomenami (np. sub1.yourdomain.com, sub2.yourdomain.com itd.), należy jawnie ustawić domenę ciasteczka sesji w następujący sposób:</p><pre><code class="code">if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"</code></pre><p>Powyższy sposób może być przydatny, jeśli, na przykład, chce się aby użytkownik mógł się logować równocześnie do wszystkich poddomen.</p><h3>Aplikacja <strong>init</strong></h3><div class="inxx">init</div><p>Podczas wdrażania web2py chce się ustawić domyślną aplikację, czyli aplikację, która będzie uruchamiana przy pustej ścieżce URL, tak jak tu:</p><pre><code class="code">http://127.0.0.1:8000</code></pre><p>Domyślnie, przy pustej ścieżce, web2py wyszukuje aplikacji o nazwie <strong>init</strong>. Jeżeli jej nie znajdzie, to wyszukuje aplikacji <strong>welcome</strong>.</p><div class="inxx">default_application</div><p>Nazwę domyślnej aplikacji można zmienić z <strong>init</strong> na inną, ustawiając odpowiednio <code>default_application</code> w pliku routes.py:</p><pre><code class="code">default_application = "myapp"</code></pre><p>Uwaga: <code>default_application</code> po raz pierwszy pojawiło się w web2py w wersji 1.83.</p><p>Oto cztery sposoby na ustawienie domyślnej aplikacji:</p><ul><li>Wywołanie domyślnej aplikacji "init".</li><li>Ustawienie <code>default_application</code> w routes.py na pożądaną nazwę aplikacji.</li><li>Wykonanie odwołania symbolicznego z "applications/init" do folderu swojej aplikacji.</li><li>Użycie przepisania adresu URL, co omówione jest w następnym rozdziale.</li></ul><h3>Przepisywanie URL</h3><div class="inxx">url rewrite</div><div class="inxx">routes_in</div><div class="inxx">routes_out</div><p>W web2py istnieje możliwość przepisania ścieżki URL przychodzących żądań przed wywołaniem akcji kontrolera (mapowania URL) i odwrotnie, web2py może przepisać ścieżkę URL generowaną przez funkcję <code>URL</code> (odwrotne mapowanie URL). Jednym z powodów dla których trzeba to zrobić jest obsługa starszych adresów URL. Innym powodem może być uproszenie ścieżek i wykonanie skrótów.</p><p>Platforma web2py zawiera dwa odrębne systemy przepisywania URL: łatwy w użyciu system <em>oparty na parametrach</em> mający zastosowanie we większości przypadków i elastyczny system <em>oparty na wzorcach</em> dobry dla bardziej skomplikowanych zastosowań. W celu określenia reguł przepisywania URL, trzeba utworzyć nowy plik w folderze "web2py" o nazwie <code>routes.py</code> (zawartość <code>routes.py</code> będzie zależeć od tego, który z tych dwóch systemów przepisywania zostanie wybrany, tak jak opisano to w nastęþnych dwóch rozdziałach). Te dwa systemy przepisywania nie mogą być mieszane.</p><blockquote>Trzeba pamiętać, że po edytowaniu pliku routes.py trzeba go przeładować. Można to
zrobić jednym z dwóch sposobów: przez ponowne uruchomienie serwera internetowego
albo przez klikniecie przycisku <em>Przeładuj</em> w interfejsie administracyjnym.
Jeśli popełniony został jakiś błąd trasowania, to nie nastąpi przeładowanie.</blockquote><h4>System trasowania oparty na parametrach</h4><p>Router oparty na parametrach (parametryczny) zapewnia łatwy dostęp do różnych gotowych metod przepisywania ścieżek URL. Jego możliwości obejmują:</p><ul><li>Pominięcie w zewnętrznej ścieżce URL (tej tworzonej przez funkcję URL) nazw domyślnej aplikacji, kontrolera i funkcji;</li><li>Odwzorowanie domen (i ewentualnie portów) do aplikacji lub kontrolerów;</li><li>Osadzenie selektora językowego w adresie URL;</li><li>Usuwanie stałych przedrostków z nadchodzących adresów URL i dodawanie ich z powrotem w wychodzących adresach URL;</li><li>Odwzorowywanie plików głównych, takich jak /robots.txt do katalogu plików statycznych (static)  aplikacji.</li></ul><p>Parametryczny router zapewnia również nieco bardziej elastycznej walidacji przychodzących adresów URL.</p><p>Załóżmy, że napisaliśmy aplikację o nazwie <code>myapp</code> i uczyniliśmy ja aplikacją domyślną, tak więc nazwa tej aplikacji nie jest już częścią adresu URL widzianego przez użytkownika. Nasz domyślny kontroler to ciągle <code>default</code>. Chcemy też usunąć nazwę kontrolera z adresu URL widzianego przez użytkownika. Oto co należy wpisać w pliku <code>routes.py</code>:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
)</code></pre><p>To jest to. Parametryczny router jest wystarczająco inteligentny, aby wiedzieć jak właściwie przekształcić takie adresy URL jak te:</p><pre><code class="code">http://domain.com/myapp/default/myapp</code></pre><p>lub</p><pre><code class="code">http://domain.com/myapp/myapp/index</code></pre><p>gdzie normalnie skracana ścieżka byłaby dwuznaczna. Jeśli ma się dwie aplikacje, <code>myapp</code> i <code>myapp2</code>, to można uzyskać ten sam efekt i dodatkowo ze ścieżki URL aplikacji <code>myapp2</code> zostanie usunięta nazwa domyślnego kontrolera, gdy będzie to bezpieczne (co ma miejsce w większości przypadków).</p><p>Oto inny przypadek: załóżmy, że chcemy obsługiwać języki w oparciu o URL, gdzie ścieżki URL wyglądają tak:</p><pre><code class="code">http://myapp/en/some/path</code></pre><p>lub (przepisane)</p><pre><code class="code">http://en/some/path</code></pre><p>Oto jak to zrobić:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)</code></pre><p>Teraz przychodzący adres URL,  wyglądający tak:</p><pre><code class="code">http:/domain.com/it/some/path</code></pre><p>Będzie kierowany do <code>/myapp/some/path</code>, a request.uri_language zostanie ustawiony na 'it', wymuszając w ten sposób tłumaczenie. Można również obsługiwać statyczne pliki specyficzne dla języka:</p><pre><code class="code">http://domain.com/it/static/filename</code></pre><p>zostanie mapowane do:</p><pre><code class="code">applications/myapp/static/it/filename</code></pre><p>jeśli ten plik istnieje. Jeśli nie, to adresy URL takie jak:</p><pre><code class="code">http://domain.com/it/static/base.css</code></pre><p>będą nadal przekształcane na:</p><pre><code class="code">applications/myapp/static/base.css</code></pre><p>(ponieważ nie istnieje <code>static/it/base.css</code>).</p><p>Tak więc można mieć statyczne pliki specyficzne językowo, włączając w to obrazy, jeśli potrzeba. Obsługiwane jest również mapowanie domenowe:</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)</code></pre><p>robi to, czego oczekiwaliśmy.</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)</code></pre><p>Odwzorowuje <code>http://domain.com</code> na kontroler o nazwie <code>insecure</code>, ponieważ dostęp przez <code>HTTPS</code> następuje przez kontroler <code>secure</code>. Alternatywnie można odwzorować różne porty na różne aplikacje, w oczywisty sposób.</p><p>W celu uzyskania więcej informacji proszę zapoznać się z plikiem <a href="https://github.com/web2py/web2py/blob/master/examples/routes.parametric.example.py">"routes.parametric.example.py"</a> umieszczonym w folderze "examples" standardowej dystrybucji web2py.</p><p>Uwaga: System trasowania <em>oparty na parametrach</em> został wprowadzony po raz pierwszy w wersji 1.92.1 web2py.</p><h4>System trasowania oparty na wzorcach</h4><p>Pomimo, że właśnie opisany system trasowania  <em>oparty na parametrach</em> powinien być wystarczający dla większości, alternatywny system trasowania <em>oparty na wzorcach</em> zapewnia pewną dodatkową elastyczność w bardziej złożonych przypadkach. Aby użyć system oparty na wzorcach, zamiast definiowania routerów jako słownika parametrów trasowania, definiuje się dwie listy (lub krotki) dwóch krotek, <code>routes_in</code> i <code>routes_out</code>. Każda krotka zawiera dwa elementy: wzorzec, który ma zostać być zamieniony i ciąg znakowy go zastępujący. Na przykład:</p><pre><code class="code">routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)</code></pre><p>Przy tych trasach adres URL:</p><pre><code class="code">http://127.0.0.1:8000/testme</code></pre><p>jest odwzorowywany na:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/index</code></pre><p>Dla odwiedzającego wszystkie odnośniki URL do strony wyglądają podobnie do <code>/testme</code>.</p><p>Wzorce mają taką samą składnie jak wyrażenia regularne Pythona. Na przykład:</p><pre><code class="code">  ('.*.php', '/init/default/index'),</code></pre><p>odwzorowuje wszystkie adresy URL kończące się na ".php" na stronę index.</p><p>W drugim warunku reguły można również dokonać przekierowania do innej strony:</p><pre><code class="code">  ('.*.php', '303-&gt;http://example.com/newpage'),</code></pre><p>Tutaj 303 jest kodem stanu HTTP do przekierowania odpowiedzi.</p><p>Czasem zachodzi potrzeba pozbycia się przedrostka z adresów URL, ponieważ chce się udostępnić tylko jedna aplikację. Można to osiągnąć za pomocą:</p><pre><code class="code">routes_in = (
  ('/(?P&lt;any&gt;.*)', '/init/\g&lt;any&gt;'),
)
routes_out = (
  ('/init/(?P&lt;any&gt;.*)', '/\g&lt;any&gt;'),
)</code></pre><p>Istnieje również alternatywna składnia umożliwiająca mieszanie notacji wyrażeń regularnych ze powyższą składnią. Składa się ona ze zmiennej <code>$name</code> zamiast <code>(?P&lt;name&gt;\w+)</code> czy <code>\g&lt;name&gt;</code>. Na przykład:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)</code></pre><p>Eliminuje to również przedrostek aplikacji "/example" we wszystkich adresach URL.</p><p>Używając notacji ze zmienną <code>$name</code>, można automatycznie odwzorowac <code>routes_in</code> na <code>routes_out</code>, pod warunkiem, że nie używa się wyrażeń regularnych. Na przykład:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]</code></pre><p>Jeśli istnieje wiele tras, wykonywana jest pierwsza dopasowana ścieżka URL. Jeśli żaden wzorzec nie zostanie dopasowany, tp ścieżka pozostaje nie zmieniona.</p><p>Można użyć zmiennej <code>$anything</code> aby dopasować cokolwiek (<code>.*</code>) aż do końca linii.</p><p>Oto minimalna treść pliku "routes.py" dla obsługi żądań pliku favicon.ico i robots.txt:</p><p><div class="inxx">favicon</div> <div class="inxx">robots</div></p><pre><code class="code">routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()</code></pre><p>Oto bardziej złożony przykład udostępniający pojedynczą aplikację "myapp", bez zbędnych przedrostków, ale również interfejsy <strong>admin</strong> i <strong>appadmin</strong> oraz katalog static:</p><pre><code class="code">routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]</code></pre><p>Ogólna składnia trasy jest bardzie skomplikowana, niż widzieliśmy to do tej pory. Oto bardziej ogólny i reprezentatywny przykład:</p><pre><code class="code">routes_in = (
 ('140.191.\d+.\d+:https?://www.web2py.com:post /(?P&lt;any&gt;.*).php',
  '/test/default/index?vars=\g&lt;any&gt;'),
)</code></pre><p>Odwzorowuje to <code>http</code> lub <code>https</code> żądań <code>POST</code> (ale nie pisane małymi literami "post") dla hosta <code>www.web2py.com</code> ze zdalnego IP pasującego do wyrażenia regularnego</p><pre><code class="code">'140.191.\d+.\d+'</code></pre><p>żądana strona pasująca do wyrażenia regularnego</p><pre><code class="code">'/(?P&lt;any&gt;.*).php'</code></pre><p>na</p><pre><code class="code">'/test/default/index?vars=\g&lt;any&gt;'</code></pre><p>gdzie <code>\g&lt;any&gt;</code> jest zamieniane przez dopasowanie wyrażenia regularnego.</p><p>Ogólna składnia to</p><pre><code class="code">'[remote address]:[protocol]://[host]:[method] [path]'</code></pre><p>Jeśli brakuje pierwszej sekcji wzorca (wszystko z wyjątkiem <code>[path]</code>), to web2py dostarcza domyślnie:</p><pre><code class="code">'.*?:https?://[^:/]+:[a-z]+'</code></pre><p>Całe wyrażenie jest dopasowywane jako wyrażenie regularne, tak więc znak kropki (.) musi być poprzedzony znakiem ucieczki (znakiem lewego ukośnika) i każde dopasowywane podwyrażenie można przedstawić przy użyciu <code>(?P&lt;...&gt;...)</code> wykorzystując składnię wyrażenia regularnego Pythona. Metoda żądania (zwykle GET lub POST) musi być pisana małymi literami. Adres URL, który jest dopasowywany musi mieć jakiekolwiek wyrażenie ucieczkowe <code>%xx</code> ujęte w znaki cudzysłowu.</p><p>Umożliwia to przekierowanie żądań opartych na adresie IP klienta lub domenie, na typie żądania, na metodzie i na ścieżce. Umożliwia to również, aby web2py odwzorowywał różne wirtualne hosty w różnych aplikacjach. Każde dopasowane podwyrażenie może być użyte do budowy docelowej ścieżki URL i ostatecznie przekazane jako zmienna GET.</p><p>Wszystkie główne serwery internetowe, takie jak Apache czy lighttpd, mają również zdolność przepisywania adresów URL. W środowisku produkcyjnym może to być wykorzystane zamiast <code>routes.py</code>. Cokolwiek się wybierze, zalecamy aby nie kodować na sztywno wewnętrznych ścieżek URL w aplikacji ale do ich generowania używać funkcji URL. Sprawi to, że aplikacja będzie bardziej przenośna w przypadku zmiany tras.</p><h5>Przepisywanie adresów URL specyficzne dla aplikacji</h5><div class="inxx">routes_app</div><p>Gdy stosuje się system trasowania oparty na wzorcach, aplikacja może ustawiać swoje własne trasy w pliku routes.py zlokalizowanym w podstawowym folderze danej aplikacji. Jest to możliwe przez konfigurację <code>routes_app</code> w pliku podstawowym routes.py, tak aby określić skąd ma być wybrana nazwa przychodzącego adresu URL aplikacji. Gdy to nastąpi, będzie używany  plik routes.py danej aplikacji w miejsce podstawowego pliku routes.py.</p><p>Format <code>routes_app</code> jest identyczny z <code>routes_in</code> z tym wyjątkiem, że wymienialny wzorzec jest tylko nazwą aplikacja. Jeśli zastosowanie <code>routes_app</code> do przychodzącego adresu URL z dopasowaniem nazwy aplikacji nie da rezultatu lub wynikowy plik routes.py określonej aplikacji nie zostanie znaleziony, to zostanie użyty bazowy plik routes.py.</p><p>Uwaga: <code>routes_app</code> został zastosowany po raz pierwszy w wersji 1.83 web2py.</p><h5>Domyślna aplikacja, kontroler i funkcja</h5><div class="inxx">default_application</div><div class="inxx">default_controller</div><div class="inxx">default_function</div><p>Gdy używa się systemu trasowania opartego na wzorcach nazwa domyślnej aplikacji, kontrolera i funkcji mogą być zmienione z <strong>init</strong>, <strong>default</strong> czy <strong>index</strong> odpowiednio na inna nazwę, przez odpowiednie ustawienie wartości w routes.py:</p><pre><code class="code">default_application = "myapp"
default_controller = "admin"
default_function = "start"</code></pre><p>Uwaga: Elementy te po raz pierwszy zastosowano w wersji 1.83 web2py.</p><h4>Trasy do stron błędu</h4><div class="inxx">routes_onerror</div><p>Można również wykorzystać <code>routes.py</code> do zmiany trasy żądań dla określonych akcji, w przypadku gdy pojawi się na serwerze błąd. Można określić to trasowanie globalnie dla całej aplikacji, dla każdego kodu błędu lub dla każdej aplikacji i każdego kodu błędu. Oto przykład:</p><pre><code class="code">routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]</code></pre><p>Dla każdej krotki, porównywany jest pierwszy ciąg ze wzorcem "[app name]/[error code]". Jeśli pasuje, to błędne żądanie jest przekierowywane na ścieżkę URL określoną w drugim ciągu dopasowanej krotki. Jeśli ścieżka URL obsługiwanego błędu nie prowadzi do pliku statycznego, to do akcji błędu dopasowana zostanie następująca zmienna GET:</p><ul><li><code>code</code>: kod stanu HTTP (np. 404, 500);</li><li><code>ticket</code>: w postaci "[app name]/[ticket number]" (lub "None" jeśli nie ma biletu);</li><li><code>requested_uri</code>: odpowiednik <code>request.env.request_uri</code>;</li><li><code>request_url</code>: odpowiednik <code>request.url</code>.</li></ul><p>Zmienne te są dostępne dla akcji obsługującej błędy poprzez <code>request.vars</code> i mogą być użyte do generowania odpowiedzi o błędzie. W szczególności, dobrym pomysłem jest aby akcja błędu zwracała oryginalny kod błędu HTTP zamiast domyślny kod stanu 200 (OK). Można to zrobić przez ustawienie <code>response.status = request.vars.code</code>. Jest też możliwe, aby akcja błędu wysyłała (lub kolejkowała) wiadomości email do administratora, w tym odnośnik do biletu w interfejsie <code>admin</code>.</p><p>Niedopasowane błędy wyświetlą domyślną stronę błędów. Tą domyślną stronę błędów można również tutaj dostosować (zobacz "routes.parametric.example.py" i "routes.patterns.example.py" w folderze "examples"):</p><pre><code class="code">error_message = '&lt;html&gt;&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'
error_message_ticket = '''&lt;html&gt;&lt;body&gt;&lt;h1&gt;Internal error&lt;/h1&gt;
     Ticket issued: &lt;a href="/admin/default/ticket/%(ticket)s"
     target="_blank"&gt;%(ticket)s&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''</code></pre><p>Pierwsza zmienna zawiera komunikat błędu na wypadek żądania nieprawidłowej aplikacji lub funkcji. Druga zmienna zawiera komunikat błędu na wypadek wystawienia biletu.</p><p>Zmienna <code>routes_onerror</code> działa w obydwu mechanizmach trasowania.</p><div class="inxx">error_handler</div><p>W "routes.py" można też określić akcję odpowiedzialną za obsługę błedów:</p><pre><code class="code">error_handler = dict(application='error',
                      controller='default',
                      function='index')</code></pre><p>Jeśli zmienna <code>error_handler</code> określa akcją, to jest ona wywoływana bez przekierowywania użytkownika i za obsługę błędu będzie odpowiedzialna akcja handlera. W przypadku, gdy sama strona obsługuje zwracane błędy, web2py powróci do swoich starych odpowiedzi statycznych.</p><h4>Zarządzanie statycznymi aktywami</h4><p>Od wersji 2.1.0, web2py ma możliwość zarządzania aktywami statycznymi.</p><p>Gdy aplikacja jest w fazie tworzenia, pliki statyczne można zmieniać często dlatego, że web2py wysyła pliki statyczne z nagłówkami nie buforowania. Efektem ubocznym jest "wymuszania" na przeglądarce żądania plików statycznych przy każdym żądaniu HTTP. Powoduje to niską wydajność ładowania strony.</p><p>W środowisku "produkcyjnym", można serwować pliki statyczne z nagłówkami <code>cache</code> w celu przeciwdziałania zbytecznym pobraniom, gdyż pliki statyczne nie zmieniają się.</p><p>Nagłówki <code>cache</code> pozwalają przeglądarce pobrać plik tylko raz, oszczędzając w ten sposób przepustowość i zmniejszając czas ładowania.</p><p>Jednak jest pewien problem. Co powinny deklarować nagłówki buforowania? Kiedy należy wygasić buforowanie plików? Gdy plik jest serwowany po raz pierwszy, serwer nie jest w stanie przewidzieć, kiedy nastąpi zmiana tego pliku.</p><p>Podręcznikowe podejście do przechowywania plików statycznych nakazuje tworzenie podfolderów dla każdej odrębnej wersji plików statycznych. Na przykład jakaś wcześniejsza wersja "layout.css" może być dostępna na ścieżce URL "/myapp/static/css/1.2.3/layout.css". Gdy wprowadza się zmiany w tym pliku, tworzy się nowy podfolder "/myapp/static/css/1.2.4/layout.css" i zmienia się odnośniki.</p><p>Ta procedura działa, ale jest uciążliwa, ponieważ przy każdej zmianie w pliku CSS, trzeba pamiętać aby przenieść go do innego folderu, zmienić ścieżki URL pliku w layout.html i to wdrożyć.</p><p>Zarządzanie statycznymi aktywami rozwiązuje problem umożliwiając programiście deklarować wersję grupy plików statycznych, co sprawi, że będą one ponownie żądane tylko gdy zmieni się numer wersji. Numer wersji aktywa jest częścią adresu URL tak jak w poprzednim przykładzie. Różnica w stosunku do poprzedniego podejścia polega na tym, że numer wersji pojawia się tylko w adresie URL a nie w systemie plików.</p><p>Jeśli chce się serwować plik "/myapp/static/layout.css" z nagłówkiem buforowania, wystarczy zawrzeć plik ze zmieniona ścieżką URL, która zawiera numer wersji:</p><pre><code>/myapp/static/_1.2.3/layout.css</code></pre><p>(proszę zwrócić uwagę, że numer wersji jest okreśłany w ścieżce URL i nie pojawia się on gdzie indziej).</p><p>Proszę też zwrócić uwagę, że ścieżka URL rozpoczyna się od "/myapp/static/", po czym następuje numer wersji złożony ze znaku pokreślenia i 3 liczb całkowitych rozdzielonych kropką (tak jak opisano to w <a href="http://semver.org/">SemVer</a>), a następnie nazwa pliku. Trzeba podkreślić, że nie musi się tworzyć folderu "_1.2.3/".</p><p>Za każdym razem gdy plik statyczny zostanie zażądany z numerem wersji w adresie URL, to zostanie on zaserwowany z nagłówkiem buforowania "o dalekiej przyszłości", w szczególności:</p><pre><code>Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT</code></pre><p>Oznacza to, przeglądarka będzie pobierać takie pliki tylko raz i będą one zapisane w pamięci przeglądarki "na zawsze".</p><p>Za każdym razem, gdy w adresie URL znajduje się komponent wersjonowania "_1.2.3/filename", web2py usuwa ze ścieżki część dotyczącą wersji i serwuje plik z nagłówkiem wskazującym na daleka przyszłość, tak więc plik ten będzie zawsze buforowany. Jeśli został zmieniony numer wersji w adresie URL, to ten wybieg spowoduje, że przeglądarka zażąda innego (wg niej) pliku i plik zostanie pobrany ponownie.</p><p>Można użyć numerów "_1.2.3", "_0.0.0", "_999.888.888" – jedyna ograniczenie, to rozpoczęcie numeru wersji znakiem podkreślenia i struktura składająca się z trzech ciągów cyfr rozdzielonych kropką.</p><p>Podczas prac programistycznych, można użyć <code>response.files.append(...)</code> w celu zlinkowania adresów URL plików statycznych. W takim przypadku można dopisać ręcznie część "_1.2.3/" lub wykorzystać nowy parametr obiektu odpowiedzi: <code>response.static_version</code>. Wystarczy zawrzeć pliki w zwykły sposób, na przykład</p><pre><code>{{response.files.append(URL('static','layout.css'))}}</code></pre><p>a w modułach ustawić</p><pre><code class="code">response.static_version = '1.2.3'</code></pre><p>To przepisze automatycznie każda ścieżkę URL "/myapp/static/layout.css" do "/myapp/static/_1.2.3/layout.css", dla kazdego pliku, łącznie z <code>response.files</code>.</p><p>Często w środowisku produkcyjnym sprawia się, że odpowiednie serwowanie plików statycznych powierza się serwerowi internetowemu (Apache, Nginx itd.). Trzeba wówczas dostosować konfigurację w taki sposób, aby "przeskoczyć" część "_1.2.3/".</p><p>Na przyklad, w Apache zmień to:</p><pre><code>AliasMatch ^/([^/]+)/static/(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>na to:</p><pre><code>AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>Podobnie w Nginx zmień to:</p><pre><code>location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}</code></pre><p>na to:</p><pre><code>location ~* /(\w+)/static(?:/_[\d]+.[\d]+.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}</code></pre><h3>Uruchamianie zadań w tle</h3><p>W web2py każde żądanie HTTP jest obsługiwane w swoim własnym wątku. Wątki są odnawiane w celu efektywności i zarządzane przez serwer internetowy. Dla bezpieczeństwa, serwer internetowy ustawia limit czasu dla każdego żądania. Oznacza to, że akcje nie powinny uruchamiać zadań, które trwają zbyt długo, nie powinny tworzyć nowych wątków i nie powinny rozwidlać procesów (jest to możliwe, ale nie zalecane).</p><p>Właściwym sposobem na uruchomienie czasochłonnych zadań jest uruchamianie ich w tle. Jest kilka sposobów na to, ale tu opisujemy trzy mechanizmy wbudowane w web2py: <strong>cron</strong>, <strong>własne kolejkowanie zadań</strong> i <strong>terminarz</strong>.</p><p>Przez <strong>cron</strong> rozumiemy tu funkcjonalność web2py a nie mechanizm Cron systemów uniksowych. Cron web2py działa też na systemie Windows.</p><p>Cron web2py ma zastosowanie, jeśli potrzeba, aby zadania były uruchamiane w tle o ściśle zaplanowanym czasie i jeśli zadania te mają stosunkowo krótki czas wykonania w stosunku do przerw pomiędzy kolejnymi uruchomieniami. Każde zadanie uruchamiane jest w jego ostatnim procesie i można uruchomiać jednocześnie wiele zadań, lecz nie ma kontroli nad tym, jak wiele zadań jest uruchomionych. Jeśli jedno z zadań pokrywa się z innym, to może to doprowadzić do blokady bazy danych i skoku zużycia pamięci.</p><p>W terminarzu web2py przyjęto inne podejście. Liczba uruchamianych procesów jest stała i mogą one działać na różnych komputerach. Każdy proces jest wywoływany przez workera. Każdy worker wybiera zadanie, gdy jest ono dostępne i wykonywane jest ono niezwłocznie po upływie zaplanowanego terminu uruchomienia, ale nie koniecznie dokładnie o tym czasie. Nie może być uruchomionych więcej procesów niż liczba zaplanowanych zadań i dlatego nie nastąpi skok pamięci. Zadania terminarza mogą być definiowane w modelach i są przechowywane w bazie danych. Terminarz web2py nie implementuje rozproszonej kolejki, ponieważ zakłada się, że czas potrzebny do podzielenia zadań jest znikomy w porównaniu z czasem uruchomionych zadań. Workery pobierają zadania z bazy danych.</p><p>Własne kolejkowanie zadań może być w niektórych przypadkach prostszą alternatywą dla terminarza web2py.</p><h4>Cron</h4><div class="inxx">cron</div><p>Cron web2py umożliwia, aby aplikacje wykonywały zadania w określonym czasie, w sposób niezależny od systemu operacyjnego.</p><p>Funkcjonalność cron jest określana w każdej aplikacji w pliku crontab:</p><pre><code>app/cron/crontab</code></pre><p>Stosuje sie w nim zwykłą składnię opisaną w informatorze <sup>[<a href="/book/default/reference/42/cron" target="_blank">cron</a>]</sup> (z pewnymi rozszerzeniami, specyficznymi dla web2py).</p><blockquote>Przed wersją 2.1.1 web2py, cron był domyślnie włączony i mógł być wyłączony opcją
<code>-N</code> polecenia terminalowego. Od wersji 2.1.1, cron jest domyślnie wyłączony i
może być włączony opcja <code>-Y</code>. Zmiana ta została podyktowana chęcią nakłonienia
użytkowników do stosowania nowego terminarza (który jest lepszy od mechanizmu cron)
a także dlatego, ze cron może mieć negatywny wpływ na wydajność.</blockquote><p>Oznacza to, że każda aplikacja może mieć oddzielną konfigurację cron i że konfiguracja cron może być zmieniana bez wpływu na cron systemu operacyjnego.</p><p>Oto przykład:</p><pre><code class="code">0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py</code></pre><p>Dwie ostatnie linie w tym przykładzie wykorzystują rozszerzenia zwykłej składni cron aby zapewnić dodatkową funkcjonalność web2py.</p><blockquote>Plik "applications/admin/cron/expire_sessions.py" faktycznie istnieje i jest dostarczany
wraz z aplikacja <strong>admin</strong>. Zawarty tam kod sprawdza czy sesje wygasły i usuwa je.
Kod w "applications/admin/cron/crontab" uruchamia to zadanie co godzinę.</blockquote><p>Jeśli nazwa zadania (skryptu) jest poprzedzona znakiem gwiazdki (<code>*</code>) i kończy się rozszerzeniem <code>.py</code>, to zadanie to będzie wykonane w środowisku web2py. Oznacza to, że ma się do dyspozycji wszystkie kontrolery i modele. Jeśli użyje się dwóch gwiazdek (<code>**</code>), modele nie będą wykonywane. Jest to zalecany sposób wywoływania, ponieważ ma mniejsze obciążenie i pozwala uniknąć potencjalne problemy.</p><p>Proszę zwrócić uwagę, że skrypty (funkcje) wykonywane w środowisku web2py wymagają ręcznego wykonania <code>db.commit()</code> na końcu funkcji, inaczej transakcja zostanie odwrócona.</p><p>Framework web2py nie generuje biletów lub jednoznacznych komunikatów o ostatnich wywołaniach (<em>ang. traceback</em>) w trybie powłoki, w której uruchomiony jest cron. Tak więc trzeba się upewnić czy kod web2py został uruchomiony bez błędów, zanim ustawi się go jako zadanie cron, ponieważ nie będzie się w stanie stwierdzić ewentualnych błędów po uruchomieniu zadania cron. Ponadto należy uważać, w jaki sposób korzysta się z modeli: podczas wykonania zdarza się, że w oddzielnym procesie muszą być wzięte pod uwagę blokady bazy danych, aby uniknąć stron oczekujących na zadania cron, które mogą blokować bazę danych. Użyj składni <code>**</code>, jeśli nie musisz używac bazy danych w swoim zadaniu cron.</p><p>Można również wywołać funkcję kontrolera, w którym to przypadku nie potrzeba określać ścieżki. Kontroler i funkcja będą przywoływać aplikację. Trzeba zachować szczególną ostrożność wykazując powyższe. Przykład:</p><pre><code class="code">*/30  *  *  *  *  root *mycontroller/myfunction</code></pre><p>Jeśli określi się <code>@reboot</code> w pierwszym polu pliku crontab, podane zadanie zostanie wykonane tylko raz, przy uruchomieniu web2py. Można skorzystać z tej funkcjonalności, jeśli chce się wstępnie buforować jakieś dane, sprawdzić je lub zainicjować dane przy uruchomieniu web2py. Trzeba pamiętać, że zadania cron są wykonywane równolegle z aplikacją. Jeśli aplikacja nie jest gotowa do obsługi żądań do czasu zakończenia zadań cron, trzema implementować sprawdzenie tego stanu i jego uwzględnienie. Przykład:</p><pre><code class="code">@reboot  root *mycontroller/myfunction</code></pre><p>W zależności od sposobu wywołania web2py, są cztery tryby pracy cron web2py.</p><ul><li><em>miękki cron</em>: dostępny we wszystkich trybach wykonania;</li><li><em>twardy cron</em>: dostępny, jeśli używa się wbudowanego serwera internetowego (bezpośrednio lub za pośrednictwem mod_proxy Apache);</li><li><em>zewnetrzny cron</em>: dostępny, jeśli ma się możliwość korzystania z usługi cron systemu operacyjnego;</li><li>brak cronu.</li></ul><p>Gdy używa się wbudowanego serwera internetowego domyślnym trybem jest twardy cron. We wszystkich inych przypadkach, domyślnym trybem jest miękki cron.  Miękki cron jest też domyślnym trybem, jeśli używa się CGI, FASTCGI lub WSGI (ale trzeba mieć na uwadze, że miękki cron nie jest domyślnie włączony w standardowym pliku <code>wsgihandler.py</code> dostarczanym w web2py).</p><p>Zadania cron są wykonywane od pierwszego wywołania (załadowania strony) aż do czasu określonego w crontab, ale tylko po przetworzeniu strony, tak więc użytkownik nie zauważy żadnego opóźnienia. Oczywiście istnieje pewien stopień niepewności co do dokładności czasu w który zadanie będzie wykonane, co uzależnione jest od ruchu na witrynie. Ponadto zadanie cron może zostać przerwane, jeśli serwer internetowy ma ustawiony limit ładowania strony. Jeśli te ograniczenia nie są dopuszczalne, to należy zastosować zewnętrzny cron. Miękki cron powinien być stosowany w ostateczności, gdy inne tryby nie mogą być użyte.</p><p>Twardy cron jest trybem domyślnym, jeśli używa się wbudowanego serwera internetowego (bezpośrednio lub za pośrednictwem mod_proxy Apache). Twardy cron jest wykonywany w równoległym wątku, inaczej niż ma to miejsce w przypadku miękkiego crona. W trybie tym nie ma żadnych ograniczeń związanych z czasem uruchamiania lub dokładnością czasu wykonania.</p><p>Zewnętrzny cron nie jest domyślny w jakimkolwiek scenariuszu, ale wymaga dostępu do systemowej usługi cron. Jest uruchamiany w równoległym procesie, tak więc nie ma ograniczeń występujących w miękkim cronie. Jest to zalecany sposób użycia crona w WSGI lub FASTCGI.</p><p>Przykład linii kodu dodającego systemowy crontab, (zwykle to /etc/crontab):</p><pre><code class="code">0-59/1 * * * * web2py cd /var/www/web2py/ &amp;&amp; python web2py.py -J -C -D 1 &gt;&gt; /tmp/cron.output 2&gt;&amp;1</code></pre><p>W zewnętrznym <code>cron</code>, trzeba się upewnić, że dodany jest parametr <code>-J</code> (albo <code>--cronjob</code>, co jest tym samym) jak pokazano to powyżej, tak aby web2py wiedział, że to zadanie jest wykonywane przez zewnętrzny cron. Web2py przestawia to wewnętrznie z miękkiego i twardego <code>cron</code>.</p><h4>Własne kolejkowanie zadań</h4><p>Chociaż cron jest przydatny do uruchamiania zadań w regularnych odstępach czasu, to nie zawsze jest najlepszym rozwiązaniem do uruchamiania zadań w tle. Z tych powodów w web2py udostępnia się możliwość uruchamiania dowolnych skryptów Pythona, tak jakby znajdowały się w kontrolerze:</p><pre><code class="code">python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c</code></pre><p>gdzie <code>-S app</code> powiadamia web2py aby uruchamiał "myscript.py" jako "app", <code>-M</code> powiadamia aby wykonał modele a <code>-A a b c</code> przekazuje opcjonalne argumenty linii poleceń <code>sys.args=['a','b','c']</code> do "myscript.py".</p><p>Tego typu proces tła nie powinien być wykonywany za pośrednictwem cron (może z wyjątkiem wyrażenie @reboot crona), ponieważ trzeba mieć pewność, że w danym czasie działa nie więcej niż jedna instancja. W cronie możliwe jest, że proces rozpoczyna pierwszą iteracje crona i nie jest zakańczany przez iterację drugą, tak więc cron uruchamia go ponownie i ponownie i ponownie – zagłuszając tym samym serwer poczty, jeśli zadanie dotyczy wysyłania wiadomości email.</p><p>W rozdziale 8 znajdują się przykłady pokazujące jak używać powyższej metody do wysyłania wiadomości email.</p><h4>Terminarz</h4><p>Przed wersją 2.6.0 terminarz był traktowany jako kod eksperymentalny. Począwszy od wersji 2.6.0 udokumentowane API jest stabilne. Stabilne API składa się z następujących funkcji:</p><ul><li>disable()</li><li>resume()</li><li>terminate()</li><li>kill()</li><li>queue_task(),</li><li>task_status()</li><li>stop_task()</li></ul><p>Terminarz web2py działa bardzo podobnie do kolejkowania zadań, opisanego w poprzednim podrozdziale z pewnymi różnicami:</p><ul><li>Zapewnia standardowy mechanizm dla tworzenia, harmonogramowania i monitorowania zadań.</li><li>Nie jest pojedynczym procesem wykonywanym w tle, ale zestawem workerów.</li><li>Zadania węzłów wykonawczych (<em>ang. job of worker nodes</em>) mogą być monitorowane, ponieważ ich stan, jak również stan samych zadań jest przechowywany w bazie danych.</li><li>Działa to bez web2py ale nie jest to udokumentowane.</li></ul><p>Terminarz web2py nie wykorzystuje crona, choć można użyć wyrażenia @reboot crona aby rozpocząć działanie węzłów wykonawczych.</p><p>Więcej informacji o wdrażaniu terminarza pod Linuksem i Windowsem znajduje się w rozdziale "Receptury wdrożeniowe".</p><p>W terminarzu zadanie jest po prostu funkcją zdefiniowaną w modelu (lub w module i importowana przez model). Na przykład:</p><pre><code class="code">def task_add(a,b):
    return a+b</code></pre><p>Zadania będą zawsze wywoływane w tym samym środowisku, jakie widzą kontrolery i dlatego są dla nich dostępne wszystkie zmienne globalne zdefiniowane w modelach, w tym połączenia z bazą danych (<code>db</code>). Zadania różnią się od akcji kontrolera, ponieważ nie są powiązane z jakimś żądaniem HTTP i dlatego nie ma <code>request.env</code>. Ponadto, zadania mogą mieć dostęp do zmienej innego środowiska, która nie występuje w zwykłych żądaniach: <code>W2P_TASK</code>. Zmienna <code>W2P_TASK.id</code> posiada <code>scheduler_task.id</code> i <code>W2P_TASK.uuid</code> pola <code>scheduler_task.uuid</code> uruchomionego zadania.</p><blockquote>Trzeba pamiętać, aby wywołać <code>db.commit()</code> na końcu każdego zadania, jeśli zadanie
dotyczy operacji zapisu danych do bazy danych. Wprawdzie web2py zatwierdza domyślnie
transakcję na koniec udanej akcji, ale zadania terminarza nie są akcjami.</blockquote><p>Aby udostępnić terminarz należy w modelu utworzyć instancję klasy Scheduler. Zalecanym sposobem włączenia terminarza do aplikacji jest utworzenie pliku modelu o nazwie <code>scheduler.py</code> i zdefiniowanie tam swojej funkcji. Po funkcji można umieścić w modelu następujący kod:</p><pre><code class="code">from gluon.scheduler import Scheduler
scheduler = Scheduler(db)</code></pre><p>Jeśli zadania są zdefiniowane w modelu (w przeciwieństwie do modelu), to może być konieczne ponowne uruchomienie workerów.</p><p>Planowanie zadań dokonuje się za pomocą</p><pre><code class="code">scheduler.queue_task(task_add,pvars=dict(a=1,b=2))</code></pre><h5>Parametry</h5><p>Pierwszym argumentem klasy <code>Scheduler</code> musi być baza danych używana przez terminarz do komunikacji z workerami. Może to być <code>db</code> aplikacji lub inny dedykowany obiekt <code>db</code>, być może jeden ze współdzielonych przez wiele aplikacji. Jeśli używa się SQLite, to zaleca się stosowanie oddzielnych baz danych – odrębnej dla aplikacji i dla terminarza, tak aby utrzymać responsywność aplikacji. Po zdefiniowaniu zadań i utworzeniu instancji <code>Scheduler</code>, wszystko co trzeba zrobić, to uruchomić workery. Można to zrobić na kilka sposobów:</p><pre><code>python web2py.py -K myapp</code></pre><p>uruchamia workera dla aplikacji <code>myapp</code>. Jeśli chce się uruchomić wiele workerów dla tej samej aplikacji, można to zrobić przekazując po prostu <code>myapp,myapp</code>. Można przekazać również <code>group_names</code> (przesłaniając jedno z ustawień w modelu) poprzez</p><pre><code>python web2py.py -K myapp:group1:group2,myotherapp:group1</code></pre><p>Jeśli ma się model o nazwie <code>scheduler.py</code> można uruchomić (zatrzymać) workery z domyślnego okna web2py (tego używanego do ustawiania adresu IP i portu).</p><h5>Wdrożenie terminarza</h5><p>Jeden ostatni miły dodatek: w przypadku korzystania z wbudowanego serwera internetowego, można uruchomić ten serwer i terminarz za pomocą jednej linii kodu (jeśli nie chce się, aby wyskakiwało okno web2py, to można użyć zamiast tego menu "Schedulers")</p><pre><code>python web2py.py -a yourpass -K myapp -X</code></pre><p>Można przekazać zwykłe parametry (-i, -p, tutaj -a zabezpiecza okno przed wyświetlaniem), przekazać cokolwiek do aplikacji w parametrze -K i dołączyć -X. Terminarz będzie działać obok serwera internetowego!</p><p>Użytkownicy Windows poszukujący informacji o tworzeniu usługi terminarza powinni szukać jej w rozdziale "Recepty wdrożeniowe".</p><h5>Kompletna sygnatura terminarza</h5><p>Pełna sygnatura terminarza to:</p><pre><code class="code">Scheduler(
    db,
    tasks=None,
    migrate=True,
    worker_name=None,
    group_names=None,
    heartbeat=HEARTBEAT,
    max_empty_runs=0,
    discard_results=False,
    utc_time=False
)</code></pre><p>Omówmy ją po kolei:</p><ul><li><code>db</code> to instancja DAL bazy danych, w której chce się umieścić tabele terminarza;</li><li><code>tasks</code> to słownik odwzorowujący nazwy zadań na funkcje. Jeśli nie przekaże się tego parametru, to funkcja będzie wyszukiwana w środowisku aplikacji;</li><li><code>worker_name</code> domyślnie None. Jak tylko zostanie uruchomiony worker, generowana jest jego nazwa jako uuid. Jeśli chce się ją określić samemu, to trzeba być pewnym, że wybrana nazwa jest unikalna.</li><li><code>group_names</code> domyślnie ustawiony jest na <strong>[main]</strong>. Wszystkie zadania mają parametr <code>group_name</code> ustawiony domyślnie na <strong>main</strong>. Workery mogą tylko wybierać zadania przypisane do ich grupy.</li></ul><blockquote>NB: Jest to przydatne, jeśłi ma się różne instancje workerów (np. na różnych maszynach)
i chce się przypisać zadania do określonego workera.</blockquote><blockquote>NB2: Jest możliwe, aby przypisać workerowi więcej grup i mogą być one również wszystkie
takie same jak <code>['mygroup','mygroup']</code>. Zadania zostaną rozdzielone, przy uwzględnieniu,
że worker z group_names <code>['mygroup','mygroup']</code> jest zdolny przetworzyć dwa razy
więcej zadań niż worker z nazwą <code>['mygroup']</code>.</blockquote><ul><li><code>heartbeat</code> domyślnie jest ustawiony na 3 sekundy. Parametr ten kontroluje jak często terminarz ma sprawdzać swój stan w tabeli <code>scheduler_worker</code> i stwierdzić, czy są jakieś zadania przypisane do jego procesu;</li><li><code>max_empty_runs</code> domyślnie to 0, co oznacza, że worker będzie kontynuować przetwarzanie zadań dopóki są <strong>PRZETWARZANE</strong>. Jeśli ustawi się to na jakąś wartość inną niż 0, powiedzmy na 10, worker przestanie działać automatycznie po dziesięciu pętlach, jeśli jest <strong>AKTYWNE</strong> i żadne zadania nie są <strong>PRZYPISANE</strong>. Pętla wykonywana jest kiedy worker wyszukuje zadania, co 3 sekundy (lub o interwale ustawionym w <code>heartbeat</code>);</li><li><code>discard_results</code> domyślnie False. Jeśli ustawione na True, nie zostaną utworzone żadne rekordy scheduler_run.</li></ul><blockquote>NB: rekordy scheduler_run będą tworzone jak poprzednio dla stanów zadań <strong>BŁĘDNE</strong>, <strong>PO CZASIE</strong> i <strong>ZATRZYMANE</strong>.</blockquote><ul><li><code>utc_time</code> domyślnie False. Jeśli zachodzi potrzeba koordynacji workerów znajdujących się w różnych strefach czasowych lub nie ma się problemu z czasem solar/DST, dostarczającym danych czasowych dla różnych krajów itd., można ustawić ten parametr na True. Terminarz będzie uznawał czas UTC i działać będzie pozostawiając czas lokalny na boku. Uwaga: trzeba planować zadania w czasach UTC (dla start_time, stop_time i tak dalej).</li></ul><p>Mamy już teraz ustawioną infrastrukturę: zdefiniowane zadania, poinformowany terminarz o nich, uruchomiony worker (workery). Pozostaje właściwe zaplanowanie zadań</p><h5>Zadania</h5><p>Zadania mogą być planowane programowo lub poprzez interfejs administracyjny. W rzeczywistości planowanie zadania odbywa się poprzez dodanie wpisu do tabeli "scheduler_task", do której dostęp można uzyskać poprzez interfejs administracyjny:</p><pre><code>http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task</code></pre><p>Znaczenia pól tej tabeli są oczywiste. Pola "args" i "vars"" są wartościami przekazywanymi do zadania w formacie JSON. W przypadku poprzednio rozpatrywanego "task_add", przykładem "args" i "vars" może być:</p><pre><code class="code">args = [3, 4]
vars = {}</code></pre><p>lub</p><pre><code class="code">args = []
vars = {'a':3, 'b':4}</code></pre><p>Zadania organizowane są w tabeli <code>scheduler_task</code>.</p><p>W celu dodania zadań poprzez API, trzeba zastosować</p><pre><code>scheduler.queue_task('mytask',...)</code></pre><p>co jest udokumentowane <a href="#markmin_queue_task_sig">poniżej</a> .</p><h5>Cykl życia zadania</h5><p>Wszystkie zadania mają następujący cykl życia</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/ce8edcc3.png" alt="scheduler tasks" /></p></p><p>Domyślnie podczas wysyłania zadania do terminarza ma ono status <strong>QUEUED</strong>. Jeżeli zachodzi potrzeba późniejszego wykonania tego zadania, to stosuje się parametr <code>start_time</code> (domyślnie now). Jeśli z jakichś powodów musi się mieć pewność, że zadanie nie zostanie wykonane później niż jakiś moment czasu (na przykład, do usługi internetowej, która zostaje zamknięta o 1AM, poczty, która musi być wysłana po godzinach pracy itd.) można ustawić dla niego parametr <code>stop_time</code> (domyślnie None). Jeśli zadanie NIE zostało pobrane przez workera przed czasem określonym w <code>stop_time</code>, będzie ustawione jako <strong>EXPIRED</strong>. Zadania z nie ustawionym parametrem <code>stop_time</code> lub pobrane <strong>PRZED</strong> czasem stop_time są <strong>ASSIGNED</strong> do workera. Gdy workery pobierają zadanie, jego stan jest ustawiany na <strong>RUNNING</strong>.</p><p>Zadania uruchomione (status <strong>RUNING</strong>) można zakończyć ze statusem:</p><ul><li><strong>TIMEOUT</strong> gdy upłynęło więcej niż <code>n</code> sekund od czasu przekazanego przez parametr <code>timeout</code> (domyślnie 60 sekund);</li><li><strong>FAILED</strong> gdy wykryty został wyjątek;</li><li><strong>COMPLETED</strong> gdy zadanie zostało zakończone pomyślnie.</li></ul><p>Wartości dla <code>start_time</code> i <code>stop_time</code> powinny być obiektami datetime. W celu zaplanowania zadania "mytask", tak aby uruchamiane było, na przykład, co 30 sekund od chwili obecnej, można wykonać co następuje:</p><pre><code class="code">from datetime import timedelta as timed
scheduler.queue_task('mytask',
    start_time=request.now + timed(seconds=30))</code></pre><p>Dodatkowo można kontrolować ile razy zadanie powinno być powtarzane (czyli trzeba zgrupować kilka danych określających interwały czasowe). Aby to wykonać, trzeba ustawić parametr <code>repeats</code> (domyślnie 1, 0 – nieograniczona ilość razy). Można wpłynąć na to, ile sekund powinno upłynąć pomiędzy poszczególnymi wykonaniami ustawiając parametr <code>period</code> (domyślnie 60 sekund).</p><blockquote>Domyślnie, czas nie jest obliczany między końcem pierwszego cyklu a początkiem
następnego, ale pomiędzy początkiem pierwszego cyklu a początkiem następnego cyklu). 
Może to powodować gromadzenie się 'dryftu' (opóźnień) w momencie rozpoczęcia zadania.
Po wersji 2.8.2 został dodany nowy parametr <code>prevent_drift</code> z domyślną wartością
False. Po ustawieniu na True, przy kolejnym wykonaniu zadania, parametr start_time
będzie uzyskiwał pierwszeństwo, zabezpieczając przed dryftem.</blockquote><p>Można również ustawić, ile razy funkcje mogą zgłaszać wyjątki (np. w przypadku żądania danych z powolnych serwisów internetowych) i ponownie kolejkować je zamiast zatrzymywać ze statusem <strong>FAILED</strong>,  wykorzystując parametr <code>retry_failed</code> (domyślnie 0, -1 - nieograniczone).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/7d8b85e4.png" alt="task repeats" /></p></p><p>Podsumowując, można ustawić</p><ul><li><code>period</code> i <code>repeats</code> aby automatycznie pobierać zmienioną funkcję;</li><li><code>timeout</code> aby się upewnić, że funkcja nie przekracza okreśłonej ilości czasu;</li><li><code>retry_failed</code> aby kontrolować ile razy zadanie może być "błędne";</li><li><code>start_time</code> i <code>stop_time</code> aby zaplanować funkcje w wymaganym okresie czasu.</li></ul><h5><code>queue_task</code> i <code>task_status</code> <span class="anchor" id="markmin_queue_task_sig"></span></h5><p>Metoda:</p><pre><code class="code">scheduler.queue_task(
    function,
    pargs=[],
    pvars={},
    start_time=now, 		#datetime
    stop_time = None,		#datetime
    timeout = 60,               #seconds
    prevent_drift=False,
    period=60,                  #seconds
    immediate=False,
    repeats = 1
)</code></pre><p>pozwala kolejkować zadania, które mają być wykonywane przez workery. Metoda ta zwraca wiersz (patrz <a href="#markmin_queue_task_return">tutaj</a>) i pobiera następujące parametry:</p><ul><li><code>function</code> (obowiazkowy): może to być nazwa zadania lub referencje do aktualnej funkcji;</li><li><code>pargs</code>: są argumentami, które będą przekazywane do zadania, zapisywane jako lista Pythona;</li><li><code>pvars</code> : są nazwanymi argumentami, które mają być przekazane do zadania, zapisane jako słownik Pythona;</li><li>wszystkie inne kolumny scheduler_task mogą być przekazywane jako argumenty kluczowe – najważniejsze są wyświetlane.</li></ul><p>Na przykład:</p><pre><code>scheduler.queue_task('demo1', [1,2])</code></pre><p>robi dokładnie to samo, co</p><pre><code class="code">scheduler.queue_task('demo1', pvars={'a':1, 'b':2})</code></pre><p>jako</p><pre><code class="code">st.validate_and_insert(function_name='demo1', args=json.dumps([1,2]))</code></pre><p>i jako:</p><pre><code class="code">st.validate_and_insert(function_name='demo1', vars=json.dumps({'a':1,'b':2}))</code></pre><p>Oto bardziej złożony kompletny przykład:</p><pre><code class="code">def task_add(a,b):
    return a+b

scheduler = Scheduler(db, tasks=dict(demo1=task_add))

scheduler.queue_task('demo1', pvars=dict(a=1,b=2),
                     repeats = 0, period = 180)</code></pre><p>Od wersji 2.4.1, jeśli przekaże się dodatkowy parametr<code>immediate=True</code>, to zostanie wymuszone, aby główny worker ponownie powiązał zadania. Do wersji 2.4.1 worker sprawdzał dla nowego zadania co każde 5 cykli (a więc co <code>5*heartbeats</code> sekund). Jeśli ma się aplikację, która potrzebuje często sprawdzać nowe zadania, aby uzyskać <em>prędkie</em> zachowanie, trzeba wymusić wyższy parametr <code>heartbeat</code>, stawiając niepotrzebnie bazę danych pod presją. Z parametrem <code>immediate=True</code> można wymusić sprawdzanie nowych zadań – trwać to będzie co najwyżej taką ilość sekund, jaką przekazano w <code>heartbeat</code>.</p><p>Wywołanie <code>scheduler.queue_task</code> zwraca <code>id</code> zadania i <code>uuid</code> zadania, które oczekuje w kolejce (może być tym, co zostało przekazane lub tym, co zostało wygenerowane automatycznie) i ewentualnie <code>errors</code>: <span class="anchor" id="markmin_queue_task_return"></span></p><pre><code>&lt;Row {'errors': {}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'}&gt;</code></pre><p>Jeśli wystąpią jakieś błędy (zazwyczaj błąd składni lub błędy sprawdzania danych wejściowych), to zwrócony będzie wynik walidacji, a identyfikatory id i uuid będą miały wartość None</p><pre><code>&lt;Row {'errors': {'period': 'enter an integer greater than or equal to 0'}, 'id': None, 'uuid': None}&gt;</code></pre><h5>Wyniki i dane wyjściowe</h5><p>Tabela "scheduler_run" przechowuje statusy wszystkich uruchomionych zadań. Każdy rekord odpowiada zadaniu, jakie zostało wybrane przez workera.  Jedno zadanie może mieć wiele uruchomień. Na przykład, zadanie zaplanowane do powtórzenia 10 razy w ciągu godziny będzie przypuszczalnie mieć 10 uruchomień (chyba, ze jedno z nich zawiedzie lub trwają one dłużej niż 1 godzinę). Trzeba pamiętać, że jeśli zadanie nie ma zwracanych wartości, to jest usuwane z tabeli scheduler_run jak tylko zakończy działanie.</p><p>Możliwe statusy, to:</p><pre><code>RUNNING, COMPLETED, FAILED, TIMEOUT</code></pre><p>Jeśli uruchomienie zostało zakończone, nie zgłoszone zostały jakieś wyjątki i nie ma zadań z przekroczonym limitem czasu, uruchomienie jest oznaczane jako <code>COMPLETED</code> a samo zadanie jako <code>QUEUED</code> lub <code>COMPLETED</code>, w zależności od tego czy jest przeznaczone do ponownego uruchomienia w późniejszym czasie. Dane wyjściowe zadania są serializowane do formatu JSON i zapisywane w rekordzie uruchomienia.</p><p>Gdy uruchomione zadanie (ze statusem <code>RUNNING</code>) zgłasza wyjątek, uruchomienie i samo zadanie zostają oznaczone jaki błędne (status <code>FAILED</code>). Komunikat o ostatnim wywołaniu (traceback) zostaje zapisane w rekordzie uruchomienia.</p><p>Podobnie, gdy uruchomienie przekroczy określony limit czasu, to zostanie zatrzymane i oznaczone jako <code>TIMEOUT</code>, tak samo jak zadanie.</p><p>W każdym przypadku, standardowy strumień wyjścia <em>stdout</em> jest przechwytywany i również rejestrowany w rekordzie uruchomienia.</p><p>Używając interfejsu administracyjnego, można sprawdzić wszystkie uruchomione zadania (ze statusem <code>RUNNING</code>), dane wyjściowe zadań zakończonych (ze statusem <code>COMPLETED</code>), błąd zadań błędnych (ze statusem <code>FAILED</code>) itd.</p><p>Terminarz również tworzy jeszcze jedną tabele o nazwie "scheduler_worker", która przechowuje dane parametru <code>heartbeat</code> workerów i ich statusy.</p><h5>Zarządzanie procesami</h5><p>Zarządzanie workerami jest trudne. Moduł ten stara się obsłużyć każdą platformę (Mac, Win, Linux).</p><p>Po uruchomieniu workera, można później potrzebować go:</p><ul><li>zabić "bez względu na to co robi";</li><li>zabić tylko wtedy, gdy żadne zadanie nie jest przetwarzane;</li><li>uśpić.</li></ul><p>Załóżmy, że mamy jeszcze jakieś zadania w kolejce i chcemy zaoszczędzić trochę zasobów. Chcemy te zadania przetworzyć co godzinę, tak więc możemy:</p><ul><li>przetworzyć wszystkie zadania w kolejce i automatycznie je zlikwidować.</li></ul><p>Wszystkie te rzeczy są możliwe do zrobienia w zarządzaniu parametrami klasy <code>Scheduler</code> lub tabelą <code>scheduler_worker</code>. Aby być bardziej precyzyjnym, dla rozpoczętych workerów można zmienić wartość <code>status</code> każdego workera, aby wpłynąć na jego zachowanie. Co do zadań, workery mogą się znajdować w jednym z następujących stanów: ACTIVE, DISABLED, TERMINATE lub KILLED.</p><p>Stany <strong>ACTIVE</strong> i <strong>DISABLED</strong> są stanami "trwałymi", podczas gdy <strong>TERMINATE</strong> i <strong>KILL</strong>, jak sugeruje sama nazwa, są bardziej poleceniami niż stanami. Użycie w terminalu (w którym uruchomiono workera) klucza Ctrl+C jest równoważne ustawieniu workera w stan <strong>KILL</strong>.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/bd891eed.png" alt="workers statuses" /></p></p><p>Począwszy 2.4.1 dostępnych jest kilka narzędziowych funkcji:</p><pre><code class="code">scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()</code></pre><p>Każda z tych funkcji przyjmuje opcjonalny parametr, który może być łańcuchem lub listą, w celu zarządzania workerami na podstawie <code>group_names</code>. Domyśłnie jest to parametr <code>group_names</code> zdefiniowany w obiekcie terminarza.</p><p>Przykład jest lepszy niż tysiące słów: <code>scheduler.terminate('high_prio')</code> zakończy działanie wszystkich workerów, które przetwarzają zadania <code>high_prio</code>, podczas gdy <code>scheduler.terminate(['high_prio', 'low_prio'])</code> zakończy działanie wszystkich workerów z zadaniami <code>high_prio</code> i <code>low_prio</code>.</p><blockquote>Uważaj: jeśli ma się worker przetwarzający <code>high_prio</code> i <code>low_prio</code>,
<code>scheduler.terminate('high_prio')</code> będzie usuwał każdy taki worker, nawet jeśli
nie chce się usunąć workerów z <code>low_prio</code>.</blockquote><p>Wszystko co można zrobić z poziomu interfejsu administracyjnego, można zrobić programowo przez wstawienie i zaktualizowanie rekordów w tych tabelach.</p><p>W każdym razie, nie powinno się aktualizować rekordów dotyczących zadań ze statusem <code>RUNNING</code>, gdyż może spowodować to nieoczekiwane zachowanie się kodu. Najlepszą praktyką jest kolejkowanie zadań przy wykorzystaniu metody "queue_task".</p><p>Na przykład:</p><pre><code class="code">scheduler.queue_task(
    function_name='task_add',
    pargs=[],
    pvars={'a':3,'b':4},
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 120, # should take less than 120 seconds
    )</code></pre><p>Proszę zauważyć, że pola "times_run", "last_run_time" i "assigned_worker_name" nie są udostępniane w czasie planowania, ale są wypełniane automatycznie przez workery.</p><p>Można też pobrać dane wyjściowe zakończonych zadań:</p><pre><code class="code">completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()</code></pre><blockquote>Terminarz jest jeszcze uważany za eksperymentalny, ponieważ może ulec zmianie
struktura tabeli, jak też mogą zostać dodane nowe możliwości.</blockquote><h5>Procentowe raportowanie</h5><p>W wyrażeniach print funkcji można użyć specjalne"słowo" czyszczące wszystkie poprzednie dane wyjściowe. Słowem tym jest <code>!clear!</code>. To w połączeniu z parametrem <code>sync_output</code> umożliwia procentowe raportowanie.</p><p>Oto przykład:</p><pre><code>def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1</code></pre><p>Funkcja <code>reporting_percentages</code> śpi przez 5 sekund, wyprowadza <code>50%</code>. Następnie, znowu śpi przez 5 sekund i wyprowadza <code>100%</code>. Proszę zauważyć, że dane wyjściowe w tabeli scheduler_run są synchronizowane co 2 sekundy i że drugie wyrażenie print, zawierające <code>!clear!100%</code>, dostaje wyczyszczone wyjście <code>50%</code> i zamienia to na <code>100%</code>.</p><pre><code class="code">scheduler.queue_task(reporting_percentages,
                     sync_output=2)</code></pre><h3>Moduły osób trzecich</h3><div class="inxx">import</div><p>Framework web2py jest napisany w Pythonie, tak więc można go importować i używać jak każdy moduł Pythona, podobnie jak moduły osób trzecich. Wystarczy, że Python będzie miał możliwość odnalezienia ich. Tak jak w przypadku każdej aplikacji Pythona, moduły mogą być instalowane w oficjalnym ogólnowitrynowym katalogu pakietów Pythona, a następnie importowane w dowolnym miejscu kodu.</p><p>Moduły w witrynowym katalogu pakietów są, jak sama nazwa wskazuje, pakietami poziomu witryny. Aplikacje wymagające pakietów witrynowych nie są przenośne, chyba że moduły te są zainstalowane oddzielnie. Zaleta posiadania modułów w witrynowym katalogu pakietów jest to, że korzystać z nich może wiele aplikacji. Przyjrzyjmy się, na przykład, pakietowi kreślarskiemu o nazwie "matplotlib". Można zainstalować go z poziomu powłoki używając polecenia PEAK <code>easy_install</code> <sup>[<a href="/book/default/reference/42/easy-install" target="_blank">easy-install</a>]</sup> (lub jego nowszy zamiennik <code>pip</code> <sup>[<a href="/book/default/reference/42/PIP" target="_blank">PIP</a>]</sup> ):</p><pre><code class="code">easy_install py-matplotlib</code></pre><p>a następnie można zaimportować go do dowolnego modelu, kontrolera czy widoku poleceniem:</p><pre><code class="code">import matplotlib</code></pre><p>Dystrybucja źródłowa web2py i dystrybucja binarna Windows mają pakiety witrynowe w folderze głównego poziomu. Dystrybucja binarna Mac ma folder pakietów witrynowych w folderze:</p><code class="code">web2py.app/Contents/Resources/site-packages</code><p>Problem z wykorzystaniem pakietów witrynowych jest taki, że trudno jest używać różnych wersji poszczególnych modułów w tym samym czasie. Na przykład nie może być dwóch aplikacji, w których każda uzywa inną wersję tego samego pliku. W tym przykładzie, <code>sys.path</code> nie poze być zmienione ponieważ ma to wpływ na obie aplikacje.</p><p>Dla tego rodzaju sytuacji web2py dostarcza inny sposób importu modułów w taki sposób, ze globalna zmienna <code>sys.path</code> jest niezmienna – przez umieszczenie tych modułów w folderze "modules" aplikacji. Jedną z zalet tego rozwiązania jest to, że moduł będzie automatycznie kopiowany  i dystrybuowany z aplikacją.</p><blockquote>Po umieszczeniu modułu "mymodule.py" w folderze "modules/" aplikacji, może on zostać
zaimportowany z dowolnego miejsca aplikacji web2py (bez potrzeby zmiany <code>sys.path</code>):
<pre><code>import mymodule</code></pre></blockquote><h3>Środowisko wykonawcze</h3><div class="inxx">exec_environment</div><blockquote>Chociaż wszystko co tu opisano działa, to jednak zamiast tego rozwiązania zalecamy
zbudowanie swojej aplikacji przy wykorzystaniu komponentów omówionych w rozdziale 12.</blockquote><p>Pliki modelu i kontrolera web2py różnią się od typowych modułów Pythona tym, że nie mogą być importowane przy użyciu wyrażenia <code>import</code> Pythona. Powodem jest to, że modele i kontrolery są zaprojektowane do ich wykonywania w przygotowanym środowisku, które zostało wstępnie wypełnione globalnymi obiektami web2py (żądanie, odpowiedź, sesja, pamięć podręczna i T) oraz funkcjami pomocniczymi (helperami). Jest to konieczne, ponieważ Python jest językiem o statycznym zakresie leksykalnym, podczas gdy środowisko web2py jest tworzone dynamiczne.</p><p>Framework web2py dostarcza funkcję <code>exec_environment</code> umożliwiającą bezpośredni dostęp  do modeli i kontrolerów. Funkcja <code>exec_environment</code> tworzy środowisko wykonawcze web2py, ładując do niego plik, a  następnie zwracając obiekt Storage zawierający środowisko. Obiekt Storage obsługuje również mechanizm przestrzeni nazw. Każdy plik Pythona, zaprojektowany jako wykonywany w środowisku wykonawczym, może być ładowany przy użyciu <code>exec_environment</code>. Zastosowanie <code>exec_environment</code> obejmuje:</p><ul><li>Uzyskiwanie dostępu do danych (modeli) z innych aplikacji.</li><li>Dostęp do obiektów globalnych z innych modeli lub kontrolerów.</li><li>Wykonywanie funkcji kontrolera z poziomu innych kontrolerów.</li><li>Ładowanie bibliotek pomocniczych dla całej witryny.</li></ul><p>Następujący przykład odczytuje wiersze z tabeli <code>user</code> w aplikacji <code>cas</code>:</p><pre><code class="code">from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)</code></pre><p>Inny przykład. Załóżmy, że mamy kontroler "other.py", który zawiera:</p><pre><code class="code">def some_action():
    return dict(remote_addr=request.env.remote_addr)</code></pre><p>Oto jak można wywołać ta akcję z poziomu innego kontrolera (lub z powłoki web2py):</p><pre><code class="code">from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()</code></pre><p>W linii 2, wyrażenie <code>request=request</code> jest opcjonalne. Jego efektem jest przekazanie bieżącego żądania do środowiska "other". Bez tego argumentu środowisko powinno zawierać nowy i pusty obiekt żądania (oprócz <code>request.folder</code>). Możliwe jest również przekazanie obiektu odpowiedzi i sesji do <code>exec_environment</code>. Trzeba jednak być bardzo ostrożnym przekazując obiekty żądania, odpowiedzi i sesji  --- modyfikacja przez wywołanie akcji lub zależności kodowe w wywołanej akcji mogą doprowadzić do nieoczekiwanych efektów.</p><p>Wywołanie funkcji w linii 3 nie wywołuje widoku. Zwraca po prostu słownik, chyba że <code>response.render</code> zostanie wywołany jawnie przez "some_action".</p><p>Jedna końcowa uwaga: nie należy używać <code>exec_environment</code> niewłaściwie. Jeśli chce się otrzymywać wyniki akcji w innej aplikacji, to prawdopodobnie trzeba zaimplementować XML-RPC API (implementacja API XML-RPC w web2py jest niemal trywialna). Nie należy używać <code>exec_environment</code> jako mechanizmu przekierowań – w takim przypadku trzeba wykorzystać helper <code>redirect</code>.</p><h3>Współdzialanie aplikacji</h3><div class="inxx">współdziałanie aplikacji</div><p>Istnieje kilka postaci współdziałania aplikacji:</p><ul><li>Aplikacje mogą łączyć się z tą sama bazą danych i współdzielić tabele. Nie jest konieczne, aby wszystkie tabele w bazie danych były definiowane przez wszystkie aplikacje, ale muszą być zdefiniowane w tych aplikacjach, które je używają. Wszystkie aplikacje mogą używać tej samej tabeli, ale jedna musi ją definiować z parametrem <code>migrate=False</code>.</li><li>Aplikacje mogą osadzać komponenty z innych aplikacji, przy użyciu helpera LOAD (opisanego w rozdziale 12).</li><li>Aplikacje mogą współdzielić sesje.</li><li>Aplikacje mogą zdalnie wywoływać akcję kazdej innej aplikacji poprzez XML-RPC.</li><li>Aplikacje mogą uzyskiwać dostęp do plików każdej innej aplikacji poprzez system plików (zakładając, że współdzielą ten sam system plików).</li><li>Aplikacje mogą lokalnie wywoływać akcje każdej innej aplikacji używając, tak jak omówiono to powyżej.</li><li>Aplikacje mogą importować moduły każdej innej aplikacji używając składni:</li></ul><pre><code class="code">from applications.otherapp.modules import mymodule</code></pre><p>lub</p><pre><code class="code">import applications.otherapp.modules.othermodule</code></pre><ul><li>Aplikacje mogą importować dowolny moduł zlokalizowany na ścieżce wyszukiwania <code>PYTHONPATH</code>, <code>sys.path</code>.</li></ul><p>W jedna aplikacji można załadować sesję innej aplikacji używając polecenia:</p><pre><code class="code">session.connect(request, response, masterapp='appname', db=db)</code></pre><p>Tutaj "appname" jest nazwą aplikacji nadrzędnej, która ustawia w ciasteczku początkowy parametr session_id. Parametr <code>db</code> jest połączeniem z bazą danych zawierającą tabele sesji (<code>web2py_session</code>). Wszystkie aplikacje, które współdzielą sesje muszą użyć tej samej bazy danych do przechowywania sesji.</p><h3>Rejestrowanie zdarzeń</h3><p>Python dostarcza API rejestrowania zdarzeń. Web2py dostarcza mechanizm konfigurujący ten interfejs, tak aby aplikacje mogły go używać.</p><p>W aplikacji można utworzyć rejestrator, na przykład w modelu:</p><pre><code class="code">import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)</code></pre><p>i można go zastosować do rejestracji komunikatów o różnej ważności</p><pre><code class="code">logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)</code></pre><p><code>logging</code> to standardowy moduł Pythona, opisany na stronie:</p><pre><code>http://docs.python.org/library/logging.html</code></pre><p>Łańcuch "web2py.app.myapp" definiuje rejestrator poziomu aplikacji.</p><p>Jednak aby działał on poprawnie, potrzebny jest plik konfiguracyjny dla rejestratora. Jeden jest dostarczany przez web2py w folderze "examples" i ma nazwę "logging.example.conf". Trzeba skopiować ten plik do katalogu web2py i zmienić jego nazwę na "logging.conf" i dostosować w razie potrzeby.</p><p>Plik ten zawiera opis dokumentacyjny, tak więc wystarczy go otworzyć i przeczytać.</p><p>W celu utworzenia konfigurowalnego rejestratora dla aplikacji "myapp", należy dodać nazwę myapp do listy kluczy [loggers]:</p><pre><code class="code">[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp</code></pre><p>oraz dodać sekcję [logger_myapp], wzorując się na [logger_welcome].</p><pre><code class="code">[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0</code></pre><p>Dyrektywa "handlers" określa typ rejestrowania i tutaj wskazuje na rejestrowanie "myapp" do konsoli.</p><h3>WSGI</h3><div class="inxx">WSGI</div><p>Platformę web2py i WSGI łączy związek miłości i nienawiści. Z naszej perspektywy WSGI został opracowany jako protokół do łączenia serwera internetowego z aplikacjami w przenośny sposób i używamy go do tego celu. Platforma web2py w istocie jest aplikacją WSGI - <code>gluon.main.wsgibase</code>. Niektórzy programiści wykorzystują WSGI w ograniczony sposób jako protokół komunikacyjnej warstwy pośredniej tworząc aplikację internetową jak cebulę z wielu warstw (każda warstwa stanowi warstwę pośrednią WSGI niezależnie od całego frameworka). Platforma web2py nie wprowadza takiej struktury wewnętrznej. To dlatego, że naszym zdaniem, rdzenna funkcjonalność frameworka (obsługa ciasteczek, sesji, błędów, transakcji, rozdzielania) może być lepiej zoptymalizowana pod względem prędkości, jeśli jest obsługiwana kompleksowo przez pojedynczą warstwę.</p><p>A jednak web2py umożliwia wykorzystywanie aplikacji WSGI osób trzecich i warstwy pośredniej na trzy sposoby (i ich kombinację):</p><ul><li>Można edytować plik "wsgihandler.py" i dołączyć dowolna warstwę pośrednią WSGI osób trzecich.</li><li>Można połączyć warstwę pośrednią WSGI osób trzecich do konkretnej akcji w swojej aplikacji.</li><li>Można wywołać aplikację WSGI osób trzecich z poziomu swojej aplikacji.</li></ul><p>Jedynym ograniczeniem jest to, że nie można zastosować warstwy pośredniej osób trzecich do zamiany funkcji rdzenia web2py.</p><h4>Zewnętrzna warstwa pośrednia</h4><p>Rozważmy plik "wsgibase.py":</p><pre><code class="code">#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase</code></pre><p>Gdy <code>LOGGING</code> jest ustawiona na <code>True</code>, <code>gluon.main.wsgibase</code> zostaje opakowywana przez funkcje warstwy pośredniej <code>gluon.main.appfactory</code>. Zapewnia to rejestrowanie zdarzeń w pliku "httpserver.log". W podobny sposób można dodać dowolna warstwę pośrednią. Polecamy zapoznać się z oficjalna dokumentacją WSGI w celu poznania szczegółów.</p><h4>Wewnętrzna warstwa pośrednia</h4><p>Każda aplikacja warstwy pośredniej osób trzecich (na przykład <code>MyMiddleware</code>, która konwertuje dane wyjściowe na duże litery), może być użyta jako dekorator web2py tworzący warstwę pośrednia dla dowolnej akcji kontrolera (na przykład <code>index</code>). Oto przykład:</p><pre><code class="code">class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'</code></pre><p>Nie możemy gwarantować, że wszystkie warstwy pośrednie osób trzecich będą działać z tym mechanizmem.</p><h4>Wywoływanie aplikacji <em>WSGI</em></h4><p>Aplikacja WSGI może być łatwo wywołana z poziomu akcji web2py. Oto przykład:</p><pre><code class="code">def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()</code></pre><p>W tym przypadku akcja <code>index</code> wywołuje <code>test_wsgi_app</code> i przed zwróceniem wartości zabezpiecza dane wyjściowe znakami ucieczki. Proszę zwrócić uwagę, że akcja <code>index</code> nie jest sama w sobie aplikacją WSGI i musi być wykorzystane zwykłe API web2py (takie jak <code>response.write</code> do zapisu do gniazda).</p>