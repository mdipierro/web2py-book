<h2>Services</h2><p><div class="inxx">Web Services</div> <div class="inxx">API</div></p><p>The W3C defines a web service as "a software system designed to support interoperable machine-to-machine interaction over a network". This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.</p><p>In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.</p><p>web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.</p><p>Each of those protocols are supported in multiple ways, and we make a distinction between:</p><ul><li>Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)</li><li>Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)</li></ul><h3>Rendering a dictionary</h3><h4>HTML, XML, and JSON</h4><p><div class="inxx">HTML</div> <div class="inxx">XML</div> <div class="inxx">JSON</div></p><p>Consider the following action:</p><pre><code class="code">def count():
    session.counter = (session.counter or 0) + 1
    return dict(counter=session.counter, now=request.now)</code></pre><p>This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.</p><p>Normally this page would be requested via:</p><pre><code class="code">http://127.0.0.1:8000/app/default/count</code></pre><p>and rendered in HTML. Without writing one line of code, we can ask web2py to render this page using different protocols by adding an extension to the URL:</p><pre><code class="code">http://127.0.0.1:8000/app/default/count.html
http://127.0.0.1:8000/app/default/count.xml
http://127.0.0.1:8000/app/default/count.json</code></pre><p>The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.</p><p>Here is the XML output:</p><pre><code class="code">&lt;document&gt;
   &lt;counter&gt;3&lt;/counter&gt;
   &lt;now&gt;2009-08-01 13:00:00&lt;/now&gt;
&lt;/document&gt;</code></pre><p>Here is the JSON output:</p><pre><code class="code">{ 'counter':3, 'now':'2009-08-01 13:00:00' }</code></pre><p>Notice that date, time and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.</p><h4>Generic views</h4><p>When, for example, the ".xml" extension is called, web2py looks for a template file called "default/count.xml", and if it does not find it, looks for a template called "generic.xml".  The files "generic.html", "generic.xml", "generic.json" are provided with the current scaffolding application. Other extensions can be easily defined by the user.</p><blockquote>For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic_patterns.</blockquote><p>Assuming you are using a copy of scaffold app, edit the following line in models/db.py</p><ul><li>restrict access only to localhost</li></ul><pre><code class="code">response.generic_patterns = ['*'] if request.is_local else []</code></pre><ul><li>to allow all generic views</li></ul><pre><code class="code">response.generic_patterns = ['*']</code></pre><ul><li>to allow only .json</li></ul><pre><code class="code">response.generic_patterns = ['*.json']</code></pre><p>The generic_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.</p><pre><code class="code">response.generic_patterns = ['*.json','*.xml']</code></pre><p>To use it in an older web2py app, you may need to copy the "generic.*" files from a later scaffolding app (after version 1.60).</p><p>Here is the code for "generic.html"</p><pre><code class="code">{{extend 'layout.html'}}

{{=BEAUTIFY(response._vars)}}

&lt;button onclick="document.location='{{=URL("admin","default","design",
args=request.application)}}'"&gt;admin&lt;/button&gt;
&lt;button onclick="jQuery('#request').slideToggle()"&gt;request&lt;/button&gt;
&lt;div class="hidden" id="request"&gt;&lt;h2&gt;request&lt;/h2&gt;{{=BEAUTIFY(request)}}&lt;/div&gt;
&lt;button onclick="jQuery('#session').slideToggle()"&gt;session&lt;/button&gt;
&lt;div class="hidden" id="session"&gt;&lt;h2&gt;session&lt;/h2&gt;{{=BEAUTIFY(session)}}&lt;/div&gt;
&lt;button onclick="jQuery('#response').slideToggle()"&gt;response&lt;/button&gt;
&lt;div class="hidden" id="response"&gt;&lt;h2&gt;response&lt;/h2&gt;{{=BEAUTIFY(response)}}&lt;/div&gt;
&lt;script&gt;jQuery('.hidden').hide();&lt;/script&gt;</code></pre><p>Here is the code for "generic.xml"</p><pre><code class="code">{{
try:
   from gluon.serializers import xml
   response.write(xml(response._vars),escape=False)
   response.headers['Content-Type']='text/xml'
except:
   raise HTTP(405,'no xml')
}}</code></pre><p>And here is the code for "generic.json"</p><pre><code class="code">{{
try:
   from gluon.serializers import json
   response.write(json(response._vars),escape=False)
   response.headers['Content-Type']='text/json'
except:
   raise HTTP(405,'no json')
}}</code></pre><p>Any dictionary can be rendered in HTML, XML and JSON as long as it only contains python primitive types (int, float, string, list, tuple, dictionary). <code>response._vars</code> contains the dictionary returned by the action.</p><p>If the dictionary contains other user-defined or web2py-specific objects, they must be rendered by a custom view.</p><h4>Rendering <code>Rows</code></h4><div class="inxx">as_list</div><p>If you need to render a set of Rows as returned by a select in XML or JSON or another format, first transform the Rows object into a list of dictionaries using the <code>as_list()</code> method.</p><p>Consider for example the following mode:</p><pre><code class="code">db.define_table('person', Field('name'))</code></pre><p>The following action can be rendered in HTML, but not in XML or JSON:</p><pre><code class="code">def everybody():
    people = db().select(db.person.ALL)
    return dict(people=people)</code></pre><p>while the following action can rendered in XML and JSON:</p><pre><code class="code">def everybody():
    people = db().select(db.person.ALL).as_list()
    return dict(people=people)</code></pre><h4>Custom formats</h4><p>If, for example, you want to render an action as a Python pickle:</p><pre><code class="code">http://127.0.0.1:8000/app/default/count.pickle</code></pre><p>you just need to create a new view file "default/count.pickle" that contains:</p><pre><code class="code">{{
import cPickle
response.headers['Content-Type'] = 'application/python.pickle'
response.write(cPickle.dumps(response._vars),escape=False)
}}</code></pre><p>If you want to be able to render any action as a pickled file, you need only to save the above file with the name "generic.pickle".</p><p>Not all objects are pickleable, and not all pickled objects can be un-pickled. It is safe to stick to primitive Python objects and combinations of them. Objects that do not contain references to file streams or database connections are usually pickleable, but they can only be un-pickled in an environment where the classes of all pickled objects are already defined.</p><h4>RSS</h4><div class="inxx">RSS</div><p>web2py includes a "generic.rss" view that can render the dictionary returned by the action as an RSS feed.</p><p>Because the RSS feeds have a fixed structure (title, link, description, items, etc.) then for this to work, the dictionary returned by the action must have the proper structure:</p><pre><code class="code">{'title'      : '',
 'link'       : '',
 'description': '',
 'created_on' : '',
 'entries'    : []}</code></pre><p>and each entry in entries must have the same similar structure:</p><pre><code class="code">{'title'      : '',
 'link'       : '',
 'description': '',
 'created_on' : ''}</code></pre><p>For example the following action can be rendered as an RSS feed:</p><pre><code class="code">def feed():
    return dict(title="my feed",
                link="http://feed.example.com",
                description="my first feed",
                entries=[
                  dict(title="my feed",
                  link="http://feed.example.com",
                  description="my first feed")
                ])</code></pre><p>by simply visiting the URL:</p><pre><code class="code">http://127.0.0.1:8000/app/default/feed.rss</code></pre><p>Alternatively, assuming the following model:</p><pre><code class="code">db.define_table('rss_entry',
    Field('title'),
    Field('link'),
    Field('created_on','datetime'),
    Field('description'))</code></pre><p>the following action can also be rendered as an RSS feed:</p><pre><code class="code">def feed():
    return dict(title="my feed",
                link="http://feed.example.com",
                description="my first feed",
                entries=db().select(db.rss_entry.ALL).as_list())</code></pre><p>The <code>as_list()</code> method of a Rows object converts the rows into a list of dictionaries.</p><p>If additional dictionary items are found with key names not explicitly listed here, they are ignored.</p><p>Here is the "generic.rss" view provided by web2py:</p><pre><code class="code">{{
try:
   from gluon.serializers import rss
   response.write(rss(response._vars),escape=False)
   response.headers['Content-Type']='application/rss+xml'
except:
   raise HTTP(405,'no rss')
}}</code></pre><p>As one more example of an RSS application, we consider an RSS aggregator that collects data from the "slashdot" feed and returns a new web2py rss feed.</p><pre><code class="code">def aggregator():
    import gluon.contrib.feedparser as feedparser
    d = feedparser.parse(
        "http://rss.slashdot.org/Slashdot/slashdot/to")
    return dict(title=d.channel.title,
                link = d.channel.link,
                description = d.channel.description,
                created_on = request.now,
                entries = [
                  dict(title = entry.title,
                  link = entry.link,
                  description = entry.description,
                  created_on = request.now) for entry in d.entries])</code></pre><p>It can be accessed at:</p><pre><code class="code">http://127.0.0.1:8000/app/default/aggregator.rss</code></pre><h4>CSV</h4><div class="inxx">CSV</div><p>The Comma Separated Values (CSV) format is a protocol to represent tabular data.</p><p>Consider the following model:</p><pre><code class="code">db.define_table('animal',
    Field('species'),
    Field('genus'),
    Field('family'))</code></pre><p>and the following action:</p><pre><code class="code">def animals():
    animals = db().select(db.animal.ALL)
    return dict(animals=animals)</code></pre><p>web2py does not provide a "generic.csv"; you must define a custom view "default/animals.csv" that serializes the animals into CSV. Here is a possible implementation:</p><pre><code class="code">{{
import cStringIO
stream=cStringIO.StringIO()
animals.export_to_csv_file(stream)
response.headers['Content-Type']='application/vnd.ms-excel'
response.write(stream.getvalue(), escape=False)
}}</code></pre><p>Notice that one could also define a "generic.csv" file, but one would have to specify the name of the object to be serialized ("animals" in the example). This is why we do not provide a "generic.csv" file.</p><h3>Remote procedure calls</h3><div class="inxx">RPC</div><p>web2py provides a mechanism to turn any function into a web service. The mechanism described here differs from the mechanism described before because:</p><ul><li>The function may take arguments</li><li>The function may be defined in a model or a module instead of controller</li><li>You may want to specify in detail which RPC method should be supported</li><li>It enforces a more strict URL naming convention</li><li>It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.</li></ul><p>To use this feature:</p><p>First, you must import and initiate a service object.</p><pre><code class="code">from gluon.tools import Service
service = Service()</code></pre><blockquote>This is already done in the "db.py" model file in the scaffolding application.</blockquote><p>Second, you must expose the service handler in the controller:</p><pre><code class="code">def call():
    session.forget()
    return service()</code></pre><blockquote>This is already done in the "default.py" controller of the scaffolding application. Remove <code>session.forget()</code> if you plan to use session cookies with the services.</blockquote><p>Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:</p><pre><code class="code">@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.jsonrpc2
@service.amfrpc3('domain')
@service.soap('FunctionName',returns={'result':type},args={'param1':type,})</code></pre><p>As an example, consider the following decorated function:</p><pre><code class="code">@service.run
def concat(a,b):
    return a+b</code></pre><p>This function can be defined in a model or in the controller where the <code>call</code> action is defined. This function can now be called remotely in two ways:</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/run/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/run/concat/hello/world</code></pre><p>In both cases the http request returns:</p><pre><code class="code">helloworld</code></pre><p>If the <code>@service.xml</code> decorator is used, the function can be called via:</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/xml/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/xml/concat/hello/world</code></pre><p>and the output is returned as XML:</p><pre><code class="code">&lt;document&gt;
   &lt;result&gt;helloworld&lt;/result&gt;
&lt;/document&gt;</code></pre><p>It can serialize the output of the function even if this is a DAL Rows object. In this case, in fact, it will call <code>as_list()</code> automatically.</p><p>If the <code>@service.json</code> decorator is used, the function can be called via:</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/json/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/json/concat/hello/world</code></pre><p>and the output returned as JSON.</p><p>If the <code>@service.csv</code> decorator is used, the service handler requires, as the return value, an iterable object of iterable objects, such as a list of lists. Here is an example:</p><pre><code class="code">@service.csv
def table1(a,b):
    return [[a,b],[1,2]]</code></pre><p>This service can be called by visiting one of the following URLs:</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/csv/table1?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/csv/table1/hello/world</code></pre><p>and it returns:</p><pre><code class="code">hello,world
1,2</code></pre><p>The <code>@service.rss</code> decorator expects a return value in the same format as the "generic.rss" view discussed in the previous section.</p><p>Multiple decorators are allowed for each function.</p><p>So far, everything discussed in this section is simply an alternative to the method described in the previous section. The real power of the service object comes with XMLRPC, JSONRPC and AMFRPC, as discussed below.</p><h4>XMLRPC</h4><div class="inxx">XMLRPC</div><p>Consider the following code, for example, in the "default.py" controller:</p><pre><code class="code">@service.xmlrpc
def add(a,b):
    return a+b

@service.xmlrpc
def div(a,b):
    return a/b</code></pre><p>Now in a python shell you can do</p><pre><code class="code">&gt;&gt;&gt; from xmlrpclib import ServerProxy
&gt;&gt;&gt; server = ServerProxy(
       'http://127.0.0.1:8000/app/default/call/xmlrpc')
&gt;&gt;&gt; print server.add(3,4)
7
&gt;&gt;&gt; print server.add('hello','world')
'helloworld'
&gt;&gt;&gt; print server.div(12,4)
3
&gt;&gt;&gt; print server.div(1,0)
ZeroDivisionError: integer division or modulo by zero</code></pre><p>The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.</p><p>The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.</p><h4>ServerProxy signature</h4><code class="code">a_server = ServerProxy(location,transport=None,encoding=None,verbose=False,version=None)</code><p>The important arguments are:</p><ul><li><code>location</code> is the remote URL for the server. There are examples below.</li><li><code>verbose=True</code> activates useful diagnostics</li><li><code>version</code> sets the jsonrpc version. It is ignored by jsonrpc. Set this to <code>version='2.0'</code> to support jsonrpc2. Because it is ignored by jsonrpc, setting it gains support for both versions. It is not supported by XMLRPC.</li></ul><h4>XMLRPC Libraries</h4><p>There are XMLRPC libraries for many programming languages (including C, C++, Java, C#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.</p><p>The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:</p><pre><code class="code">session.forget(response)</code></pre><p><span class="anchor" id="markmin_jsonrpc"></span> <span class="anchor" id="markmin_jsonrpc2"></span></p><h4>JSONRPC</h4><div class="inxx">JSONRPC</div><div class="inxx">JSONRPC2</div><p>In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:</p><pre><code class="code">@service.jsonrpc
@service.jsonrpc2
def add(a,b):
    return a+b

def call():
    return service()</code></pre><p>JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.</p><h4>Accessing JSONRPC services from web2py</h4><p>Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module "gluon/contrib/simplejsonrpc.py" created by Mariano Reingart. Here is an example of how to use to call the above service:</p><pre><code class="code">&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy
&gt;&gt;&gt; URL = "http://127.0.0.1:8000/app/default/call/jsonrpc"
&gt;&gt;&gt; service = ServerProxy(URL, verbose=True)
&gt;&gt;&gt; print service.add(1, 2)</code></pre><p>Use "http://127.0.0.1:8000/app/default/call/jsonrpc2" for jsonrpc2, and create the service object like this:</p><pre><code class="code">service = ServerProxy(URL,verbose=True,version='2.0')</code></pre><h4>JSONRPC and Pyjamas</h4><p><div class="inxx">JSONRPC</div> <div class="inxx">Pyjamas</div></p><p>As an example of application here, we discuss the usage of JSON Remote Procedure Calls with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.</p><p>Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.</p><p>We are going to build a simple "todo" application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.</p><p>First, create a new application called "todo".</p><p>Second, in "models/db.py", enter the following code:</p><pre><code class="code">db=DAL('sqlite://storage.sqlite')
db.define_table('todo', Field('task'))
service = Service()</code></pre><p><em>(Note: Service class is from gluon.tools).</em></p><p>Third, in "controllers/default.py", enter the following code:</p><pre><code class="code">    def index():
    redirect(URL('todoApp'))

    @service.jsonrpc
    def getTasks():
        todos = db(db.todo).select()
        return [(todo.task,todo.id) for todo in todos]

    @service.jsonrpc
    def addTask(taskFromJson):
        db.todo.insert(task= taskFromJson)
        return getTasks()

    @service.jsonrpc
    def deleteTask (idFromJson):
        del db.todo[idFromJson]
        return getTasks()

    def call():
        session.forget()
        return service()

    def todoApp():
        return dict()</code></pre><p>The purpose of each function should be obvious.</p><p>Fourth, in "views/default/todoApp.html", enter the following code:</p><pre><code class="code">&lt;html&gt;
  &lt;head&gt;
    &lt;meta name="pygwt:module"
     content="{{=URL('static','output/TodoApp')}}" /&gt;
    &lt;title&gt;
      simple todo application
    &lt;/title&gt;
  &lt;/head&gt;
  &lt;body bgcolor="white"&gt;
    &lt;h1&gt;
      simple todo application
    &lt;/h1&gt;
    &lt;i&gt;
      type a new task to insert in db,
      click on existing task to delete it
    &lt;/i&gt;
    &lt;script language="javascript"
     src="{{=URL('static','output/pygwt.js')}}"&gt;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>This view just executes the Pyjamas code in "static/output/todoapp" - code that we have not yet created.</p><p>Fifth, in "static/TodoApp.py" (notice it is TodoApp, not todoApp!), enter the following client code:</p><pre><code class="code">from pyjamas.ui.RootPanel import RootPanel
from pyjamas.ui.Label import Label
from pyjamas.ui.VerticalPanel import VerticalPanel
from pyjamas.ui.TextBox import TextBox
import pyjamas.ui.KeyboardListener
from pyjamas.ui.ListBox import ListBox
from pyjamas.ui.HTML import HTML
from pyjamas.JSONService import JSONProxy

class TodoApp:
    def onModuleLoad(self):
        self.remote = DataService()
        panel = VerticalPanel()

        self.todoTextBox = TextBox()
        self.todoTextBox.addKeyboardListener(self)

        self.todoList = ListBox()
        self.todoList.setVisibleItemCount(7)
        self.todoList.setWidth("200px")
        self.todoList.addClickListener(self)
        self.Status = Label("")

        panel.add(Label("Add New Todo:"))
        panel.add(self.todoTextBox)
        panel.add(Label("Click to Remove:"))
        panel.add(self.todoList)
        panel.add(self.Status)
        self.remote.getTasks(self)

        RootPanel().add(panel)

    def onKeyUp(self, sender, keyCode, modifiers):
        pass

    def onKeyDown(self, sender, keyCode, modifiers):
        pass

    def onKeyPress(self, sender, keyCode, modifiers):
        """
        This function handles the onKeyPress event, and will add the
        item in the text box to the list when the user presses the
        enter key. In the future, this method will also handle the
        auto complete feature.
        """
        if keyCode == KeyboardListener.KEY_ENTER and            sender == self.todoTextBox:
            id = self.remote.addTask(sender.getText(),self)
            sender.setText("")
            if id&lt;0:
                RootPanel().add(HTML("Server Error or Invalid Response"))

    def onClick(self, sender):
        id = self.remote.deleteTask(
                sender.getValue(sender.getSelectedIndex()),self)
        if id&lt;0:
            RootPanel().add(
                HTML("Server Error or Invalid Response"))

    def onRemoteResponse(self, response, request_info):
        self.todoList.clear()
        for task in response:
            self.todoList.addItem(task[0])
            self.todoList.setValue(self.todoList.getItemCount()-1,
                                   task[1])

    def onRemoteError(self, code, message, request_info):
        self.Status.setText("Server Error or Invalid Response: "                             + "ERROR " + code + " - " + message)

class DataService(JSONProxy):
    def __init__(self):
        JSONProxy.__init__(self, "../../default/call/jsonrpc",
                           ["getTasks", "addTask","deleteTask"])

if __name__ == '__main__':
    app = TodoApp()
    app.onModuleLoad()</code></pre><p>Sixth, run Pyjamas before serving the application:</p><pre><code class="code">cd /path/to/todo/static/
python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py</code></pre><p>This will translate the Python code into JavaScript so that it can be executed in the browser.</p><p>To access this application, visit the URL:</p><pre><code class="code">http://127.0.0.1:8000/todo/default/todoApp</code></pre><p>This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.<sup>[<a href="/book/default/reference/42/blogspot1" target="_blank">blogspot1</a>]</sup>.</p><h4>AMFRPC</h4><p><div class="inxx">PyAMF</div> <div class="inxx">Adobe Flash</div></p><p>AMFRPC is the Remote Procedure Call protocol used by Flash clients to communicate with a server. web2py supports AMFRPC, but it requires that you run web2py from source and that you preinstall the PyAMF library. This can be installed from the Linux or Windows shell by typing:</p><pre><code class="code">easy_install pyamf</code></pre><p>(please consult the PyAMF documentation for more details).</p><p>In this subsection we assume that you are already familiar with ActionScript programming.</p><p>We will create a simple service that takes two numerical values, adds them together, and returns the sum. We will call our web2py application "pyamf_test", and we will call the service <code>addNumbers</code>.</p><p>First, using Adobe Flash (any version starting from MX 2004), create the Flash client application by starting with a new Flash FLA file. In the first frame of the file, add these lines:</p><pre><code class="code">import mx.remoting.Service;
import mx.rpc.RelayResponder;
import mx.rpc.FaultEvent;
import mx.rpc.ResultEvent;
import mx.remoting.PendingCall;

var val1 = 23;
var val2 = 86;

service = new Service(
    "http://127.0.0.1:8000/pyamf_test/default/call/amfrpc3",
    null, "mydomain", null, null);

var pc:PendingCall = service.addNumbers(val1, val2);
pc.responder = new RelayResponder(this, "onResult", "onFault");

function onResult(re:ResultEvent):Void {
    trace("Result : " + re.result);
    txt_result.text = re.result;
}

function onFault(fault:FaultEvent):Void {
    trace("Fault: " + fault.fault.faultstring);
}

stop();</code></pre><p>This code allows the Flash client to connect to a service that corresponds to a function called "addNumbers" in the file "/pyamf_test/default/gateway". You must also import ActionScript version 2 MX remoting classes to enable Remoting in Flash. Add the path to these classes to the classpath settings in the Adobe Flash IDE, or just place the "mx" folder next to the newly created file.</p><p>Notice the arguments of the Service constructor. The first argument is the URL corresponding to the service that we want will create. The third argument is the domain of the service. We choose to call this domain "mydomain".</p><p>Second, create a dynamic text field called "txt_result" and place it on the stage.</p><p>Third, you need to set up a web2py gateway that can communicate with the Flash client defined above.</p><p>Proceed by creating a new web2py app called <code>pyamf_test</code> that will host the new service and the AMF gateway for the flash client. Edit the "default.py" controller and make sure it contains</p><pre><code class="code">@service.amfrpc3('mydomain')
def addNumbers(val1, val2):
    return val1 + val2

def call(): return service()</code></pre><p>Fourth, compile and export/publish the SWF flash client as <code>pyamf_test.swf</code>, place the "pyamf_test.amf", "pyamf_test.html", "AC_RunActiveContent.js", and "crossdomain.xml" files in the "static" folder of the newly created appliance that is hosting the gateway, "pyamf_test".</p><p>You can now test the client by visiting:</p><pre><code class="code">http://127.0.0.1:8000/pyamf_test/static/pyamf_test.html</code></pre><p>The gateway is called in the background when the client connects to addNumbers.</p><p>If you are using AMF0 instead of AMF3 you can also use the decorator:</p><pre><code class="code">@service.amfrpc</code></pre><p>instead of:</p><pre><code class="code">@service.amfrpc3('mydomain')</code></pre><p>In this case you also need to change the service URL to:</p><pre><code class="code">http://127.0.0.1:8000/pyamf_test/default/call/amfrpc</code></pre><h4>SOAP</h4><div class="inxx">SOAP</div><p>web2py includes a SOAP client and server created by Mariano Reingart. It can be used very much like XML-RPC:</p><p>Consider the following code, for example, in the "default.py" controller:</p><pre><code class="code">@service.soap('MyAdd',returns={'result':int},args={'a':int,'b':int,})
def add(a,b):
    return a+b</code></pre><p>Now in a python shell you can do:</p><pre><code class="code">&gt;&gt;&gt; from gluon.contrib.pysimplesoap.client import SoapClient
&gt;&gt;&gt; client = SoapClient(wsdl="http://localhost:8000/app/default/call/soap?WSDL")
&gt;&gt;&gt; print client.MyAdd(a=1,b=2)
{'result': 3}</code></pre><p>To get proper encoding when returning a text values, specify string as u'proper utf8 text'.</p><p>You can obtain the WSDL for the service at</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/soap?WSDL</code></pre><p>And you can obtain documentation for any of the exposed methods:</p><pre><code class="code">http://127.0.0.1:8000/app/default/call/soap</code></pre><h3>Low level API and other recipes</h3><h4>simplejson</h4><p><div class="inxx">JSON</div> <div class="inxx">simplejson</div></p><p>web2py includes gluon.contrib.simplejson, developed by Bob Ippolito. This module provides the most standard Python-JSON encoder-decoder.</p><p>SimpleJSON consists of two functions:</p><ul><li><code>gluon.contrib.simplesjson.dumps(a)</code> encodes a Python object <code>a</code> into JSON.</li><li><code>gluon.contrib.simplejson.loads(b)</code> decodes the JSON data in <code>b</code> into a Python object.</li></ul><p>Object types that can be serialized include primitive types, lists, and dictionaries. Compound objects can be serialized with the exception of user defined classes.</p><p>Here is a sample action (for example in controller "default.py") that serializes the Python list containing weekdays using this low level API:</p><pre><code class="code">def weekdays():
    names=['Sunday','Monday','Tuesday','Wednesday',
           'Thursday','Friday','Saturday']
    import gluon.contrib.simplejson
    return gluon.contrib.simplejson.dumps(names)</code></pre><p>Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;script&gt;
$.getJSON('/application/default/weekdays',
          function(data){ alert(data); });
&lt;/script&gt;</code></pre><p>The code uses the jQuery function <code>$.getJSON</code>, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable <code>data</code> and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.</p><h4>PyRTF</h4><p><div class="inxx">PyRTF</div> <div class="inxx">RTF</div></p><p>Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.</p><p>web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically, including colored formatted text and pictures.</p><p>In the following example we initiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:</p><pre><code class="code">def makertf():
    import gluon.contrib.pyrtf as q
    doc=q.Document()
    section=q.Section()
    doc.Sections.append(section)
    section.append('Section Title')
    section.append('web2py is great. '*100)
    response.headers['Content-Type']='text/rtf'
    return q.dumps(doc)</code></pre><p>In the end the Document is serialized by <code>q.dumps(doc)</code>. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.</p><p>Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.</p><h4>ReportLab and PDF</h4><p><div class="inxx">ReportLab</div> <div class="inxx">PDF</div></p><p>web2py can also generate PDF documents, with an additional library called "ReportLab"<sup>[<a href="/book/default/reference/42/ReportLab" target="_blank">ReportLab</a>]</sup> .</p><p>If you are running web2py from source, it is sufficient to have ReportLab installed. If you are running the Windows binary distribution, you need to unzip ReportLab in the "web2py/" folder. If you are running the Mac binary distribution, you need to unzip ReportLab  in the folder:</p><pre><code class="code">web2py.app/Contents/Resources/</code></pre><p>From now on we assume ReportLab is installed and that web2py can find it. We will create a simple action called "get_me_a_pdf" that generates a PDF document.</p><pre><code class="code">from reportlab.platypus import *
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.rl_config import defaultPageSize
from reportlab.lib.units import inch, mm
from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
from reportlab.lib import colors
from uuid import uuid4
from cgi import escape
import os

def get_me_a_pdf():
    title = "This The Doc Title"
    heading = "First Paragraph"
    text = 'bla '* 10000

    styles = getSampleStyleSheet()
    tmpfilename=os.path.join(request.folder,'private',str(uuid4()))
    doc = SimpleDocTemplate(tmpfilename)
    story = []
    story.append(Paragraph(escape(title),styles["Title"]))
    story.append(Paragraph(escape(heading),styles["Heading2"]))
    story.append(Paragraph(escape(text),styles["Normal"]))
    story.append(Spacer(1,2*inch))
    doc.build(story)
    data = open(tmpfilename,"rb").read()
    os.unlink(tmpfilename)
    response.headers['Content-Type']='application/pdf'
    return data</code></pre><p>Notice how we generate the PDF into a unique temporary file, <code>tmpfilename</code>, we read the generated PDF from the file, then we deleted the file.</p><p>For more information about the ReportLab API, refer to the ReportLab documentation. We strongly recommend using the Platypus API of ReportLab, such as <code>Paragraph</code>, <code>Spacer</code>, etc.</p><h3>Restful Web Services</h3><div class="inxx">REST</div><p>REST stands for "REpresentational State Transfer" and it is a type of web service architecture and not, like SOAP, a protocol. In fact there is no standard for REST.</p><p>Loosely speaking REST says that a service can be thought of as a collection of resources. Each resource should be identified by a URL. There are four methods actions on a resource and they are POST (create), GET (read), PUT (update) and DELETE, from which the acronym CRUD (create-read-update-delete) stands for. A client communicates with the resource by making an HTTP request to the URL that identifies the resource and using the HTTP method POST/PUT/GET/DELETE to pass instructions to the resource. The URL may have an extension, for example <code>json</code> that specify how the protocol for encoding the data.</p><p>So for example a POST request to</p><pre><code>http://127.0.0.1/myapp/default/api/person</code></pre><p>means that you want to create a new <code>person</code>. In this case a <code>person</code> may correspond to a record in table <code>person</code> but may also be some other type of resource (for example a file).</p><p>Similarly a GET request to</p><pre><code>http://127.0.0.1/myapp/default/api/persons.json</code></pre><p>indicates a request for a list of persons (records from the data <code>person</code>) in json format.</p><p>A GET request to</p><pre><code>http://127.0.0.1/myapp/default/api/person/1.json</code></pre><p>indicates a request for the information associated to <code>person/1</code> (the record with <code>id==1</code>) and in json format.</p><p>In the case of web2py each request can be split into three parts:</p><ul><li>A first part that identify the location of the service, i.e. the action that exposes the service:</li></ul><pre><code>http://127.0.0.1/myapp/default/api/</code></pre><ul><li>The name of the resource (<code>person</code>, <code>persons</code>, <code>person/1</code>, etc.)</li><li>The communication protocol specified by the extension.</li></ul><p>Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:</p><pre><code>http://127.0.0.1/myapp/default/api/person/1.json</code></pre><p>into this:</p><pre><code>http://127.0.0.1/api/person/1.json</code></pre><p>yet this is a matter of taste and we have already discussed it at length in chapter 4.</p><p>In our example we used an action called <code>api</code> but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sake of argument we will continue to assume that our RESTful action is called <code>api</code>.</p><p>We will also assume we have defined the following two tables:</p><pre><code>db.define_table('person',Field('name'),Field('info'))
db.define_table('pet',Field('owner',db.person),Field('name'),Field('info'))</code></pre><p>and they are the resources we want to expose.</p><p>The first thing we do is create the RESTful action:</p><pre><code>def api():
    return locals()</code></pre><p>Now we modify it so that the extension is filtered out of the request args (so that <code>request.args</code> can be used to identify the resource) and so that it can handle the different methods separately:</p><pre><code>@request.restful()
def api():
    def GET(*args,**vars):
        return dict()
    def POST(*args,**vars):
        return dict()
    def PUT(*args,**vars):
        return dict()
    def DELETE(*args,**vars):
        return dict()
    return locals()</code></pre><p>Now when we make a GET http request to</p><pre><code>http://127.0.0.1:8000/myapp/default/api/person/1.json</code></pre><p>it calls and returns <code>GET('person','1')</code> where GET is the function defined inside the action. Notice that:</p><ul><li>we do not need to define all four methods, only those that we wish to expose.</li><li>the method function can take named arguments</li><li>the extension is stored in <code>request.extension</code> and the content type is set automatically.</li></ul><blockquote>The <code>@request.restful()</code> decorator makes sure that the extension in the path info is stored into <code>request.extension</code>, maps the request method into the corresponding function within the action (POST, GET, PUT, DELETE), and passes <code>request.args</code> and <code>request.vars</code> to the selected function.</blockquote><p>Now we build a service to POST and GET individual records:</p><pre><code>@request.restful()
def api():
    response.view = 'generic.json'
    def GET(tablename,id):
        if not tablename=='person': raise HTTP(400)
        return dict(person = db.person(id))
    def POST(tablename,**fields):
        if not tablename=='person': raise HTTP(400)
        return db.person.validate_and_insert(**fields)
    return locals()</code></pre><p>Notice that:</p><ul><li>the GET and POST are dealt with by different functions</li><li>the function expect the correct arguments (un-named arguments parsed by <code>request.args</code> and named arguments are from <code>request.vars</code>)</li><li>they check the input is correct and eventually raise an exception</li><li>GET perform a select and returns the record, <code>db.person(id)</code>. The output is automatically converted to JSON because the generic view is called.</li><li>POST performs a <code>validate_and_insert(..)</code> and returns the <code>id</code> of the new record or, alternatively, validation errors. The POST variables, <code>**fields</code>, are the post variables.</li></ul><h4><code>parse_as_rest</code> (experimental)</h4><p>The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.</p><p>In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.</p><div class="inxx">parse_as_rest</div><p>This is done using URL patterns. A pattern is a string that maps the request args from a URL into a database query. There 4 types of atomic patterns:</p><ul><li>String constants for example "friend"</li><li>String constant corresponding to a table. For example "friend[person]" will match "friends" in the URL to the "person" table.</li><li>Variables to be used to filter. For example "{person.id}" will apply a <code>db.person.name=={person.id}</code> filter.</li><li>Names of fields, represented by ":field"</li></ul><p>Atomic patterns can be combined into complex URL patterns using "/" such as in</p><pre><code>"/friend[person]/{person.id}/:field"</code></pre><p>which gives a url of the form</p><pre><code>http://..../friend/1/name</code></pre><p>Into a query for a person.id that returns the name of the person. Here "friend[person]" matches "friend" and filters the table "person". "{person.id}" matches "1" and filters "person.id==1". ":field" matches "name" and returns:</p><pre><code>db(db.person.id==1).select().first().name</code></pre><p>Multiple URL patters can be combined into a list so that one single RESTful action can serve different types of requests.</p><p>The DAL has a method <code>parse_as_rest(pattern,args,vars)</code> that given a list of patterns, the <code>request.args</code> and the <code>request.vars</code> matches the pattern and returns a response (GET only).</p><p>So here is a more complex example:</p><pre><code class="code">
@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(*args,**vars):
        patterns = [
            "/friends[person]",
            "/friend/{person.name.startswith}",
            "/friend/{person.name}/:field",
            "/friend/{person.name}/pets[pet.owner]",
            "/friend/{person.name}/pet[pet.owner]/{pet.name}",
            "/friend/{person.name}/pet[pet.owner]/{pet.name}/:field"
            ]
        parser = db.parse_as_rest(patterns,args,vars)
        if parser.status == 200:
            return dict(content=parser.response)
        else:
            raise HTTP(parser.status,parser.error)
    def POST(table_name,**vars):
        if table_name == 'person':
            return db.person.validate_and_insert(**vars)
        elif table_name == 'pet':
            return db.pet.validate_and_insert(**vars)
        else:
            raise HTTP(400)
    return locals()</code></pre><p>Which understands the following URLs that correspond to the listed patterns:</p><ul><li>GET all persons</li></ul><pre><code>http://.../api/friends</code></pre><ul><li>GET one person with name starting with "t"</li></ul><pre><code>http://.../api/friend/t</code></pre><ul><li>GET the "info" field value of the first person with name equal to "Tim"</li></ul><pre><code>http://.../api/friend/Tim/info</code></pre><ul><li>GET a list of pets of the person (friend) above</li></ul><pre><code>http://.../api/friend/Tim/pets</code></pre><ul><li>GET the pet with name "Snoopy of person with name "Tim"</li></ul><pre><code>http://.../api/friend/Tim/pet/Snoopy</code></pre><ul><li>GET the "info" field value for the pet</li></ul><pre><code>http://.../api/friend/Tim/pet/Snoopy/info</code></pre><p>The action also exposes two POST urls:</p><ul><li>POST a new friend</li><li>POST a new pet</li></ul><p>If you have the "curl" utility installed you can try:</p><pre><code>$ curl -d "name=Tim" http://127.0.0.1:8000/myapp/default/api/friend.json
{"errors": {}, "id": 1}
$ curl http://127.0.0.1:8000/myapp/default/api/friends.json
{"content": [{"info": null, "name": "Tim", "id": 1}]}
$ curl -d "name=Snoopy&amp;owner=1" http://127.0.0.1:8000/myapp/default/api/pet.json
{"errors": {}, "id": 1}
$ curl http://127.0.0.1:8000/myapp/default/api/friend/Tim/pet/Snoopy.json
{"content": [{"info": null, "owner": 1, "name": "Snoopy", "id": 1}]}</code></pre><p>It is possible to declare more complex queries such where a value in the URL is used to build a query not involving equality. For example</p><code>patterns = ['friends/{person.name.contains}'</code><p>maps</p><pre><code>http://..../friends/i</code></pre><p>into</p><pre><code>db.person.name.contains('i')</code></pre><p>And similarly:</p><code>patterns = ['friends/{person.name.ge}/{person.name.gt.not}'</code><p>maps</p><pre><code>http://..../friends/aa/uu</code></pre><p>into</p><pre><code>(db.person.name&gt;='aa')&amp;(~(db.person.name&gt;'uu'))</code></pre><p>valid attributes for a field in a pattern are: <code>contains</code>, <code>startswith</code>, <code>le</code>, <code>ge</code>, <code>lt</code>, <code>gt</code>, <code>eq</code> (equal, default), <code>ne</code> (not equal). Other attributes specifically for date and datetime fields are <code>day</code>, <code>month</code>, <code>year</code>, <code>hour</code>, <code>minute</code>, <code>second</code>.</p><p>Notice that this pattern syntax is not designed to be general. Not every possible query can be described via a pattern but a lot of them are. The syntax may be extended in the future.</p><p>Often you want to expose some RESTful URLs but you want to restrict the possible queries. This can be done by passing an extra argument <code>queries</code> to the <code>parse_as_rest</code> method. <code>queries</code> is a dictionary of <code>(tablename,query)</code> where query is a DAL query to restrict access to table <code>tablename</code>.</p><p>We can also order results using the order GET variables</p><pre><code>http://..../api/friends?order=name|~info</code></pre><p>which order alphabetically (<code>name</code>) and then by reversed info <code>order</code>.</p><p>We can also limit the number of records by specifying a <code>limit</code> and <code>offset</code> GET variables</p><pre><code>http://..../api/friends?offset=10&amp;limit=1000</code></pre><p>which will return up to 1000 friends (persons) and skip the first 10. <code>limit</code> defaults to 1000 and <code>offset</code> default to 0.</p><p>Let's now consider an extreme case. We want to build all possible patterns for all tables (except <code>auth_</code> tables). We want to be able to search by any text field, any integer field, any double field (by range) and any date (also by range). We also want to be able to POST into any table:</p><p>In the general case this requires a lot of patterns. Web2py makes it simple:</p><pre><code>@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(*args,**vars):
        patterns = 'auto'
        parser = db.parse_as_rest(patterns,args,vars)
        if parser.status == 200:
            return dict(content=parser.response)
        else:
            raise HTTP(parser.status,parser.error)
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()</code></pre><p>Settings <code>patterns='auto'</code> results in web2py generating all possible patterns for all non-auth tables. There is even a pattern for querying about patterns:</p><pre><code>http://..../api/patterns.json</code></pre><p>which for out <code>person</code> and <code>pet</code> tables results in:</p><pre><code>{"content": [
   "/person[person]",
   "/person/id/{person.id}",
   "/person/id/{person.id}/:field",
   "/person/id/{person.id}/pet[pet.owner]",
   "/person/id/{person.id}/pet[pet.owner]/id/{pet.id}",
   "/person/id/{person.id}/pet[pet.owner]/id/{pet.id}/:field",
   "/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}",
   "/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}/:field",
   "/person/name/pet[pet.owner]",
   "/person/name/pet[pet.owner]/id/{pet.id}",
   "/person/name/pet[pet.owner]/id/{pet.id}/:field",
   "/person/name/pet[pet.owner]/owner/{pet.owner}",
   "/person/name/pet[pet.owner]/owner/{pet.owner}/:field",
   "/person/info/pet[pet.owner]",
   "/person/info/pet[pet.owner]/id/{pet.id}",
   "/person/info/pet[pet.owner]/id/{pet.id}/:field",
   "/person/info/pet[pet.owner]/owner/{pet.owner}",
   "/person/info/pet[pet.owner]/owner/{pet.owner}/:field",
   "/pet[pet]",
   "/pet/id/{pet.id}",
   "/pet/id/{pet.id}/:field",
   "/pet/owner/{pet.owner}",
   "/pet/owner/{pet.owner}/:field"
]}</code></pre><p>You can specify auto patterns for some tables only:</p><pre><code>patterns = [':auto[person]',':auto[pet]']</code></pre><h4><code>smart_query</code> (experimental)</h4><div class="inxx">smart_query</div><p>There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like</p><pre><code>http://.../api.json?search=person.name starts with 'T' and person.name contains 'm'</code></pre><p>You can do this using</p><pre><code>@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(search):
        try:
            rows = db.smart_query([db.person,db.pet],search).select()
            return dict(result=rows)
        except RuntimeError:
            raise HTTP(400,"Invalid search string")
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()</code></pre><p>The method <code>db.smart_query</code> takes two arguments:</p><ul><li>a list of field or table that should be allowed in the query</li><li>a string containing the query expressed in natural language</li></ul><p>and it returns a <code>db.set</code> object with the records that have been found.</p><p>Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.</p><h4>Access Control</h4><p>Access to the API can be restricted as usual by using decorators. So, for example</p><pre><code>auth.settings.allow_basic_login = True

@auth.requires_login()
@request.restful()
def api():
   def GET(s):
       return 'access granted, you said %s' % s
   return locals()</code></pre><p>can now be accessed with</p><pre><code>$ curl --user name:password http://127.0.0.1:8000/myapp/default/api/hello
access granted, you said hello</code></pre><h3>Services and Authentication</h3><div class="inxx">Authentication</div><p>In the previous chapter we have discussed the use of the following decorators:</p><pre><code class="code">@auth.requires_login()
@auth.requires_membership(...)
@auth.requires_permission(...)</code></pre><p>For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.</p><p>For functions defined as services and decorated using the <code>@service...</code> decorators, the <code>@auth...</code> decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the <code>call</code> actions that needs to be decorated:</p><pre><code class="code">@auth.requires_login()
def call(): return service()</code></pre><p>Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:</p><pre><code class="code">public_service=Service()
private_service=Service()

@public_service.jsonrpc
@private_service.jsonrpc
def f(): return 'public'

@private_service.jsonrpc
def g(): return 'private'

def public_call(): return public_service()

@auth.requires_login()
def private_call(): return private_service()</code></pre><p>This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using <a href="../09/#markmin_basic_authentication">basic authentication</a>, as discussed in the previous chapter). The client must support it; not all clients do.</p><p>If using ServerProxy() described above, you can pass basic authentication credentials in the URL, like so:</p><pre><code class="code">URL='http://user:password@127.0.0.1:8000/app/default/private_call/jsonrpc2'
service = ServerProxy(URL, version='2.0')</code></pre><p>where the function <code>private_call</code> in the controller is decorated for user authentication</p>