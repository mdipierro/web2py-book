<h2>Język programowania Python</h2><div class="inxx">Python</div><h3>O Pythonie</h3><div class="inxx">API</div><p>Python jest językiem programowania wysokiego poziomu o ogólnym przeznaczeniu. Filozofia jego zaprojektowania kladzie nacisk na produktywność programisty i czytelność kodu. Ma minimalistyczną składnię rdzenia z niewielu podstawowymi poleceniami i prostą semantyką, ale ma także wielkie i wszechstronne standardowe biblioteki, w tym interfejs programowania aplikacyjnego (Application Programming Interface - API) z wieloma podstawowymi funkcjami systemów operacyjnych (OS). Kod Pythona, z racji minimalizmu, definiuje wbudowane obiekty, takie jak listy (<code>list</code>), krotki (<code>tuple</code>), słowniki (<code>dict</code>) i dowolnie długie liczby (<code>long</code>).</p><p>Python obsługuje wiele paradygmatów programowania, w tym programowanie zorientowane obiektowo (<code>class</code>), programowanie proceduralne (<code>def</code>) i programowanie funkcjonalne (<code>lambda</code>). Python ma dynamiczny system typów i automatyczne zarządzanie pamięcią za pomocą zliczania referencji (podobnie jak Perl, Ruby i Scheme).</p><p>Python został wydany przez Guido van Rossuma w 1991 r. Język ma otwarty, społecznościowy model twórczy zarządzany przez organizację non-profit Python Software Foundation. Istnieje wiele interpreterów i kompilatorów języka programowania Python, w tym w Java (Jython), ale w tym przeglądzie odnosimy się do referencji implementacji języka C, stworzonego przez Guido.</p><p>Na oficjalnej stronie Pythona<sup>[<a href="/book/default/reference/42/python" target="_blank">python</a>]</sup> można znaleźć wiele poradników, oficjalną dokumentację oraz informatory bibliotek.</p><p>Dodatkowe informacje o Pythonie można znaleźć polecanej przez nas książce ref.<sup>[<a href="/book/default/reference/42/guido" target="_blank">guido</a>]</sup>  i ref.<sup>[<a href="/book/default/reference/42/lutz" target="_blank">lutz</a>]</sup>.</p><p>Można pominąć ten rozdział, jeśli jest się zaznajomionym z językiem Python.</p><h3>Rozpoczynamy</h3><div class="inxx">shell</div><p>Binarne dystrybucje web2py dla Microsoft Windows lub Apple OS X zawierają wbudowany w sam plik dystrybucji interpreter Pythona.</p><p>Można go uruchomić na Windows za pomoca następującego polecenia (wpisz w wierszu poleceń DOSa):</p><pre><code class="code">web2py.exe -S welcome</code></pre><p>Na Apple OS X wprowadź następujące polecenie w oknie terminala (będąc w tym samym katalogu co web2py.app):</p><pre><code class="code">./web2py.app/Contents/MacOS/web2py -S welcome</code></pre><p>Na Linuksie lub innym systemie uniksopodobnym są szanse, że masz już zainstalowanego Pythona. Jeśli tak, wprowadź w powłoce polecenie:</p><pre><code class="code">python web2py.py -S welcome</code></pre><p>Jeśli nie masz jeszcze zainstalowanego Pythona 2.5 (lub nowszej wersji 2.x), trzeba będzie pobrać i zainstalować go przed uruchomieniem web2py.</p><p>Opcja <code>-S welcome</code> polecenia instruuje web2py aby uruchomił interaktywną powłokę, tak jakby polecenie było wykonane w kontrolerze dla aplikacji <strong>welcome</strong> - szkieletowej aplikacji web2py. Daje ona możliwość dostępu do prawie wszystkie klas, obiektów i funkcji web2py. Jest to jedyna różnica pomiędzy interaktywną linią poleceń web2py a zwykłą linią poleceń Pythona.</p><p>Interfejs administracyjny zapewnia również powłokę internetową dla każdej aplikacji. Możesz uzyskać dostęp do jeden z nich tak jak do aplikacji "welcome".</p><pre><code class="code">http://127.0.0.1:8000/admin/shell/index/welcome</code></pre><p>Wypróbuj wszystkie przykłady w tym rozdziale wykorzystując zwykłą powłokę lub powłokę internetową.</p><h3>help, dir</h3><p><div class="inxx">help</div> <div class="inxx">dir</div></p><p>Język Python dostarcza dwa polecenia umożliwiające uzyskanie informacji o zdefiniowanych obiektach w bieżącym zakresie, zarówno tych wbudowanych jak i zdefiniowanych przez użytkowników.</p><p>Możemy wykorzystać polecenie <code>help</code> dla uzyskania informacji o obiekcie dla przykładu "1":</p><pre><code class="code">&gt;&gt;&gt; help(1)
Help on int object:

class int(object)
 |  int(x[, base]) -&gt; integer
 |
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string. If the argument is outside the integer range a long object
 |  will be returned instead.
 |
 |  Methods defined here:
 |
 |  __abs__(...)
 |      x.__abs__() &lt;==&gt; abs(x)
...</code></pre><p>a, ponieważ "1" jest liczbą, mamy opis o klasie <code>int</code> i wykazane wszystkie jego metody. Tutaj dane wyjściowe zostały obcięte, ponieważ wyjście jest badzo długie i szczegółowe.</p><p>Podobnie można uzyskać listę metod obiektu "1" przez polecenie <code>dir</code>:</p><pre><code class="code">&gt;&gt;&gt; dir(1)
['__abs__', ..., '__xor__']</code></pre><h3>Typy</h3><div class="inxx">type</div><p>Python jest językiem o dynamicznym systemem typów, co oznacza że zmienne nie mają typu i nie muszą być deklarowane. Z drugiej strony, wartości mają typ. Można wypytać zmienną o typ wartości jaką zawiera:</p><pre><code class="code">&gt;&gt;&gt; a = 3
&gt;&gt;&gt; print type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = 3.14
&gt;&gt;&gt; print type(a)
&lt;type 'float'&gt;
&gt;&gt;&gt; a = 'hello python'
&gt;&gt;&gt; print type(a)
&lt;type 'str'&gt;</code></pre><p>Python zawiera również struktury danych takie jak listy i słowniki.</p><h4>Ciąg znakowy</h4><p><div class="inxx">ciag znakowy</div> <div class="inxx">ciąg znakowy</div> <div class="inxx">str</div> <div class="inxx">ASCII</div> <div class="inxx">UTF8</div> <div class="inxx">Unicode</div> <div class="inxx">encode</div></p><blockquote>W tym podręczniku pojęcia <em>ciąg znakowy</em>, <em>łańcuch znakowy</em> i <em>łańcuch tekstowy</em>
oznaczaja ten sam typ zmiennej <code>string</code> i używane są zamiennie.</blockquote><p>Python (2.x) obsługuje stosowanie dwóch różnych typów ciągów znakowych: ciągi znaków ASCII i ciągi znaków Unicode. Ciągi znaków ASCII są ujmowane w znaki cudzysłowów: '...', "..." albo w ograniczniki '<em>..</em>' lub """...""". Potrójne cudzysłowy ograniczają ciągi złożone. Ciąg znaków Unicode rozpoczyna się przedrostkiem <code>u</code> po którym następuje ciąg zawierający znaki Unicode. Ciągi znaków Unicode mogą być konwertowane do ciagów znaków ASCII przez użycie metody <code>encode</code>, na przykład:</p><pre><code class="code">&gt;&gt;&gt; a = 'this is an ASCII string'
&gt;&gt;&gt; b = u'This is a Unicode string'
&gt;&gt;&gt; a = b.encode('utf8')</code></pre><p>Po wykonaniu tych trzech poleceń wynikową wartością <code>a</code> jest ciąg zawierający zakodowane znaki UTF8. Zgodnie z założeniami web2py używa wewnętrznie kodowanych ciągów znaków UTF8.</p><p>Jest też możliwe dodawanie zmiennych do ciągów w różny sposób:</p><pre><code class="code">&gt;&gt;&gt; print 'number is ' + str(3)
number is 3
&gt;&gt;&gt; print 'number is %s' % (3)
number is 3
&gt;&gt;&gt; print 'number is %(number)s' % dict(number=3)
number is 3</code></pre><p>Ostatnia notacja jest bardziej wyrazista i jest mniej podatna na błędy, dlatego jest zalecana.</p><p>Wiele obiektów Pythona, na przykład liczby, mogą być serializowane do ciągów znakowych przy użyciu <code>str</code> lub <code>repr</code>. Te dwa polecenia są bardzo podobne ale dają trochę odmienne dane wyjściowe. Na przykład:</p><pre><code class="code">&gt;&gt;&gt; for i in [3, 'hello']:
        print str(i), repr(i)
3 3
hello 'hello'</code></pre><p>Dla klas zdefiniowanych przez użytkownika <code>str</code> i <code>repr</code> mogą być definiowane i redefiniowane przy użyciu specjalnych operatorów <code>__str__</code> i <code>__repr__</code>. Są one krótko opisane dalej, bo szczegóły można znaleźć w oficjalnej dokumentacji Pythona<sup>[<a href="/book/default/reference/42/pydocs" target="_blank">pydocs</a>]</sup> . <code>repr</code> ma zawsze wartość domyślną.</p><p>Inna ważna cechą ciągów znakowych Pythona jest to, że podobnie jak listy są iterowalnymi obiektami.</p><pre><code class="code">&gt;&gt;&gt; for i in 'hello':
        print i
h
e
l
l
o</code></pre><h4>Lista</h4><div class="inxx">lista</div><p>W Pythonie główne metody klasy <code>list</code> to <code>append</code>, <code>insert</code> i <code>delete</code>:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; print type(a)
&lt;type 'list'&gt;
&gt;&gt;&gt; a.append(8)
&gt;&gt;&gt; a.insert(2, 7)
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; print a
[2, 7, 3, 8]
&gt;&gt;&gt; print len(a)
4</code></pre><p>Listy moga być dzielone:</p><pre><code class="code">&gt;&gt;&gt; print a[:3]
[2, 7, 3]
&gt;&gt;&gt; print a[1:]
[7, 3, 8]
&gt;&gt;&gt; print a[-2:]
[3, 8]</code></pre><p>i łączone:</p><pre><code class="code">&gt;&gt;&gt; a = [2, 3]
&gt;&gt;&gt; b = [5, 6]
&gt;&gt;&gt; print a + b
[2, 3, 5, 6]</code></pre><p>Lista jest iterowalna – można wyszukiwać w niej elementy stosując pętlę:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; for i in a:
        print i
1
2
3</code></pre><p>Elementami listy nie muszą być tego samego typu – mogą być nimi dowolne obiekty Pythona.</p><p>Istnieje bardzo częsta sytuacja, w której można użyć <em>listy składanej</em>. Rozważmy następujący kod:</p><pre><code class="code">&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for x in a:
        if x % 2 == 0:
            b.append(x * 3)
&gt;&gt;&gt; b
[6, 12]</code></pre><p>Kod ten jasno przetwarza elementy listy , wybierając i modyfikując podzbiór wejściowy listy i tworząc nowa listę wynikową. Kod ten może być wyrażony krócej z użyciem listy składanej (<em>ang. list comprehension</em>). pojęciem listy:</p><pre><code class="code">&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; b = [x * 3 for x in a if x % 2 == 0]
&gt;&gt;&gt; b
[6, 12]</code></pre><p>Listę <code>b</code> jest <em>listą składaną</em>.</p><h4>Krotka</h4><div class="inxx">krotka</div><p>Krotka jest podobna do listy, ale jej wielkość i elementy są niezmienne, podczas gdy w listy są modyfikowalne. Jeśli element krotki jest jest obiektem, to atrybuty obiektu są modyfikowalne. Krotki ogranicza się nawiasami okrągłymi.</p><pre><code class="code">&gt;&gt;&gt; a = (1, 2, 3)</code></pre><p>Więc choć krotka działa podobnie do listy:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; a[1] = 5
&gt;&gt;&gt; print a
[1, 5, 3]</code></pre><p>to przypisysywanie elementów nie działa w krotce:</p><pre><code class="code">&gt;&gt;&gt; a = (1, 2, 3)
&gt;&gt;&gt; print a[1]
2
&gt;&gt;&gt; a[1] = 5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment</code></pre><p>Krotka, podobnie jak lista, jest iterowalna. Proszę zauważyć, że krotka z jednym elementem musi zawierać końcowy przecinek, tak jak pokazano to niżej:</p><pre><code class="code">&gt;&gt;&gt; a = (1)
&gt;&gt;&gt; print type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = (1,)
&gt;&gt;&gt; print type(a)
&lt;type 'tuple'&gt;</code></pre><p>Krotki są bardzo przydatne dla efektywnego wypakowania obiektów do odrębnych zmiennych, gdyż są niezmienne i też dlatego, że nawiasy są często opcjonalne:</p><pre><code class="code">&gt;&gt;&gt; a = 2, 3, 'hello'
&gt;&gt;&gt; x, y, z = a
&gt;&gt;&gt; print x
2
&gt;&gt;&gt; print z
hello</code></pre><h4>Słownik</h4><div class="inxx">słownik</div><p>Słownik Pythona jest tablicą asocjacyjną, która odwzorowuje obiekty klucze na obiekty wartości. Na przykład:</p><pre><code class="code">&gt;&gt;&gt; a = {'k':'v', 'k2':3}
&gt;&gt;&gt; a['k']
v
&gt;&gt;&gt; a['k2']
3
&gt;&gt;&gt; a.has_key('k')
True
&gt;&gt;&gt; a.has_key('v')
False</code></pre><p>Kluczami mogą być dowolne niemodyfikowalne obiekty (int, string, tuple lub każdy obiekt, którego klasa implementuje metodę <code>__hash__</code>). Wartościami mogą być obiekty dowolnego typu. Różne klucze i wartości w tym samym słowniku nie muszą być tego samego typu. Jeśli klucze są znakami alfanumerycznymi, to słownik może być zadeklarowany w alternatywnej składni:</p><pre><code class="code">&gt;&gt;&gt; a = dict(k='v', h2=3)
&gt;&gt;&gt; a['k']
v
&gt;&gt;&gt; print a
{'k':'v', 'h2':3}</code></pre><p>Użytecznymi metodami są <code>has_key</code>, <code>keys</code>, <code>values</code> i <code>items</code>:</p><pre><code class="code">&gt;&gt;&gt; a = dict(k='v', k2=3)
&gt;&gt;&gt; print a.keys()
['k', 'k2']
&gt;&gt;&gt; print a.values()
['v', 3]
&gt;&gt;&gt; print a.items()
[('k', 'v'), ('k2', 3)]</code></pre><p>Metoda <code>items</code> tworzy listę krotek, każda zawiera klucz i związaną z nim wartość.</p><p>Elementy słownika i elementy listy można usunąć za pomocą polecenia <code>del</code>:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; print a
[1, 3]
&gt;&gt;&gt; a = dict(k='v', h2=3)
&gt;&gt;&gt; del a['h2']
&gt;&gt;&gt; print a
{'k':'v'}</code></pre><p>Wewnętrznie Python wykorzystuje operator <code>hash</code> do konwersji obiektów na liczby całkowite i używa takiej liczby do określenia gdzie przechowywać daną wartość.</p><pre><code class="code">&gt;&gt;&gt; hash("hello world")
-1500746465</code></pre><h3>O wcięciach</h3><p>W Pythonie do rozdzielenia bloków kodu używa się wcięć. Blok rozpoczyna się od linii kończącej się w dwukropkiem i jest kontynuowany przez wszystkie linie mające takie same lub większe wcięcie w następnej linii. Na przykład:</p><pre><code class="code">&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; 3:
&gt;&gt;&gt;    print i
&gt;&gt;&gt;    i = i + 1
&gt;&gt;&gt;
0
1
2</code></pre><p>Powszechnie stosuje się cztery spacje dla każdego wcięcia. Dobrą zasada jest nie mieszanie tabulatorów ze spacjami, bo prowadzi to do (niewidzialnych) błędów.</p><h3>Instrukcja <code>for...in</code></h3><div class="inxx">for</div><p>W Pythonie można iterować iterowalne obiekty w pętli:</p><pre><code class="code">&gt;&gt;&gt; a = [0, 1, 'hello', 'python']
&gt;&gt;&gt; for i in a:
        print i
0
1
hello
python</code></pre><p>Jednym z popularnych skrótów generujących zakres iteratora bez zapisywania całych list elementów jest <code>xrange</code>.</p><pre><code class="code">&gt;&gt;&gt; for i in xrange(0, 4):
        print i
0
1
2
3</code></pre><p>Jest to równoważnik składni C/C++/C#/Java:</p><pre><code class="code">for(int i=0; i&lt;4; i=i+1) { print(i); }</code></pre><p>Innym użytecznym poleceniem jest <code>enumerate</code>, które zlicza pętle:</p><pre><code class="code">&gt;&gt;&gt; a = [0, 1, 'hello', 'python']
&gt;&gt;&gt; for i, j in enumerate(a):
        print i, j
0 0
1 1
2 hello
3 python</code></pre><p>Istnieje również słowo kluczowe <code>range(a, b, c)</code>, które zwraca listę liczb, począwszy od wartości <code>a</code>, powiększanych w każdym kroku o <code>c</code> i kończąc na liczbie mniejszej od <code>b</code>,  domyślnie <code>a</code> ma wartość 0 a <code>c</code> wartość 1. Polecenie <code>xrange</code> jest podobne, ale faktycznie nie generuje lity, tylko iteruje po liście, więc lepsze jest przy iteracji.</p><p>Można też wyjść z pętli używając polecenia <code>break</code></p><pre><code class="code">&gt;&gt;&gt; for i in [1, 2, 3]:
         print i
         break
1</code></pre><p>Można przejść do następnej iteracji pętli  bez wykonywania całego bloku kodu stosując polecenie <code>continue</code></p><pre><code class="code">&gt;&gt;&gt; for i in [1, 2, 3]:
         print i
         continue
         print 'test'
1
2
3</code></pre><h3>Polecenie <code>while</code></h3><div class="inxx">while</div><p>Pętla <code>while</code> w Pythonie działa podobnie jak ma to miejsce w innych językach programowania, poprzez zapętlanie nieskończona ilość razy i badanie warunku przed każdą iteracja. Jeśli warunek ma wartość <code>False</code>, pętla kończy się.</p><pre><code class="code">&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; 10:
        i = i + 1
&gt;&gt;&gt; print i
10</code></pre><p>W Pythonie nie ma konstrukcji <code>loop...until</code>.</p><h3>Instrukcja <code>if...elif...else</code></h3><p><div class="inxx">if</div> <div class="inxx">elif</div> <div class="inxx">else</div> Korzystanie z instrukcji warunkowej w Pythonie jest intuicyjne:</p><pre><code class="code">&gt;&gt;&gt; for i in range(3):
&gt;&gt;&gt;     if i == 0:
&gt;&gt;&gt;         print 'zero'
&gt;&gt;&gt;     elif i == 1:
&gt;&gt;&gt;         print 'one'
&gt;&gt;&gt;     else:
&gt;&gt;&gt;         print 'other'
zero
one
other</code></pre><p>Słowo "elif" oznacza "else if". Zarówno <code>elif</code> jak <code>else</code> sa klauzulami opcjonalnymi. Wyrażeń <code>elif</code> może być wiele ale tylko jedno <code>else</code>. Przy użyciu operatorów <code>not</code>, <code>and</code> i <code>or</code> można tworzyć skomplikowane warunki.</p><pre><code class="code">&gt;&gt;&gt; for i in range(3):
&gt;&gt;&gt;     if i == 0 or (i == 1 and i + 1 == 2):
&gt;&gt;&gt;         print '0 or 1'</code></pre><h3>Instrukcja <code>try...except...else...finally</code></h3><p><div class="inxx">try</div> <div class="inxx">except</div> <div class="inxx">finally</div> <div class="inxx">Exception</div> W Pythonie można zrzucać i zgłaszać wyjątki:</p><pre><code class="code">&gt;&gt;&gt; try:
&gt;&gt;&gt;     a = 1 / 0
&gt;&gt;&gt; except Exception, e:
&gt;&gt;&gt;     print 'oops: %s' % e
&gt;&gt;&gt; else:
&gt;&gt;&gt;     print 'no problem here'
&gt;&gt;&gt; finally:
&gt;&gt;&gt;     print 'done'
oops: integer division or modulo by zero
done</code></pre><p>Jeśli wystąpi wyjątek, to wykonywana jest klauzula <code>except</code> obsługująca ten wyjatek, a klauzula <code>else</code> jest wówczas pomijana. Jeśli nie wystąpi wyjątek, to klauzula <code>except</code> jest pomijana, ale wykonywana jest klauzula <code>else</code>. Klauzula <code>finally</code> jest wykonywana zawsze.</p><p>Może być wiele klauzul <code>except</code> dla różnych możliwych wyjątków:</p><pre><code class="code">&gt;&gt;&gt; try:
&gt;&gt;&gt;     raise SyntaxError
&gt;&gt;&gt; except ValueError:
&gt;&gt;&gt;     print 'value error'
&gt;&gt;&gt; except SyntaxError:
&gt;&gt;&gt;     print 'syntax error'
syntax error</code></pre><p>Klauzule <code>else</code> i <code>finally</code> są opcjonalne.</p><p>oto lista wyjatków wbudowanych w Pythonie + HTTP (zdefiniowanych w web2py)</p><pre><code class="code">BaseException
 +-- HTTP (defined by web2py)
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- Exception
      +-- GeneratorExit
      +-- StopIteration
      +-- StandardError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |    |    +-- UnicodeError
      |    |         +-- UnicodeDecodeError
      |    |         +-- UnicodeEncodeError
      |    |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning</code></pre><p>Szczegółowy opis każdego z nich można znaleźć w oficjalnej dokumentacji Pythona.</p><p>Platforma web2py dodaje tylko jeden nowy wyjątek, o nazwie <code>HTTP</code>. Gdy wyjątek ten wystąpi, spowoduje to powrót programu do strony błędu HTTP (więcej na ten temat znajduje się w rozdziale 4).</p><p>Jako wyjątek może być zgłoszony każdy obiekt, ale dobrą praktyka jest zgłaszanie obiektów, które rozszerzają jedna z wbudowanych klas wyjątku.</p><h3>Instrukcja <code>def...return</code></h3><p><div class="inxx">def</div> <div class="inxx">return</div></p><p>Funkcje deklarowane są za pomocą słowa <code>def</code>.  Oto typowa funkcja Pythona:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; print f(4, 2)
6</code></pre><p>Nie ma potrzeby (i sposobu) określania typu argumentów i typu danych wyjściowych. W tym przykładzie funkcja <code>f</code> jest zdefiniowana z dwoma argumentami.</p><p>Funkcje są pierwszym elementem składni, opisywanym w tym rozdziale, w którym wprowadza się pojęcie <em>zakresu</em> lub <em>przestrzeni nazw</em>. W powyższym przykładzie identyfikatory <code>a</code> i <code>b</code> sa zdefiniowane w zakresie funkcji <code>f</code>:</p><pre><code class="code">&gt;&gt;&gt; def f(a):
        return a + 1
&gt;&gt;&gt; print f(1)
2
&gt;&gt;&gt; print a
Traceback (most recent call last):
  File "&lt;pyshell#22&gt;", line 1, in &lt;module&gt;
    print a
NameError: name 'a' is not defined</code></pre><p>Identyfikatory zdefiniowane poza zakresem funkcji są dostępne w funkcji – proszę zwrócić uwagę jak identyfikator <code>a</code> jest obsługiwany w następującym kodzie:</p><pre><code class="code">&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f(b):
        return a + b
&gt;&gt;&gt; print f(1)
2
&gt;&gt;&gt; a = 2
&gt;&gt;&gt; print f(1) # new value of a is used
3
&gt;&gt;&gt; a = 1 # reset a
&gt;&gt;&gt; def g(b):
        a = 2 # creates a new local a
        return a + b
&gt;&gt;&gt; print g(2)
4
&gt;&gt;&gt; print a # global a is unchanged
1</code></pre><p>Jeśli <code>a</code> zostaje zmodyfikowane, to kolejne wywołania funkcji będą używać nową wartość globalną <code>a</code>, ponieważ definicja funkcji wiąże przechowywaną wartość lokalną identyfikatora <code>a</code>, nie wartość <code>a</code>, która została określona w czasie definiowania funkcji. Jednak jeśli <code>a</code> jest przypisane wewnątrz funkcji <code>g</code>, to wartość globalna <code>a</code> pozostaje bez zmian, ponieważ nowa wartość lokalna <code>a</code> przesłania wartość globalną.  Odniesienia zakresu zewnętrznego mogą być wykorzystane przy tworzeniu <em>domknięć</em>:</p><pre><code class="code">&gt;&gt;&gt; def f(x):
        def g(y):
            return x * y
        return g
&gt;&gt;&gt; doubler = f(2) # doubler is a new function
&gt;&gt;&gt; tripler = f(3) # tripler is a new function
&gt;&gt;&gt; quadrupler = f(4) # quadrupler is a new function
&gt;&gt;&gt; print doubler(5)
10
&gt;&gt;&gt; print tripler(5)
15
&gt;&gt;&gt; print quadrupler(5)
20</code></pre><p>Funkcja <code>f</code> tworzy nową funkcję. Proszę zauważyć, że zakres funkcji <code>g</code> jest całkowicie zawarty w funkcji <code>f</code>. Domknięcia są bardzo mocne.</p><p>Argumenty funkcji mogą mieć wartości domyślne a funkcje mogą zwracać wiele wyników:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b=2):
        return a + b, a - b
&gt;&gt;&gt; x, y = f(5)
&gt;&gt;&gt; print x
7
&gt;&gt;&gt; print y
3</code></pre><p>Argumenty funkcji mogą być przekazywane przez nazwę, co oznacza, że kolejność argumentów określonych w wywołaniu może być inna niż kolejność argumentów w definicji funkcji:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b=2):
        return a + b, a - b
&gt;&gt;&gt; x, y = f(b=5, a=2)
&gt;&gt;&gt; print x
7
&gt;&gt;&gt; print y
-3</code></pre><p>Funkcje mogą również pobierać w czasie wykonania zmienną liczbę argumentów:</p><pre><code class="code">&gt;&gt;&gt; def f(*a, **b):
        return a, b
&gt;&gt;&gt; x, y = f(3, 'hello', c=4, test='world')
&gt;&gt;&gt; print x
(3, 'hello')
&gt;&gt;&gt; print y
{'c':4, 'test':'world'}</code></pre><p>Tutaj argumenty nie przekazane przez nazwę (3, 'hello') są przechowywane w krotce <code>a</code>, a argumenty przekazane przez nazwę (<code>c</code> i <code>test</code>) są przechowywane w słowniku <code>b</code>.</p><p>W przeciwnym razie lista lub krotka moze być przekazywana do funkcji, która wymaga indywidualnego pozycjonowania argumentów przez ich wypakowanie:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; c = (1, 2)
&gt;&gt;&gt; print f(*c)
3</code></pre><p>a słownik może być wypakowany w celu dostarczenia argumentów w ostaci słów kluczowych:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; c = {'a':1, 'b':2}
&gt;&gt;&gt; print f(**c)
3</code></pre><h4>Wyrażenie <code>lambda</code></h4><div class="inxx">lambda</div><p>Wyrażenie <code>lambda</code> dostarcza sposób na tworzenie bardzo krótkich funkcji nienazwanych w bardzo prosty sposób:</p><pre><code class="code">&gt;&gt;&gt; a = lambda b: b + 2
&gt;&gt;&gt; print a(3)
5</code></pre><p>Wyrażenie "<code>lambda</code> [a]:[b]" czyta się dosłownie jako "funkcja z argumentami [a] zwracająca [b]". Same wyrażenie <code>lambda</code> jest nienazwane, ale funkcje przejmuje nazwę przez przypisanie do identyfikatora <code>a</code>.  Zasady zasięgu dla <code>def</code> mają zastosowanie do równoważnika <code>lambda</code> i w rzeczywistości powyższy kod, w odniesieniu do <code>a</code>, jest identyczny z funkcją zadeklarowaną przy użyciu <code>def</code>:</p><pre><code class="code">&gt;&gt;&gt; def a(b):
        return b + 2
&gt;&gt;&gt; print a(3)
5</code></pre><p>Jedyna korzyścią z używania wyrażenia <code>lambda</code> jest zwięzłość, ale zwięzłość jest bardzo wygodna w niektórych sytuacjach. Rozważmy funkcję o nazwie <code>map</code>, która stosuje funkcję do wszystkich elementów w liście, tworząc nową listę:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 7, 2, 5, 4, 8]
&gt;&gt;&gt; map(lambda x: x + 2, a)
[3, 9, 4, 7, 6, 10]</code></pre><p>Kod ten byłby dwukrotnie większy w przypadku zastosowania instrukcji <code>def</code> zamiast <code>lambda</code>. Główną wadą wyrażenia <code>lambda</code>, jest to że składania (w implementacji Pythona) pozwala tylko na pojedyncze wyrażenia. Dla dłuższych funkcji trzeba użyć instrukcji <code>def</code> a dodatkowy nakład powodowany przez funkcję nazwaną zmniejszany jest wraz ze wzrostem długości funkcji. Podobnie do <code>def</code>, wyrażenie <code>lambda</code> można stosować do funkcji <em>curry</em>: nowa funkcja może być użyta przez opakowanie istniejącej funkcji, tak że nowa funkcja posiada inny zestaw argumentów:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b): return a + b
&gt;&gt;&gt; g = lambda a: f(a, 3)
&gt;&gt;&gt; g(2)
5</code></pre><p>Istnieje wiele sytuacji w których przydatna jest funkcja curry, ale jedna z nich dotyczy bezpośrednio web2py: buforowanie. Załóżmy, że masz kosztowną funkcje, która sprawdza, czy jej argument jest liczbą pierwszą:</p><pre><code class="code">def isprime(number):
    for p in range(2, number):
        if (number % p) == 0:
            return False
    return True</code></pre><p>Funkcja ta jest oczywiście czasochłonna.</p><p>Załóżmy, że masz funkcje buforująca <code>cache.ram</code>, która pobiera trzy argumenty: klucz, funkcję i ilość sekund.</p><pre><code class="code">value = cache.ram('key', f, 60)</code></pre><p>Przy pierwszym wywołaniu , wywołuje funkcję <code>f()</code>, zapisuje wyjście w słowniku w pamięci (powiedzmy "d") i zwraca go tak, że jej wartość to:</p><pre><code class="code">value = d['key']=f()</code></pre><p>Przy drugim wywołaniu, jeśli klucz jest w słowniku i nie jest starszy niż liczba określonych sekund (60), to zwraca odpowiednią wartość bez wykonywania wywołania funkcji.</p><pre><code class="code">value = d['key']</code></pre><p>Jak buforować wyjście funkcji <strong>isprime</strong> dla dowolnego wejścia? Właśnie tak:</p><pre><code class="code">&gt;&gt;&gt; number = 7
&gt;&gt;&gt; seconds = 60
&gt;&gt;&gt; print cache.ram(str(number), lambda: isprime(number), seconds)
True
&gt;&gt;&gt; print cache.ram(str(number), lambda: isprime(number), seconds)
True</code></pre><p>Wyjście jest zawsze takie samo, ale za pierwszym razem wywoływane są funkcje <code>cache.ram</code> i <code>isprime</code>, za drugim razem tak nie jest.</p><blockquote>Funkcje Pythona, tworzone z użyciem instrukcji <code>def</code> lub wyrażenia <code>lambda</code>
umożliwiają ponowne fabrykowanie istniejących funkcji z innym zestawem argumentów.
Funkcje <code>cache.ram</code> i <code>cache.disk</code> są funkcjami buforującymi web2py.</blockquote><h3>Instrukcja <code>class</code></h3><div class="inxx">class</div><p>Ponieważ Python jest językiem o typach dynamicznych, klasy i obiekty Pythona mogą wydawać się dziwne. W rzeczywistości nie ma potrzeby definiowania zmiennych składowych (atrybutów) podczas deklarowania klas a różne instancje tej samej klasy mogą mieć różne atrybuty. Atrybuty są na ogół związane z instancją, a nie z klasa (z wyjątkiem gdy deklarowane są jako "atrybuty klasy", które są takie same jak "statyczne zmienne składowe" w C++/Java).</p><p>Oto przykład:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object): pass
&gt;&gt;&gt; myinstance = MyClass()
&gt;&gt;&gt; myinstance.myvariable = 3
&gt;&gt;&gt; print myinstance.myvariable
3</code></pre><p>Proszę zauważyć, ze polecenie <code>pass</code> jest poleceniem pustym (nic nie robiącym). W tym przypadku jest zastosowane do zdefiniowania klasy <code>MyClass</code>, która nic nie zawiera. <code>MyClass()</code> wywołuje konstruktora klasy (w tym przypadku domyślny konstruktor) i zwraca obiekt, instancje klasy. Wyrażenie <code>(object)</code> w definicji klasy wskazuje, że nasza klasa rozszerza wbudowaną klasę <code>object</code>. Nie jest to wymagane, ale jest dobrą praktyka.</p><p>Oto bardziej skomplikowany przykład:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object):
&gt;&gt;&gt;    z = 2
&gt;&gt;&gt;    def __init__(self, a, b):
&gt;&gt;&gt;        self.x = a
&gt;&gt;&gt;        self.y = b
&gt;&gt;&gt;    def add(self):
&gt;&gt;&gt;        return self.x + self.y + self.z
&gt;&gt;&gt; myinstance = MyClass(3, 4)
&gt;&gt;&gt; print myinstance.add()
9</code></pre><p>Funkcje zadeklarowane wewnątrz klasy są metodami. Niektóre metody maja specjalne, zarezerwowane nazwy. Na przykład, <code>__init__</code> jest konstruktorem. Wszystkie zmienne są zmiennymi lokalnymi metody, z wyjątkiem metod zadeklarowanych poza metodami. Na przykład <code>z</code> jest <em>zmienną klasy</em>, równoważną ze <em>statyczną zmienna składową</em> w C++, która posiada taką sama wartość dla wszystkich instancji klasy.</p><p>Proszę zauważyć, że metoda <code>__init__</code> pobiera 3 argumenty a <code>add</code> jedną, jednak wywołujemy te metody odpowiednio z 2 i 0 argumentów. Pierwszy argument reprezentuje, zgodnie z konwencją, lokalną nazwę używana wewnątrz metody do odniesienia się do bieżącego obiektu. Tutaj stosujemy <code>self</code> do odniesienia się do bieżącego obiektu, ale można by użyć innej nazwy. Zmienna <code>self</code> spełnia taką samą rolę jak <code>*this</code> w C++ lub <code>this</code> w Java, ale <code>self</code> nie jest słowem kluczowym.</p><p>Taka składnia jest niezbędna aby uniknąć dwuznaczności przy podczas deklarowania zagnieżdżonych klas, takich jak klasa, która jest lokalna w stosunku do metody wewnątrz innej klasy.</p><h3>Specjalne atrybuty, metody i operatory</h3><p>Atrybuty klas, metody i operatory rozpoczynające się podwójnym podkreśleniem są zazwyczaj przeznaczone do bycia prywatnymi (np. aby uwidaczniać je wewnątrz, ale nie na zewnątrz klasy), ale jest to konwencja nie respektowana przez interpreter.</p><p>Niektóre z nich są zarezerwowane jako słowa kluczowe i mają specjalne znaczenia.</p><p>Oto dla przykładu trzy z nich:</p><ul><li><code>__len__</code></li><li><code>__getitem__</code></li><li><code>__setitem__</code></li></ul><p>Mogą one być użyte, na przykład, do utworzenia obiektu kontenera, który działa jak lista:</p><pre><code class="code">&gt;&gt;&gt; class MyList(object):
&gt;&gt;&gt;     def __init__(self, *a): self.a = list(a)
&gt;&gt;&gt;     def __len__(self): return len(self.a)
&gt;&gt;&gt;     def __getitem__(self, i): return self.a[i]
&gt;&gt;&gt;     def __setitem__(self, i, j): self.a[i] = j
&gt;&gt;&gt; b = MyList(3, 4, 5)
&gt;&gt;&gt; print b[1]
4
&gt;&gt;&gt; b.a[1] = 7
&gt;&gt;&gt; print b.a
[3, 7, 5]</code></pre><p>Inne specjalne operatory zawierają <code>__getattr__</code> i <code>__setattr__</code> definiujące atrybuty get i set dla klas oraz  <code>__sum__</code> i <code>__sub__</code> nadpisujące operacje arytmetyczne. W celu poznania działania tych operatorów odsyłamy czytelnika do bardziej zaawansowanych książek w tym temacie. Wspominaliśmy już o specjalnych operatorach <code>__str__</code> i <code>__repr__</code>.</p><h3>Wejście i wyjście pliku</h3><p><div class="inxx">file.read</div> <div class="inxx">file.write</div></p><p>W Pythonie można otwierać pliki i dokonywać w nich zapisu przy użyciu:</p><pre><code class="code">&gt;&gt;&gt; file = open('myfile.txt', 'w')
&gt;&gt;&gt; file.write('hello world')
&gt;&gt;&gt; file.close()</code></pre><p>Podobnie można dokonywać z powrotem odczytu z pliku stosując:</p><pre><code class="code">&gt;&gt;&gt; file = open('myfile.txt', 'r')
&gt;&gt;&gt; print file.read()
hello world</code></pre><p>Alternatywnie można dokonywać odczytu w trybie binarnym stosując "rb", zapisywać w trybie binarnym stosując "wb" i otwierać plik w trybie dopisywania stosując "a", wykorzystując standardową notację C.</p><p>Polecenie <code>read</code> pobiera opcjonalny argument, który jest liczbą bajtów. Można również przeskoczyć do określonego miejsca w pliku wykorzystując atrybut <code>seek</code>.</p><div class="inxx">file.seek</div><p>Można z powrotem odczytać dane z pliku stosując polecenie <code>read</code>:</p><pre><code class="code">&gt;&gt;&gt; print file.seek(6)
&gt;&gt;&gt; print file.read()
world</code></pre><p>i można zamknąć plik stosując:</p><pre><code class="code">&gt;&gt;&gt; file.close()</code></pre><p>W standardowej dystrybucji Pythona, znanej pod nazwą CPython, zmienne są zliczanymi referencjami (odniesieniami do obiektów), dotyczy to też przechowywanie uchwytów do plików, tak więc CPython wie, ze gdy liczba referencji uchwytów do otwartych plików spada do zera, to plik może zostać zamknięty a zmienne zbyte. Jednak w innej implementacji Pythona, takiej jak PyPy, zamiast zliczania referencji stosowane jest odśmiecanie kolekcji, a to oznacza, że możliwe jest  skumulowanie w tym samym czasie za dużej ilości uchwytów do otwartych plików. W rezultacie, w wyniku błędu <em>gc</em> ma szansę zamknąć wszystkie pliki i pozbyć się zmiennych.  Dlatego najlepiej jest zamykać uchwyty do plików, gdy nie są one już potrzebne.  Platforma <em>web2py</em> dostarcza dwie funkcje pomocnicze, <code>read_file()</code> i <code>write_file()</code> wewnątrz przestrzeni nazw <code>gluon.fileutils</code>, która hermetyzuje dostęp do pliku i zapewnia właściwe zamykanie uchwytów.</p><blockquote>Podczas używania web2py nie wiesz gdzie znajduje się bieżący katalog, ponieważ
zależy to od konfiguracji web2py. Zmienna <code>request.folder</code> zawiera ścieżkę do
bieżącej aplikacji. Ścieżki można łączyć z poleceniem <code>os.path.join</code>, co jest
omówione poniżej.</blockquote><h3>Funkcje <code>exec</code>, <code>eval</code></h3><p><div class="inxx">exec</div> <div class="inxx">eval</div></p><p>W przeciwieństwie do Java, Python jest językiem rzeczywiście iterpretowanym. Oznacza to, że ma zdolność do wykonywania wyrażeń Pythona przechowywanych w ciągach znakowych. Na przykład:</p><pre><code class="code">&gt;&gt;&gt; a = "print 'hello world'"
&gt;&gt;&gt; exec(a)
'hello world'</code></pre><p>Co się stało? Funkcja <code>exec</code> powiadamia interpreter, aby ją wywołał i wykonał zawartość ciągu znaków przekazanym jako argument. Jest możliwe wykonanie zawartości ciagu w kontekście zdefiniowanym przez symbol w słowniku:</p><pre><code class="code">&gt;&gt;&gt; a = "print b"
&gt;&gt;&gt; c = dict(b=3)
&gt;&gt;&gt; exec(a, {}, c)
3</code></pre><p>Tutaj interpreter podczas wykonywania ciagu <code>a</code> widzi symbole zdefiniowane w <code>c</code> (w tym przykładzie <code>b</code>), ale nie widzi całego <code>c</code> i <code>a</code>. Jest to inaczej niż w ograniczonym środowisku, ponieważ <code>exec</code> nie ogranicza tego, co można zrobić wewnętrzny kod. Po prostu określa zestaw zmiennych widzianych przez kod.</p><p>Funkcją związana jest <code>eval</code>, która działa podobnie jak <code>exec</code>, ale oczekuje argumentów do ewaluacji wartości i zwraca tą wartość.</p><pre><code class="code">&gt;&gt;&gt; a = "3*4"
&gt;&gt;&gt; b = eval(a)
&gt;&gt;&gt; print b
12</code></pre><h3>Instrukcja <code>import</code></h3><p><div class="inxx">import</div> <div class="inxx">random</div> Prawdziwa siła Python leży w jego modułach bibliotecznych. Dostarczają one duży i spójny zbiór interfejsów programowania aplikacji (Application Programming Interfaces - API) dla wielu bibliotek systemowych (często w sposób niezależny od systemu operacyjnego).</p><p>Na przykład, jeśli chce się skorzystać z generatora liczb losowych, można to zrobić tak:</p><pre><code class="code">&gt;&gt;&gt; import random
&gt;&gt;&gt; print random.randint(0, 9)
5</code></pre><p>Drukuje to losowa liczbę całkowita pomiędzy 0 i 9 (w tym 9), na przykład 5. Funkcja <code>randint</code> jest zdefiniowana w module <code>random</code>. Jest też możliwe zaimportowanie obiektu z modułu do bieżącej przestrzeni nazw:</p><pre><code class="code">&gt;&gt;&gt; from random import randint
&gt;&gt;&gt; print randint(0, 9)</code></pre><p>lub zaimportować wszystkie obiekty z modułu do bieżącej przestrzeni nazw:</p><pre><code class="code">&gt;&gt;&gt; from random import *
&gt;&gt;&gt; print randint(0, 9)</code></pre><p>lub zaimportować wszystko w nowo definiowanej przestrzeni nazw:</p><pre><code class="code">&gt;&gt;&gt; import random as myrand
&gt;&gt;&gt; print myrand.randint(0, 9)</code></pre><p>W pozostałej części tej książki będziemy korzystać z obiektów określonych w modułach <code>os</code>, <code>sys</code>, <code>datetime</code>, <code>time</code> i <code>cPickle</code>.</p><blockquote>Wszystkie obiekty web2py są dostępne poprzez moduł o nazwie <code>gluon</code> i to jest
przedmiotem dalszych rozdziałów. Platforma web2py wykorzystuje wiele modułów
Pythona (na przykład <code>thread</code>), ale bardzo rzadko trzeba się do nich odwoływać
bezpośrednio.</blockquote><p>W kolejnych podrozdziałach omówimy te moduły, które są najbardziej użyteczne.</p><h4>Moduł <code>os</code></h4><p><div class="inxx">os</div> <div class="inxx">os.path.join</div> <div class="inxx">os.unlink</div></p><p>Moduł ten dostarcza interfejs do API systemu operacyjnego. Na przykład:</p><pre><code class="code">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.chdir('..')
&gt;&gt;&gt; os.unlink('filename_to_be_deleted')</code></pre><blockquote>Niektórych funkcji <code>os</code>, takich jak <code>chdir</code>, NIE MOŻNA używać w web2py,
ponieważ nie są bezpieczne dla wątku.</blockquote><p>Polecenie <code>os.path.join</code> jest bardzo użyteczne – pozwala na łączenie ścieżek w sposób niezależny od is OS:</p><pre><code class="code">&gt;&gt;&gt; import os
&gt;&gt;&gt; a = os.path.join('path', 'sub_path')
&gt;&gt;&gt; print a
path/sub_path</code></pre><p>Do zmiennych środowiskowych systemu można uzyskać dostęp poprzez:</p><pre><code class="code">&gt;&gt;&gt; print os.environ</code></pre><p>który jest katalogiem tylko do odczytu.</p><h4>Moduł <code>sys</code></h4><p><div class="inxx">sys</div> <div class="inxx">sys.path</div></p><p>Moduł <code>sys</code> zawiera wiele zmiennych i funkcji, ale ta, która jest najbardziej dla nas przydatna, to <code>sys.path</code>. Zawiera listę ścieżek na których Python wyszukuje moduły. Gdy próbujemy zaimportować moduł, Python odszukuje go we wszystkich folderach wykazanych przez <code>sys.path</code>. Jeśli instalujesz moduły w jakimś miejscu i chcesz, aby Python je znalazł, to musisz dołączyć ta lokalizacje do <code>sys.path</code>.</p><pre><code class="code">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('path/to/my/modules')</code></pre><p>Podczas uruchamiania web2py, Python zostaje wczytany do pamięci i rezyduje w niej przez cały czas działania web2py, tak więc w pamięci jest tylko jeden zbiór <code>sys.path</code>, podczas gdy może istnieć wiele wątków obsługujących żądania HTTP. Aby uniknąć przepełnienia pamięci, najlepiej jest sprawdzić, czy ścieżka już istnieje, przed jej ewentualnym dodaniem:</p><pre><code class="code">&gt;&gt;&gt; path = 'path/to/my/modules'
&gt;&gt;&gt; if not path in sys.path:
        sys.path.append(path)</code></pre><h4>Moduł <code>datetime</code></h4><p><div class="inxx">date</div> <div class="inxx">datetime</div> <div class="inxx">time</div></p><p>Zastosowanie modułu datetime najlepiej jest zilustrować na przykładach:</p><pre><code class="code">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; print datetime.datetime.today()
2008-07-04 14:03:90
&gt;&gt;&gt; print datetime.date.today()
2008-07-04</code></pre><p>Czasem może być konieczne ustalenie znacznika czasu na podstawie czasu UTC zamiast czasu lokalnego. W takim przypadku można skorzystać z następującej funkcji:</p><pre><code class="code">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; print datetime.datetime.utcnow()
2008-07-04 14:03:90</code></pre><p>Moduł datetime zawiera rózne klasy: date, datetime, time i timedelta. Różnicą pomiędzy dwoma obiektami date lub dwoma obiektami datetime lub dwoma obiektami time jest timedelta:</p><pre><code class="code">&gt;&gt;&gt; a = datetime.datetime(2008, 1, 1, 20, 30)
&gt;&gt;&gt; b = datetime.datetime(2008, 1, 2, 20, 30)
&gt;&gt;&gt; c = b - a
&gt;&gt;&gt; print c.days
1</code></pre><p>W web2py moduły date i datetime są używane do przechowywania odpowiednich typów SQL podczas przekazywania do lub zwracania z bazy danych.</p><h4>Moduł <code>time</code></h4><div class="inxx">time</div><p>Moduł time różni się od modułów <code>date</code> i <code>datetime</code>, ponieważ reprezentuje czas liczony w sekundach od początku epoki (początek 1970).</p><pre><code class="code">&gt;&gt;&gt; import time
&gt;&gt;&gt; t = time.time()
1215138737.571</code></pre><p>Proszę zapoznać się z dokumentacją Pythona w zakresie konwersji pomiędzy czasem w sekundach a czasem traktowanych jako <code>datetime</code>.</p><h4>Moduł <code>cPickle</code></h4><p><div class="inxx">cPickle</div> <div class="inxx">peklowanie</div></p><p>Jest to bardzo potężny moduł. Dostarcza funkcji, które mogą serializować prawie dowolny obiekt Pythona, w tym obiekty samo się odwołujących. W Pytonie taki proces serializacji nosi nazwę <em>peklowania</em>. Na przykład, zbudujmy dziwny obiekt:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object): pass
&gt;&gt;&gt; myinstance = MyClass()
&gt;&gt;&gt; myinstance.x = 'something'
&gt;&gt;&gt; a = [1 ,2, {'hello':'world'}, [3, 4, [myinstance]]]</code></pre><p>a teraz:</p><pre><code class="code">&gt;&gt;&gt; import cPickle
&gt;&gt;&gt; b = cPickle.dumps(a)
&gt;&gt;&gt; c = cPickle.loads(b)</code></pre><p>W tym przykładzie <code>b</code> jest reprezentacją łańcuchową <code>a</code>, a <code>c</code> jest kopią <code>a</code> generowaną przez zdeserializowany obiekt <code>b</code>.</p><p>cPickle może serializować i deserializować obiekt pliku:</p><pre><code class="code">&gt;&gt;&gt; cPickle.dump(a, open('myfile.pickle', 'wb'))
&gt;&gt;&gt; c = cPickle.load(open('myfile.pickle', 'rb'))</code></pre>