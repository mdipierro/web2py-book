## El núcleo

### Opciones de la línea de comandos

Es posible saltarse la GUI e iniciar web2py directamente desde la línea de comandos escribiendo algo como:
``password``:inxx

``
python web2py.py -a 'tu contraseña' -i 127.0.0.1 -p 8000
``:code

Cuando web2py se inicia, crea un archivo llamado "parameters_8000.py" en el que almacena el hash de la contraseña. Si usas "<ask>" como contraseña, web2py te pedirá que la escribas.

Para mayor seguridad, puedes iniciar web2py con:
``
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
``:code

En este caso web2py reutiliza el hash de la contraseña almacenado anteriormente. Si no se provee de una contraseña, o si se elimina el archivo "parameters_8000.py", se deshabilita la interfaz administrativa web.

``PAM``:inxx
En algunos sistemas Unix/Linux, si la contraseña es
``
<pam_user:un_usuario>
``:code

web2py usa la contraseña PAM de la cuenta de ``un_usuario`` en el sistema operativo para autenticar al administrador, a menos que lo impida la configuración de PAM.

-------
web2py normalmente se corre con CPython (la implementación en C del intérprete creada por Guido Van Rossum), pero también se puede ejecutar con Jython (la implementación en Java del intérprete). La última opción permite el uso de web2py en el contexto de una infraestructura J2EE. Para usar Jython, simplemente reemplaza "python web2py.py ..." con "jython web2py.py". Se pueden consultar detalles sobre la instalación de Jython y los módulos zxJDBC necesarios para acceder a las bases de datos en el Capítulo 14.
-------

El script "web2py.py" puede tomar múltiples argumentos de línea de comandos especificando el número máximo de hilos, si se debe habilitar SSL, etc. Para una lista completa escribe:

``command line``:inxx
``
>>> python web2py.py -h
Uso: python web2py.py

Script de inicio del Armazón Web web2py, ATENCIÓN: a menos que se
especifique una contraseña (-a 'contraseña'), web2py intentará correr una GUI.
En este caso las opciones de línea de comandos se ignoran.

Opciones:
  --versión          muestra la versión del programa y sale
  -h, --help         muestra este mensaje de ayuda y sale
  -i IP, --ip=IP    la dirección ip del servidor (127.0.0.1)
  -p PUERTO, --port=PUERTO    puerto del servidor (8000)
  -a CONTRASEÑA, --password=CONTRASEÑA
                        contraseña utilizada para administración (usa -a
                        "<recycle>" para reutilizar la última contraseña))
  -c CERTIFICADO_SSL, --ssl_certificate=CERTIFICADO_SSL
                        archivo que contiene el certificado ssl
  -k CLAVE_PRIVADA_SSL, --ssl_private_key=CLAVE_PRIVADA_SSL
                        el archivo que contiene la clave privada ssl
  -d ARCHIVO_PID, --pid_filename=ARCHIVO_PID
                        archivo para almacenar el pid del servidor
  -l ARCHIVO_LOG, --log_filename=ARCHIVO_LOG
                        log de registro de las conexiones
  -n HILOS, --numthreads=HILOS
                        cantidad de hilos (obsoleto)
  --minthreads=MIN_HILOS
                        número mínimo de hilos del servidor
  --maxthreads=MAX_HILOS
                        número máximo de hilos del servidor
  -s NOMBRE_SERVIDOR, --server_name=NOMBRE_SERVIDOR
                        nombre del servidor web
  -q COLA_SOLICITUDES, --request_queue_size=COLA_SOLICITUDES
                        número máximo de solicitudes en espera cuando el servidor
                        no puede responder
  -o TIEMPO_ESPERA, --timeout=TIEMPO_ESPERA
                        tiempo de espera para cada solicitud (10 segundos)
  -z ESPERA_APAGAR, --shutdown_timeout=ESPERA_APAGAR
                        tiempo de espera para apagar el servidor (5 segundos)
  -f CARPETA, --folder=CARPETA
                        carpeta raíz para correr web2py
  -v, --verbose         incrementar el detalle de la salida para --test
  -Q, --quiet           deshabilitar toda salida
  -D NIVEL_DEPURACIÓN, --debug=NIVEL_DEPURACIÓN
                        configurar el nivel de la salida de depuración (0, 100,
                        0 significa todo, 100 significa nada; por defecto es 30)
  -S NOMBRE_APP, --shell=NOMBRE_APP
                        corre web2py en una consola interactiva o en 
                        IPython (si está instalado) con la aplicación
                        especificada (si la app no existe se crea automáticamente).
                        NOMBRE_APP admite la notación a/c/f (c, f opcionales)
  -B, --bpython     corre web2py en la shell interactiva o bpython (si se instaló)
                           con el nombre de app especificado (si la app no existe la crea).
                           Se usa en combinación con --shell
  -P, --plain           sólo utilizar una shell estándar de Python; se debería usar con
                            la opción --shell
  -M, --import_models   importa automáticamente los archivos del modelo;
                        por defecto es False; debería usarse con la opción --shell
  -R ARCHIVO_PYTHON, --run=ARCHIVO_PYTHON
                        correr ARCHIVO_PYTHON en un entorno de web2py;
                        debería usarse con la opción --shell
  -K TAREAS_PROGRAMADAS, --scheduler=TAREAS_PROGRAMADAS
                        corre tareas programadas para las app especificadas
                        -K app1, app2, app3 requiere de un administrador de tareas
                        definido en el modelo de cada app
  -T RUTA_TEST, --test=RUTA_TEST
                        corre los doctest en un entorno de web2py; RUTA_TEST acepta
                        la notación a/c/f (c, f opcionales)
  -W SERVICIOWIN, --winservice=SERVICIOWIN
                        -W instalar|iniciar|parar como servicio de Windows
  -C, --cron            iniciar un cron manualmente; comúnmente usado en 
                            los crontab del sistema
  --softcron            activa el uso de softcron
  -N, --no-cron         no iniciar cron automáticamente
  -J, --cronjob         se usa para identificar un comando iniciado por cron
  -L CONFIG, --config=CONFIG
                        archivo config
  -F ARCHIVO_PROFILER, --profiler=ARCHIVO_PROFILER
                        nombre del archivo profiler
  -t, --taskbar         usar la gui de web2py y correr en la barra de
                            tareas (o bandeja del sistema)
  --nogui               sólo-texto, sin GUI
  -A ARGS, --args=ARGS  debería continuar con una lista de argumentos a
                        pasarse al script, para usarlo con -S, -A debe
                        ser la última opción
  --no-banner           No mostrar la gráfica del encabezado
  --interfaces=INTERFACES
                        escuchar múltiples direcciones:
                        "ip:port:cert:clave;ip2:port2:cert2:clave2;..." (:cert:clave
                        es opcional; sin espacios)
``:code

Las opciones en minúsculas se usan para configurar el servidor web. La opcion ``-L`` le dice a web2py que lea las opciones de configuración desde un archivo, ``-W`` instala web2py como servicio de Windows, mientras que las opciones ``-S``, ``-P`` y ``-M``  inician una consola interactiva de Python. La opción ``-T`` busca y ejecuta doctest en un entorno de ejecución de web2py. Por ejemplo, el siguiente ejemplo corre los doctest de todos los controladores en la aplicación "welcome":
``
python web2py.py -vT welcome
``:code

Si corres web2py como servicio de Windows, ``-W``, no es recomendable pasar la configuración por medio de la línea de comandos. Por esta razón, en la carpeta de web2py hay un archivo de configuración de ejemplo "options_std.py" para el servidor web interno:

``
import socket
import os

ip = '0.0.0.0'
port = 80
interfaces=[('0.0.0.0',80)]
#interfaces.append(('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem'))
password = '<recycle>'  # ## <recycle> significa utilizar la última contraseña
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None
``:code

Este archivo contiene la configuración por defecto de web2py. Si editas este archivo, necesitas importarlo explícitamente con la opción de línea de comandos ``-L``. Sólo funciona cuando corres web2py como servicio de Windows.

### Flujo de trabajo (Workflow)

El flujo de trabajo de web2py es el siguiente:

- Ingreso de una solicitud HTTP al servidor web (el servidor incorporado Rocket u otro servidor conectado a web2py por WSGI u otro adaptador). El servidor resuelve cada solicitud en su propio hilo, en paralelo.
- El encabezado de la solicitud HTTP se interpreta (parse) y se pasa al dispatcher (se explica más adelante en este capítulo)
- El dispatcher decide cuál de las aplicaciones instaladas manejará la solicitud y asocia (map) el PATH_INFO en la URL con una llamada a función. Cada URL se corresponde con una llamada a función.
- Las solicitudes de archivos en la carpeta static se manejan directamente, y los archivos pesados se procesan en un stream para devolverlos al cliente.
- Toda solicitud que no sea un archivo estático se asocia a una acción (por ejemplo una función en un archivo de controlador, en la aplicación solicitada).
- Antes de ejecutar la acción, ocurren algunas cosas: si el encabezado de la solicitud contiene una cookie de sesión para la app, se recupera el objeto session; si no, se crea un id de sesión (pero el archivo de la sesión aún no se escribe); se crea un entorno de ejecución para la solicitud; se ejecutan los modelos ese entorno.
- Por último la acción en el controlador es ejecutada en el entorno previamente creado.
- Si la acción devuelve una cadena (string), se devuelve al cliente (o si la acción devuelve un ayudante de HTML de web2py, se serializa y devuelve al cliente).
- Si la acción devuelve un objeto iterable, este se usa para devolver en el stream los datos al cliente por medio de un bucle.
- Si la acción devuelve un diccionario, web2py trata de ubicar una vista para convertir (render) el diccionario. La vista debe tener el mismo nombre que la acción (a menos que se haya especificado otra cosa) y la misma extensión que la página solicitada (por defecto es .html); en caso de fallar, web2py puede tomar una vista genérica (en caso de haberla encontrado y que la opción esté habilitada). La vista ve cada variable definida en los modelos así como también las que se encuentran en el diccionario devuelto por la acción, pero no ve las variables globales definidas en el controlador.
- Todo el código del usuario se ejecuta en una única transacción a menos que se especifique otra cosa.
- Si el código del usuario tiene éxito, los cambios se aplican.
- Si se producen fallos en el código del usuario, se almacena una traza (traceback) en un ticket, y el ID del ticket se envía al cliente. Sólo el administrador del sistema puede consultar los reportes y leer los detalles de las trazas de errores en los ticket.
- Hay algunas cuestiones a tener en cuenta:
- Los modelos que comparten la misma carpeta se ejecutan en orden alfabético.
- Toda variable definida en un modelo será visible para los otros modelos que sigan en el orden alfabético, para los controladores, y para las vistas.
- Los modelos en subcarpetas se ejecutan en forma condicional. Por ejemplo, si el usuario ha solicitado "/a/c/f" donde "a" es la aplicación, "c" es el controlador, y "f" es la función (acción), entonces se ejecutan los siguientes modelos:

``
applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py
``

- Se ejecutan el controlador solicitado y se llama a la función solicitada. Esto significa que todo el código de nivel superior en el controlador es también ejecutado en cada solicitud para ese controlador.
- La vista se llama sólo si la acción devuelve un diccionario.
- Si no se encuentra una vista, web2py intenta utilizar una vista genérica. Por defecto, las vistas genéricas están deshabilitadas, aunque la app 'welcome' incluye una línea en /models/db.py para habilitarlas únicamente para localhost. Se pueden habilitar en función de su extensión y por acción (usando ``response.generic_patterns``). En general, las vistas genéricas son una herramienta para desarrollo y no se deberían usar en producción. Si deseas que algunas acciones usen una vista genérica, agrega esas acciones a la lista en ``response.generic_patterns`` (tratado con más detalle en el capitulo sobre Servicios)

Los posibles comportamientos de una acción son los siguientes:

**Devolver una cadena**
``
def index(): return 'data'
``

**Devolver un diccionario para una vista**:
``
def index(): return dict(clave='valor')
``

**Devolver todas las variables locales**:
``
def index(): return locals()
``

**Redirigir al usuario a otra página**:
``
def index(): redirect(URL('otra_accion'))
``

**Devolver una página que no sea "200 OK"**:
``
def index(): raise HTTP(404)
``

**Devolver un ayudante** (por ejemplo un FORM):
``
def index(): return FORM(INPUT(_name='prueba'))
``
(esto se usa comúnmente para los callback de Ajax y componentes, ver el capítulo 12)

Cuando una acción devuelve un diccionario, este puede contener código generado por ayudantes, incluyendo formularios basados en tablas de la base de datos o formularios creados por factory, por ejemplo:

``
def index(): return dict(form=SQLFORM.factory(Field('nombre')).process())
``
(todos los formularios generados por web2py usan postback, ver el capítulo 3)

### Dispatching
``url mapping``:inxx ``dispatching``:inxx

web2py asocia (map) una URL de la forma:

``
http://127.0.0.1:8000/a/c/f.html
``:code

a la la función ``f()`` en el controlador "c.py" en la aplicación "a". Si ``f`` no se encuentra, web2py usa por defecto la función ``index`` del controlador. Si no se encuentra ``c``, web2py usa por defecto el controlador "default.py", y si ``a`` no se encuentra, web2py usa por defecto la aplicación ``init``. Si no hay una aplicación ``init``, web2py trata de correr la aplicación ``welcome``. El esquema se muestra en la imagen de abajo:

(Los nombres de la aplicación, controlador y función por defecto se pueden sobreescribir en routes.py; ver ''[[Default Application, Controller and Function #Default-Application,-Controller-and-Function]]'' abajo.

[[image @///image/en5700.png center 480px]]

Por defecto, cada nueva solicitud también crea una nueva sesión. Por otra parte, una cookie de sesión es devuelta al navegador para mantener un registro de la sesión.

La extensión ``.html`` es opcional; ``.html`` se asume por defecto. La extensión determina la extensión de la vista que convierte la salida de la función ``f()`` del controlador. Esto permite que se pueda servir el mismo contenido en múltiples formatos (html, xml, json, rss, etc.).

-------
Las funciones que toman argumentos o que comienzan con doble sub-guión ("__") no se exponen en forma pública y sólo pueden ser llamadas por otras funciones.
-------

``static files``:inxx
Hay una excepción para el caso de las URL de los formularios:
``
http://127.0.0.1:8000/a/static/nombredearchivo
``:code

No hay un controlador llamado "static". web2py interpreta esto como una solicitud del archivo llamado "nombredearchivo" en la subcarpeta "static" de la aplicación "a".

``PARTIAL CONTENT``:inxx ``IF_MODIFIED_SINCE``:inxx
Cuando se descargan los archivos estáticos, web2py no crea una sesión, ni envía un cookie o ejecuta los modelos. web2py siempre crea los stream de archivos estáticos en paquetes de 1MB y los envía como PARTIAL_CONTENT cuando el cliente envía una solicitud RANGE para una parte del archivo.

web2py además soporta el protocolo IF_MODIFIED_SINCE, y no envía el archivo si ya se ha almacenado en el caché del navegador o si el archivo no ha cambiado desde la última versión.

Cuando se crea un enlace a un archivo de video o audio en la carpeta static, si deseas forzar al navegador a que descargue el archivo en lugar de utilizar un stream con un reproductor de medios, agrega ``?attachment`` a la URL. Esto le dice a web2py que configure el encabezado ``Content-Disposition`` de la respuesta HTTP a "attachment". Por ejemplo:

``
<a href="/app/static/my_audio_file.mp3?attachment">Descargar</a>
``:code

Cuando se hace clic en el link de arriba, el navegador preguntará al usuario si quiere descargar el archivo MP3 en lugar de reproducir por streaming inmediatamente. (Como se trata más [[abajo #response]], puedes además configurar los encabezados de la respuesta HTTP directamente asignando un ``dict`` de encabezados con sus valores a ``response.headers``).

``request.application``:inxx ``request.controller``:inxx ``request.function``:inxx ``GET``:inxx ``POST``:inxx ``request.args``:inxx
web2py asocia (map) las solicitudes GET/POST de la forma:
``
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
``:code

a la función ``f`` en el controlador "c.py" en la aplicación ``a``, y almacena los parámetros de la URL en la variable ``request`` como sigue:
``
request.args = ['x', 'y', 'z']
``:code

y:
``
request.vars = {'p':1, 'q':2}
``:code

y:
``
request.application = 'a'
request.controller = 'c'
request.function = 'f'
``:code

En el ejemplo de arriba, tanto ``request.args[n]`` como ``request.args(n)`` se pueden usar para recuperar el n-ésimo de los argumentos en ``request.args``, pero con la diferencia de que para el primero genera una excepción si la lista no tiene ese elemento, y el segundo devuelve None en ese caso.

``request.url``:inxx
``
request.url
``:code

almacena la URL completa de la solicitud actual (sin incluir las variables GET).

``request.ajax``:inxx ``request.cid``:inxx

``
request.ajax
``:code

es False por defecto o True si web2py determina que la acción fue llamada con una solicitud Ajax.

Si la solicitud es de tipo Ajax y se inició con un componente de web2py, el nombre del componente se puede hallar en:

``
request.cid
``:code

Los componentes se tratan con más detalle en el Capítulo 12.

``request.get_vars``:inxx ``request.post_vars``:inxx ``request.vars``:inxx
Si la solicitud HTTP es GET, entonces ``request.env.request_method`` se establece como "GET"; si es de tipo POST, ``request.env.request_method`` se establece como "POST". Las variables de consulta en la URL se almacenan en el diccionario Storage ``request.vars``; también se guardan en ``request.get_vars`` (si la solicitud es GET) o ``request.post_vars`` (si la solicitud es POST).

web2py almacena las variables de entorno y de WSGI en ``request.env``, por ejemplo:
``
request.env.path_info = 'a/c/f'
``:code

y los encabezados HTTP en variables de entorno, por ejemplo:
``
request.env.http_host = '127.0.0.1:8000'
``:code

-------
Ten en cuenta que web2py valida todas las URL para prevenir los ataques directory traversal.
-------

Sólo se permite a las URL que contengan letras, sub-guiones y barras; los ``args`` pueden contener puntos no consecutivos. Los espacios se reemplazan con sub-guiones antes de la validación. Si la sintaxis de URL no es válida, web2py devuelve un mensaje de error HTTP 400``http:w,http:o``:cite .

Si la URL corresponde a una solicitud de un archivo estático, web2py simplemente lee y devuelve (por stream) el archivo solicitado.

Si la URL no solicita un archivo estático, web2py procesa la solicitud en el siguiente orden:
- Lee (parse) las cookie.
- Crea un entorno en el cual ejecutará la función.
- Inicializa ``request``, ``response``, ``cache``.
- Abre un objeto ``session`` existente o crea uno nuevo.
- Ejecuta los modelos que pertenecen a la aplicación solicitada.
- Ejecuta la función de la acción del controlador solicitado.
- Si la función devuelve un diccionario, ejecuta la vista asociada.
- En caso de éxito, aplica los cambios en todas las transacciones abiertas (commit).
- Guarda la sesión (session).
- Devuelve una respuesta HTTP.

Ten en cuenta que el controlador y la vista se ejecutan en copias distintas del mismo entorno; por lo tanto, la vista no ve el controlador, pero ve los modelos y las variables devueltas por la función de la acción.

Si se genera una excepción (que no sea HTTP), web2py hace lo siguiente:
- Almacena la traza del error en un archivo y le asigna un número de ticket.
- Devuelve todas las transacciones a su estado anterior (roll back).
- Devuelve una página de error informando el número de ticket.

Si la excepción es ``HTTP``, se interpreta como el comportamiento normal (por ejemplo, una redirección ``HTTP``), y se aplican los cambios de todas las transacciones de bases de datos (commit). El comportamiento que sigue lo especifica la misma excepción ``HTTP``. La clase de excepción ``HTTP`` no es una excepción estándar de Python; está definida en web2py.

### Librerías

Las librerías de web2py se exponen a las aplicaciones del usuario como objetos globales. Por ejemplo ``request``, ``response``, ``session``, ``cache``, las clases (ayudantes, validadores, la API de DAL), y las funciones (``T`` y ``redirect``).

Estos objetos se definen en los siguientes archivos del núcleo:
``
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
``:code

La aplicación de andamiaje comprimida con gzip que viene con web2py es
``
welcome.w2p
``:code

Se crea al instalar y se sobreescribe cuando se realiza un upgrade.

-------
La primera vez que inicias web2py, se crean dos nuevas carpetas: deposit y applications. La app "welcome" está comprimida en un archivo "welcome.w2p" para su uso como aplicación de andamiaje.
La carpeta deposit es utilizada como almacenamiento temporario para la instalación y desinstalación de aplicaciones.
-------

Los unit-test de web2py están en
``
gluon/tests/
``:code

Hay manejadores para conectar a varios servidores web:
``
cgihandler.py       # discouraged
gaehandler.py       # for Google App Engine
fcgihandler.py      # for FastCGI
wsgihandler.py      # for WSGI
isapiwsgihandler.py # for IIS
modpythonhandler.py # deprecated
``:code

("fcgihandler" llama a "gluon/contrib/gateways/fcgi.py" desarrollado por Allan Saddi) y

``
anyserver.py
``

que es un script para interfaz con varios servidores web, descripto en el Capítulo 13.

Hay tres archivos de ejemplo:
``
options_std.py
routes.example.py
router.example.py
``:code

El primero es un archivo de configuración opcional que se puede pasar a web2py.py con la opción ``-L``. El segundo es un ejemplo de archivo para manejo de URL (URL mapping). Se carga automáticamente cuando se cambia su nombre a "routes.py". El tercero contiene una sintaxis alternativa para el manejo de URL, y también se puede renombrar como "routes.py".

Los archivos
``
app.yaml
index.yaml
queue.yaml
``:code

son archivos de configuración usados para desplegar proyectos en Google App Engine. Puedes leer más sobre ellos en capítulo Recetas para el Despliegue y en la documentación de Google.

También hay librerías adicionales, usualmente desarrolladas por terceros:

**feedparser**``feedparser``:cite  por Mark Pilgrim para la lectura de fuentes RSS y Atom:
``
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
``:code

**markdown2**``markdown2``:cite  por Trent Mick para la sintaxis de wiki:
``
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
``:code

La sintaxis **markmin**:
``
gluon/contrib/markmin.py
``:code

**pyfpdf** creada por Mariano Reingart  para generar documentos PDF:
``
gluon/contrib/pyfpdf
``
Esto no está documentado en este libro pero está alojado y documentado aquí:
``
http://code.google.com/p/pyfpdf/
``

**pysimplesoap** es una implementación liviana para servidores SOAP creada por Mariano Reingart:

``
gluon/contrib/pysimplesoap/
``:code

**simplejsonrpc** es un cliente JSON-RPC liviano también creado por Mariano Reingart: ``jsonrpc``:inxx

``
gluon/contrib/simplejsonrpc.py
``

**memcache**``memcache``:cite  API de Python por Evan Martin:
``
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
``

**redis_cache** ``redis``:inxx es un módulo para almacenamiento del caché en una base de datos redis:
``
gluon/contrib/redis_cache.py
``

**gql**, un port de la DAL para el Google App Engine:
``
gluon/contrib/gql.py
``:code

**memdb**, un port de la DAL que opera sobre memcache:
``
gluon/contrib/memdb.py
``:code

**gae_memcache** es una API para el uso de memcache en el Google App Engine:
``
gluon/contrib/gae_memcache.py
``:code

**pyrtf**``pyrtf``:cite  para generar documentos Rich Text Format (RTF), desarrollado por Simon Cusack y revisado por Grant Edwards:
``
gluon/contrib/pyrtf
gluon/contrib/pyrtf/__init__.py
gluon/contrib/pyrtf/Constants.py
gluon/contrib/pyrtf/Elements.py
gluon/contrib/pyrtf/PropertySets.py
gluon/contrib/pyrtf/README
gluon/contrib/pyrtf/Renderer.py
gluon/contrib/pyrtf/Styles.py
``:code

**PyRSS2Gen**``pyrss2gen``:cite  desarrollado por Dalke Scientific Software, para generar fuentes RSS:
``
gluon/contrib/rss2.py
``:code

**simplejson**``simplejson``:cite  por Bob Ippolito, la librería estándar para la lectura (parse) y escritura de objetos JSON:
``
gluon/contrib/simplejson/__init__.py
gluon/contrib/simplejson/decoder.py
gluon/contrib/simplejson/encoder.py
gluon/contrib/simplejson/jsonfilter.py
gluon/contrib/simplejson/scanner.py
``:code

**Google Wallet** ``googlewallet``:cite 
provee de botones de pago instantáneo que enlazan al servicio de pagos de Google:
``
gluon/contrib/google_wallet.py
``:code

**Stripe.com** ``stripe``:cite provee de una API simple para aceptar pagos con tarjeta de crédito:
``
gluon/contrib/stripe.py
``:code

**AuthorizeNet** ``authorizenet``:cite  provee de una API para aceptar pagos con tarjeta de crédito a través de la red Authorize.net
``
gluon/contrib/AuthorizeNet.py
``:code

**Dowcommerce** ``dowcommerce``:cite otra API más de servicios para pagos con tarjeta:
``
gluon/contrib/DowCommerce.py
``:code

**PAM**``PAM``:cite  authentication API creada por Chris AtLee:
``
gluon/contrib/pam.py
``:code

Un clasificador Bayesiano para el ingreso de datos aleatorios a una base de datos para pruebas:
``
gluon/contrib/populate.py
``:code

Un archivo que permite la interacción con la barra de tareas en Windows, cuando web2py corre como servicio:
``
gluon/contrib/taskbar_widget.py
``:code

Métodos de autenticación (**login_methods**) y formularios de autenticación opcionales:
``
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py
``:code

Además web2py contiene una carpeta con varios script de utilidad incluyendo
``
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py
``:code

Los primeros tres son particularmente útiles porque intentan realizar una instalación y configuración completa en un entorno de producción desde cero.
Algunos de esos script se tratan en el Capítulo 14, pero todos contienen una docstring que explica sus características y forma de utilización.

Por último web2py incluye los archivos necesarios para crear distribuciones binarias.
``
Makefile
setup_exe.py
setup_app.py
``:code

Estos son script de configuración para **py2exe** y **py2app**, respectivamente, y son suficientes para crear las distribuciones de web2py, NUNCA DEBERÍAS NECESITAR EJECUTARLOS.

Resumiendo, las librerías de web2py proveen las siguientes funcionalidades:
- Manejo (map) de las URL para las llamadas a funciónes.
- Manejo de la recepción y devolución de parámetros por HTTP.
- Validación de esos parámetros.
- Protección de las aplicaciones respecto de la mayor parte de los problemas de seguridad.
- Manejo de la persistencia de datos (base de datos, sesión, caché, cookie).
- Traducción de cadenas para los múltiples lenguajes soportados.
- Generación de HTML en forma programática (por ejemplo a partir de tablas de bases de datos).
- Generación de SQL a través de la Capa de Abstracción de la Base de Datos (DAL).
- Generación de salida en Formato de Texto Enriquecido (Rich Text Format) o RTF.
- Generación de salida como Valores Separados por Comas (CSV) a partir de bases de datos.
- Generación de fuentes de Sindicación Realmente Simple (RSS).
- Generación de cadenas serializadas con JavaScript Object Notation (JSON) para Ajax
- Traducción de la sintaxis wiki (Markdown) en HTML.
- Exposición de servicios web XML-RPC.
- Subida y descarga de archivos pesados por streaming.

Las aplicaciones de web2py conetienen archivos adicionales, especialmente librerías JavaScript, como jQuery, calendar/datepicker, EditArea y nicEdit. La información de autoría y derechos están detallados en el código fuente de cada proyecto.


### Aplicaciones

Las aplicaciones desarrolladas en web2py se componen de las siguientes partes:
- **models** los modelos describen una representación de los datos como tablas y relaciones entre tablas.
- **controllers** los controladores describen la lógica de la aplicación y su flujo de trabajo.
- **views** las vistas describen cómo los datos deberían presentarse al usuario por medio de HTML y JavaScript.
- **languages** los idiomas describen cómo se deben traducir las cadenas en la aplicación para los distintos lenguajes soportados.
- **static** los archivos estáticos no requieren procesamiento (por ejemplo imágenes, hojas de estilo CSS, etc.).
- **ABOUT** y **README** ACERCA DE y LÉEME, cuya función está explicitada en sus nombres.
- **errors** errores almacena reportes de error generados por la aplicación.
- **sessions** sesiones almacena la información relativa a cada usuario particular.
- **databases** bases de datos almacena las bases de datos SQLite e información adicional de las tablas.
- **cache** caché almacena los ítem registrados en el caché de la aplicación.
- **modules** módulos son los módulos de Python opcionales.
- **private** privado: los archivos se pueden leer desde los controladores pero no directamente por el desarrollador.
- **uploads** archivos subidos: los archivos se pueden leer desde los modelos pero no directamente por el desarrollador (por ejemplo, los archivos subidos por los usuarios de la aplicación).
- **tests** es una carpeta para almacenar los script con test, fixture y mock.

Se puede acceder a los modelos, vistas, controladores, idiomas y archivos estáticos a través de la interfaz administrativa [diseño]. También es posible acceder a ACERCA DE, LEEME y los errores a través de la interfaz adminstrativa por medio de los ítem de menú correspondientes. Además se puede acceder a los archivos de las sesiones, el caché, módulos y privados pero no a través de la interfaz administrativa.

Todo está prolijamente organizado en una clara estructura de directorio que se refleja en cada aplicación instalada, aunque el usuario nunca tenga necesidad de acceder directamente al sistema de archivos:

``about``:inxx ``license``:inxx ``cache``:inxx ``controllers``:inxx ``databases``:inxx ``errors``:inxx ``languages``:inxx ``models``:inxx ``modules``:inxx ``private``:inxx ``session``:inxx ``static``:inxx ``tests``:inxx ``uploads``:inxx ``views``:inxx ``__init__.py``:inxx
``
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
``:code

"__init__.py" es un archivo vacío que se requiere para permitir que Python (y web2py) importe los módulos que se encuentran en el directorio ``modules``.

Ten en cuenta que la aplicación **admin** simplemente provee de una interfaz web para las aplicaciones en el sistema de archivos del servidor. También se pueden crear y dessarrollar las aplicaciones de web2py desde la línea de comandos; no necesitas utilizar la interfaz **admin** para el navegador. Se puede crear una nueva aplicación manualmente copiando la estructura de directorio anterior bajo, por ejemplo, "applications/appnueva" (o simplemente descomprimiendo el archivo ``welcome.w2p`` en el nuevo directorio de aplicación que hayas asignado). También es posible crear y editar los archivos de la aplicación desde la línea de comandos sin necesidad de usar la interfaz web **admin**.


### API

Se pueden ejecutar los modelos, vistas y controladores en un entorno para el cual los siguientes objetos se han importado previamente por nosotros:

**Objetos globales:** ``request``:inxx ``response``:inxx ``session``:inxx ``cache``:inxx

``
request, response, session, cache
``:code

**Internacionalización:** ``T``:inxx ``internationalization``:inxx

``
T
``:code

**Navegación:** ``redirect``:inxx ``HTTP``:inxx

``
redirect, HTTP
``:code


**Ayudantes:** ``helpers``:inxx

``
XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON
``:code

**Formularios y tablas**

``
SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)
``

**Validadores:** ``validators``:inxx

``
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
``:code

**Base de datos:** ``DAL``:inxx

``
DAL, Field
``:code

Para compatibiliad hacia atrás ``SQLDB=DAL`` y ``SQLField=Field``. Te recomendamos el uso de la nueva sintaxis ``DAL`` y ``Field``, en reemplazo de la sintaxis antigua.

Se definen otros objetos y módulos en las librerías, pero no se importan automáticamente porque no son utilizados tan frecuentemente..

El núcleo de entidades de la API en el entorno de ejecución son ``request``, ``response``, ``session``, ``cache``, ``URL``, ``HTTP``, ``redirect`` y ``T`` y se tratan abajo.

Algunos objetos y funciones, incluyendo **Auth**, **Crud** y **Service**, se definen en "gluon/tools.py" y deben ser importados cuando se los utiliza:
``
from gluon.tools import Auth, Crud, Service
``:code

#### Accediendo a la API desde módulos de Python

Tus modelos o controladores pueden importar módulos de Python, y estos pueden requerir el uso de la API de web2py. La forma de que disponen para ello es importándola:
``
from gluon import *
``
De hecho, cualquier módulo de Python, incluso si no se importa en la aplicación, puede importar la API de web2py siempre y cuando web2py esté en el ``sys.path``.

Sin embargo, existe una particularidad. web2py define algunos objetos globales (request, response, session, cache, T) que sólo pueden existir cuando hay una solicitud HTTP disponible (o simulada). Por lo tanto, los módulos pueden acceder a ellos sólo si se han llamado desde una aplicación. Por esta razón se incluyen en un contenedor llamado ``current``, que es un objeto que pertenece al dominio de un hilo (thread local). Aquí hay un ejemplo:

Crear un módulo "/miapp/modules/test.py" que contenga:
``
from gluon import *
def ip(): return current.request.client
``
Ahora desde un controlador en "miapp" se puede hacer:
``
import test
def index():
    return "Tu ip es " + test.ip()
``

Algunas cosas a tener en cuenta:

- ``import test`` busca el módulo inicialmente en la carpeta modules de la app, luego en las carpetas listadas en ``sys.path``. Por eso, los módulos del nivel de la aplicación siempre tienen precedencia sobre módulos de Python. Esto permite que distintas app incluyan distintas versiones de sus módulos, sin conflictos.

- Los distintos usuarios pueden llamar a la misma acción ``index`` simultaneamente, que llama a la función en el módulo, y sin embargo no hay conflicto porque ``current.request`` es un objeto diferente para distintos hilos. Sólo ten cuidado de no acceder a ``current.request`` fuera de funciones o clases (por ejemplo en el nivel más general) en el módulo.

- ``import test`` es un atajo de ``from applications.appname.modules import test``. Al usar la sintaxis más larga, es posible importar módulos desde otras aplicaciones.

Para mantener la uniformidad con el comportamiento estándar de Python, por defecto web2py no vuelve a cargar módulos cuando se realizan cambios. De todos modos esto se puede cambiar. Para habilitar la recarga automática de módulos, utiliza la función ``track_changes`` como sigue (típicamente en un módulo, antes de cualquier import):
``
from gluon.custom_import import track_changes; track_changes(True)
``:code

De ahora en más, cada vez que un módulo se importe, la funcionalidad de importación revisará si el archivo de código fuente (.py) ha cambiado. Si se detectan cambios, se cargará el módulo nuevamente. Esto es válido para todos los módulos de Python fuera de web2py. El modo es global y se verifica para todas las aplicaciones. Los cambios realizados en modelos, controladores y vistas siempre se vuelven a cargar sin importar el modo en uso. Para deshabilitar este modo, usa la misma función pero con ``False`` como argumento. Para conocer el estado actual de la verificación, utiliza la función ``is_tracking_changes()``, también en `gluon.custom_import``.

Los módulos que importan ``current`` tienen acceso a:

- ``current.request``
- ``current.response``
- ``current.session``
- ``current.cache``
- ``current.T``

y a cualquier otra variable que tu aplicación decida almacenar en current. Por ejemplo un modelo podría hacer esto:

``
auth = Auth(db)
from gluon import current
current.auth = auth
``

y ahora todos los módulos importados tienen acceso a
- ``current.auth``

``current`` e ``import`` proveen de un poderoso mecanísmo para crear módulos ampliables y reutilizables para tus aplicaciones.

-------
Hay un detalle importante a tener en cuenta. Dado un ``from gluon import current``, es correcto el uso de ``current.request`` o cualquiera de los demás objetos locales del hilo pero uno nunca debería pasarlos a variables globales en el módulo, como en

``
request = current.request # ¡INCORRECTO! ¡PELIGRO!
``
ni debería pasarlos a atributos de clase
``
class MyClass:
    request = current.request # ¡INCORRECTO! ¡PELIGRO!
``
Esto se debe a que los objetos locales del hilo deben extraerse en tiempo de ejecución. Las variables globales, en cambio, se definen una sóla vez cuando el modelo se importa inicialmente.
-------


### ``request``
``request``:inxx ``Storage``:inxx ``request.cookies``:inxx ``user_agent``:inxx

El objeto ``request`` es una instancia de la clase omnipresente llamada ``gluon.storage.Storage``, que extiende la clase ``dict`` de Python. Básicamente se trata de un diccionario, pero los valores de cada ítem también pueden obtenerse como atributos:
``
request.vars
``:code

es lo mismo que:
``
request['vars']
``:code

A diferencia de un diccionario, si un atributo (o clave) no existe, Storage no genera una excepción: en su lugar devuelve ``None``.

-----
A veces es de utilidad crear nuestros propios objetos Storage. Puedes hacerlo de la siguiente forma:
``
from gluon.storage import Storage
mi_storage = Storage() # objeto Storage vacío
mi_otro_storage = Storage(dict(a=1, b=2)) # convertir un diccionario a Storage
``:code
-----

``request`` tiene los siguientes ítem/atributos, de los cuales algunos son también instancias de la clase ``Storage``:
- ``request.cookies``: un objeto ``Cookie.SimpleCookie()`` que contiene los cookie pasados con la solicitud HTTP. Se comporta como un diccionario compuesto por cookie. Cada cookie es un objeto Morsel.
- ``request.env``: un objeto ``Storage`` que contiene las variables de entorno pasadas al controlador, incluyendo las variables del encabezado HTTP de la solicitud y los parámetros WSGI estándar. Las variables de entorno se convierten a minúsculas, y los puntos se convierten a sub-guiones para mejorar la memorización.
- ``request.application``: el nombre de la aplicación solicitada (extraída de ``request.env.path_info``).
- ``request.controller``: el nombre del controlador solicitado (extraído de ``request.env.path_info``).
- ``request.function``: el nombre de la función solicitada (extraída de ``request.env.path_info``).
- ``request.extension``: la extensión de la acción solicitada. Por defecto es "html". Si la función del controlador devuelve un diccionario y no especifica una vista, esto es usado para determinar la extensión del archivo de la vista que convertirá (render) el diccionario (extraída de ``request.env.path_info``).
- ``request.folder``: el directorio de la aplicación. Por ejemplo si la aplicación es "welcome", ``request.folder`` se establece como la ruta absoluta "ruta/a/welcome". En tus programas, deberías usar siempre esta variable y la función ``os.path.join`` para obtener rutas a los archivos que quieras manipular. Si bien web2py usa siempre rutas absolutas, es una buena práctica no cambiar explícitamente el directorio en uso (current working directory) sea cual sea, ya que no es una práctica segura para el trabajo con hilos (thread-safe).
- ``request.now``: un objeto``datetime.datetime`` que almacena la hora y la fecha de la solicitud actual.
- ``request.utcnow``: un objeto ``datetime.datetime`` que almacena la hora y fecha UTC de la solicitud actual.
- ``request.args``: Una lista de los componentes de la ruta de la URL que siguen después del nombre de la función del controlador; equivalente a ``request.env.path_info.split('/')[3:]``
- ``request.vars``: un objeto ``gluon.storage.Storage`` que contiene las variables de la consulta para HTTP GET y HTTP POST.
- ``request.get_vars``: un objeto ``gluon.storage.Storage`` que contiene sólo las variables de la consulta para HTTP GET.
- ``request.post_vars``: un objeto ``gluon.storage.Storage`` que contiene sólo las variables de la consulta para HTTP POST.
- ``request.client``: La dirección ip del cliente determinada por, si se detectó, ``request.env.http_x_forwarded_for`` o por ``request.env.remote_addr`` de lo contrario. Si bien esto es útil no es confiable porque el ``http_x_forwarded_for`` se puede falsificar.
- ``request.is_local``: ``True`` si el cliente está en localhost, ``False`` en su defecto. Debería de funcionar detrás de un proxy si el proxy soporta ``http_x_forwarded_for``.
- ``request.is_https``: ``True`` si la solicitud utiliza el protocolo HTTPS, ``False`` en su defecto.
- ``request.body``: un stream de archivo de sólo-lectura conteniendo el cuerpo de la solicitud HTTP. Esto se lee (parse) automáticamente para obtener el ``request.post_vars`` para luego devolverse a su estado inicial. Se puede leer con ``request.body.read()``.
- ``request.ajax`` es True si la función se llamó desde una solicitud tipo Ajax.
- ``request.cid`` es el ``id`` del componente que generó la solicitud Ajax (en caso de existir). Puedes leer más acerca de componentes en el Capítulo 12.
- ``request.restful`` este es un decorador nuevo y realmente útil que se puede usar para cambiar el comportamiento por defecto de una acción de web2py separando las solicitudes según GET/POST/PUSH/DELETE. Se tratará con cierto detalle en el Capítulo 10.
- ``request.user_agent()`` extrae (parse) el campo user_agent del cliente y devuelve la información en forma de diccionario. Es útil para la detección de dispositivos móviles. Utiliza "gluon/contrib/user_agent_parse.py" creado por Ross Peoples. Para ver como funciona, prueba incrustando el siguiente código en una vista:
``
{{=BEAUTIFY(request.user_agent())}}
``:code

- ``request.wsgi`` es un hook que te permite llamar a aplicaciones WSGI de terceros en el interior de las acciones

El último incluye:
- ``request.wsgi.environ``
- ``request.wsgi.start_response``
- ``request.wsgi.middleware``
su uso se trata al final de este Capítulo.

Como ejemplo, la siguiente llamada en un sistema típico:
``
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
``:code

resulta en el siguiente objeto ``request``:
``request``:inxx ``env``:inxx

----------
variable | value
request.application | examples
request.controller | default
request.function | index
request.extension | html
request.view | status
request.folder | applications/examples/
request.args | ['x', 'y', 'z']
request.vars | <Storage {'p': 1, 'q': 2}>
request.get_vars | <Storage {'p': 1, 'q': 2}>
request.post_vars | <Storage {}>
request.is_local | False
request.is_https | False
request.ajax | False
request.cid | None
request.wsgi | hook
request.env.content_length | 0
request.env.content_type | ````
request.env.http_accept | text/xml,text/html;
request.env.http_accept_encoding | gzip, deflate
request.env.http_accept_language | en
request.env.http_cookie | session_id_examples=127.0.0.1.119725
request.env.http_host | 127.0.0.1:8000
request.env.http_max_forwards | 10
request.env.http_referer | http://web2py.com/
request.env.http_user_agent | Mozilla/5.0
request.env.http_via | 1.1 web2py.com
request.env.http_x_forwarded_for | 76.224.34.5
request.env.http_x_forwarded_host | web2py.com
request.env.http_x_forwarded_server | 127.0.0.1
request.env.path_info | /examples/simple_examples/status
request.env.query_string | remote_addr:127.0.0.1
request.env.request_method | GET
request.env.script_name | ````
request.env.server_name | 127.0.0.1
request.env.server_port | 8000
request.env.server_protocol | HTTP/1.1
request.env.web2py_path | /Users/mdipierro/web2py
request.env.web2py_version | Version 1.99.1
request.env.web2py_runtime_gae | (opcional, se define sólo si se detectó GAE)
request.env.wsgi_errors | <open file, mode 'w' at >
request.env.wsgi_input | ````
request.env.wsgi_multiprocess | False
request.env.wsgi_multithread | True
request.env.wsgi_run_once | False
request.env.wsgi_url_scheme | http
request.env.wsgi_version | 10
--------

Según el servidor web, se establecerán unas u otras de las variables de entorno. Aquí nos basamos en el servidor wsgi incorporado Rocket. El conjunto de variables no difiere en mucho cuando se utiliza el servidor web Apache.

Las variables de ``request.env.http_*`` se extraen del encabezado HTTP de la solicitud.

Las variables de ``request.env.web2py_*`` no se extraen del entorno del servidor web, sino que son creadas por web2py en caso de que la aplicación necesite saber acerca de la versión y ubicación de web2py, y si está corriendo en el Google App Engine (porque algunas optimizaciones específicas podrían ser necesarias).

Se deben tener en cuenta además las variables de ``request.env.wsgi_*``, que son específicas del adaptador wsgi.

### ``response``
``response``:inxx
``response.body``:inxx
``response.cookies``:inxx
``response.download``:inxx
``response.files``:inxx
``response.flash``:inxx
``response.headers``:inxx
``response.meta``:inxx
``response.menu``:inxx
``response.postprocessing``:inxx
``response.render``:inxx
``response.status``:inxx
``response.stream``:inxx
``response.subtitle``:inxx
``response.title``:inxx
``response.toolbar``:inxx
``response.view``:inxx
``response.delimiters``:inxx
``response.js``:inxx
``response.write``:inxx
``response.include_files``:inxx
``response.include_meta``:inxx
``response.optimize_css``:inxx
``response.optimize_js``:inxx

``response`` es otra instancia de la clase ``Storage``, que contiene lo siguiente:

``response.body``: Un objeto ``StringIO`` en el que web2py escribe el cuerpo de la página devuelta. NUNCA MODIFIQUES ESTA VARIABLE.

``response.cookies``: es similar a ``request.cookies``, pero mientras el último contiene las cookie enviadas desde el cliente al servidor, el primero contiene las cookie enviados desde el servidor al cliente. La cookie de la sesión se maneja automáticamente.

``response.download(request, db)``:  un método usado para implementar la función del controladro que permite descargar los archivos subidos. ``request.download`` usa el último argumento en ``request.args`` para recuperar el nombre codificado del archivo (por ejemplo, el nombre del archivo generado cuando se subió al servidor y almacenado en el campo upload). Este método extrae el nombre del campo upload y el nombre de la tabla así como también el nombre del archivo original del nombre de archivo codificado. ``response.dowload`` recibe dos argumentos opcionales: ``chunk_size`` configura el tamaño en byte para streaming por partes (chunked streaming, por defecto es 64K), y ``attachments`` determina si el archivo descargado debería tratarse como attachment o no (por defecto ``True``). Ten en cuenta que ``response.download`` se usa específicamente para la descarga de archivos asociados a campos upload de la base de datos. Usa ``response.stream`` (ver abajo) para otras clases de descargas de archivos y streaming. Además, ten en cuenta que no es necesario el uso de p``response.download`` para examinar los archivos subidos a la carpeta static -- los archivos estáticos pueden (y deberían en general) examinarse directamente a través de su URL (por ejemplo, /app/static/files/miarchivo.pdf).

``response.files``: una lista de archivos .css, .js, .coffee, y .less asociados a la página. Se añadirán automáticamente en el encabezado de la plantilla general "layout.html" a través de la vista incluída "web2py_ajax.html". Para añadir nuevos archivos CSS, JS, COFFEE, o LESS, basta con agregarlos a la lista. Se detectan los archivos duplicados. El orden es relevante.

``response.include_files()`` genera etiquetas del encabezado html para incluir todos los archivos en ``response.files`` (utilizado por "views/web2py_ajax.html").

``response.flash``: optional parameter that may be included in the views. Normally used to notify the user about something that happened.

``response.headers``: un ``dict`` para los encabezados de la respuesta HTTP. web2py establece algunos encabezados por defecto, incluyendo "Content-Length", "Content-Type", y "X-Powered-By" (como web2py). Además, web2py establece el valor de los encabezados "Cache-Control", "Expires", y "Pragma" para prevenir el cacheado del lado del cliente, excepto para las solicitudes de archivos estáticos, para los cuales la opción de cacheado se habilita. Los encabezados que web2py establece se pueden sobreescribir o eliminar, y es posible añadir nuevos encabezados (por ejemplo, ``response.headers['Cache-Control'] = 'private'``). 

``response.menu``: parámetro opcional que se puede incluir en las vistas, normalmente para pasar un árbol de menús de navegación a la vista. Esto puede ser convertido (render) por el ayudante MENU.

``response.meta``: un objeto Storage (similar a un diccionario) que contiene meta-información opcional como ``response.meta.author``, ``.description``, y/o ``.keywords``. El contenido de cada variable meta se inserta automáticamente en la etiqueta ``META`` correspondiente a través del código en "views/web2py_ajax.html", que se incluye en "views/layout.html".

``response.include_meta()`` genera una cadena que incluye todos los encabezados ``response.meta`` serializados (usado por "views/web2py_ajax.html").

``response.postprocessing``: esta es una lista de funciones, vacías por defecto. Estas funciones se usan para filtrar el objeto response en la salida de una acción, antes de que la salida sea convertida (render) por la vista. Se podría utilizar para implementar el soporte de otros lenguajes de plantillas.

``response.render(view, vars)``: un método usado para llamar a la vista en forma explícita en el controlador. ``view`` es un parámetro opcional que especifica el nombre del archivo de la vista, ``vars`` es un diccionario de valores asignados a nombres que se pasan a la vista.

``response.session_file``: stream de archivo que contiene la sesión.

``response.session_file_name``: el nombre del archivo donde se guardará la sesión.

``response.session_id``: el id de la sesión actual. Se detecta automáticamente. NUNCA CAMBIES ESTA VARIABLE.

``response.session_id_name``: el nombre del cookie de sesión para la app actual. NUNCA CAMBIES ESTA VARIABLE.

``response.status``: el número entero del código de status HTTP que se pasa en la respuesta. Por defecto es 200 (OK).

``response.stream(file, chunk_size, request=request)``: cuando un controlador devuelve este objeto, web2py crea un stream con el contenido para el cliente en bloques del tamaño especificado en ``chunk_size``. El parámetro ``request`` es obligatorio para utilizar el inicio del paquete en el encabezado HTTP. Como se señala más arriba, ``response.download`` debería usarse para recuperar archivos almacenados a través del campo upload. Para otros casos se puede usar ``response.stream``, como el envío de un archivo temporario u objeto StringIO creado en el controlador. A diferencia de ``response.download``, ``response.stream`` no establece automáticamente el encabezado Content-Disposition, por lo que podrías necesitar hacerlo manualmente (por ejemplo, para especificar que una descarga es un attachment, y especificar el nombre del archivo). En todo caso, se establece el encabezado ``Content-Type`` (según la extensión en el nombre del archivo).

``response.subtitle``: parámetro opcional que se puede incluir en las vistas. Debería contener el subtítulo de la página.

``response.title``: parámetro opcional que se puede incluir en las vistas. Debería contener el título de la página y debería ser convertido (render) por el objeto HTML TAG del título en el encabezado.

``response.toolbar``: una función que te permite embeber una barra de herramientas en la página para depuración ``{{=response.toolbar()}}``. La barra de herramientas muestra las variables de request, response, sessiona y el tiempo de acceso a la base de datos para cada consulta.

``response._vars``: se puede acceder a esta variable solamente desde una vista, no en la acción. Contiene el valor devuelto por la acción a la vista.

``response.optimize_css``: se puede establecer como "concat,minify,inline" para concatenar, simplificar y alinear los archivos CSS incluidos con web2py.

``response.optimize_js``: se puede establecer como "concat,minify,inline" para concatenar, simplificar y alinear los archivos JavaScript incluidos con web2py.

``response.view``: el nombre de la plantilla que debe convertir (render) la página. Por defecto es:
``
"%s/%s.%s" % (request.controller, request.function, request.extension)
``:code

o, si este archivo no se encuentra:
``
"generic.%s" % (request.extension)
``:code

Cambia el valor de esta variable para modificar el archivo la vista asociado a una acción particular.

``response.delimiters`` por defecto ``('{{','}}')``. Te permite cambiar los delimitadores de código incrustado en las vistas.

``response.xmlrpc(request, methods)``: si un controlador devuelve este tipo de objeto, la función expone los métodos a través de XML-RPC``xmlrpc``:cite . Esta función es obsoleta ya que se ha implementado un mecanismo mejor y se detalla en el Capítulo 10.

``response.write(text)``: a method to write text into the output page body.

``response.js`` can contain Javascript Code. This code will be executed if and only if the response is received by a web2py component as discussed in Chapter 12.

Como ``response`` es un objeto ``gluon.storage.Storage``, se puede usar para almacenar otros atributos que quieras pasar a la vista. Si bien no hay una restricción técnicamente, lo recomendable es almacenar sólo las variables que se conviertan (render) en todas las páginas en la plantilla general ("layout.html").

De todos modos, es muy recomendable que el uso esté restringido a las variables que se listan aquí:
``
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
``:code

porque esto hará mucho más fácil la tarea de reemplazar el archivo "layout.html" que viene con web2py por otra plantilla, una que use las mismas variables.

Las versiones antiguas de web2py usaban  ``response.author`` en lugar de ``response.meta.author`` y la misma forma para el resto de los atributos meta.

### ``session``
``session``:inxx ``session.connect``:inxx ``session.forget``:inxx ``session.secure``:inxx
``session`` es otra instancia de la calse ``Storage``. Se puede almacenar cualquier cosa en ella, por ejemplo::
``
session.myvariable = "hola"
``:code

se puede recuperar más tarde:
``
a = session.mivariable
``:code

Siempre que el código se ejecute durante la misma sesión para el mismo usuario (suponiendo que el usuario no eliminó las cookie de la sesión y la sesión no venció).
Al ser ``session`` un objeto ``Storage``, el intento fallido de acceder a atributos o nombres no establecidos no genera una excepción: en su lugar devuelve ``None``.

El objeto session tiene tres métodos importantes. Uno es ``forget``:
``
session.forget(response)
``:code

Este le dice a web2py que no guarde la sesión. Este método debería usarse en los controladores cuyas acciones se llamen a menudo y no requieran el registro de la actividad del usuario.
``session.forget()`` impide la escritura del archivo session, sin importar si este se ha modificaco o no. ``session.forget(response)`` adicionalmente desbloquea y cierra el archivo de la sesión. Difícilmente necesites llamar a este método ya que las sesiones no se guardan cuando no han cambiado. Sin embargo, si la página hace múltiples solicitudes Ajax simultaneas, es buena idea que las acciones llamadas via Ajax utilicen ``session.forget(response)`` (siempre que la acción no necesite la sesión). De lo contrario, cada acción Ajax tendrá que esperar a la anterior a que se complete (y a que el archivo de la sesión se desbloquee) antes de continuar, haciéndose más lenta la descarga de la página. Ten en cuenta que las sesiones no se bloquean cuando se almacenan en la base de datos.

Otro método es:

``
session.secure()
``:code

que le dice a web2py que establezca la cookie de la sesión para que sea segura. Esto se debería configurar si la app corre sobre https. Al configurar la cookie de sesión como segura, el servidor le informa al navegador que no envíe la cookie de regreso al servidor a menos que la conexión sea sobre https.

El otro método es ``connect``:
``
session.connect(request, response, db, masterapp=None)
``:code

donde ``db`` es el nombre de una conexión a base de datos abierta (como las que genera la DAL). Esto le dice a web2py que queremos almacenar las sesiones en la base de datos y no en el sistema de archivos. ``session.connect`` se debe ubicar luego de ``db=DAL(...)``, pero antes que cualquier otro algoritmo que utilice la sesión, por ejemplo, la configuración inicial de ``Auth``.

web2py crea una tabla:
``
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
``:code

y almacena una sesión cPickleada en el campo ``session_data``.

La opción ``masterapp=None``, por defecto, le dice a web2py que intente recuperar una sesión existente para la aplicación con el nombre en ``request.application``, en la aplicación actual.

Si deseas que una o más aplicaciones compartan las sesiones, establece el valor de ``masterapp`` con el nombre de la aplicación maestro.

Puedes revisar el estado de tu aplicación en todo momento mostrando la salida de las variables del sistema ``request``, ``session`` y ``response``. Una forma de hacer esto es creando una acción especial:
``
def status():
    return dict(request=request, session=session, response=response)
``:code

#### Separando sesiones

Si almacenas las sesiones en sistemas de archivos y manejas una cantidad importante, el sistema de archivos puede convertirse un cuello de botella, una forma de resolver esto es la siguiente:
``
session.connect(request, response, separate=True)
``:code

Al establecer ``separate=True`` web2py almacenará las sesiones en la carpeta ``sessions/``pero en distintas subcarpetas de esa ruta. Cada subcarpeta se creará automáticamente. Las sesiones con el mismo prefijo se ubicarán en la misma carpeta. Nuevamente, ten en cuenta que esto se debe ejecutar antes de cualquier otro algoritmo que utilice el objeto session.

### ``cache``
``cache``:inxx ``cache.ram``:inxx ``cache.disk``:inxx
``cache`` es un objeto global que también está disponible en el entorno de ejecución de web2py. Tiene dos atributos:
- ``cache.ram``: el caché de la aplicación en la memoria principal.
- ``cache.disk``: el caché de la aplicación en el disco.
se pueden hacer llamadas a ``cache`` (callable), esto le permite ser usado como decorador para el caché de acciones y vistas.

El siguiente ejemplo guarda en caché la función ``time.ctime()`` en la RAM:
``
def cache_en_ram():
    import time
    t = cache.ram('tiempo', lambda: time.ctime(), time_expire=5)
    return dict(tiempo=t, link=A('clic aquí', _href=request.url))
``:code

La salida de ``lambda: time.ctime()`` se guarda en caché en RAM por 5 segundos. La cadena ``'tiempo'`` se usa como clave del caché.

El ejemplo siguiente guarda en caché la función ``time.ctime()`` en disco:
``
def cache_en_disco():
    import time
    t = cache.disk('tiempo', lambda: time.ctime(), time_expire=5)
    return dict(tiempo=t, link=A('clic aquí', _href=request.url))
``:code

La salida de ``lambda: time.ctime()`` se guarda en caché en el disco (usando el módulo shelve) por 5 segundos.

Ten en cuenta que el segundo argumento de ``cache.ram`` y ``cache.disk`` debe ser una función u objeto que admita llamadas (callable). Si quieres guardar en caché un objeto existente en lugar de devolver una función, puedes simplemente devolverlo por medio de una función lambda:
``
cache.ram('miobjeto', lambda: miobjeto, time_expire=60*60*24)
``:code

El próximo ejemplo guarda en caché la función ``time.ctime()`` tanto en RAM como en el disco:
``
def cache_en_ram_y_disco():
    import time
    t = cache.ram('tiempo', lambda: cache.disk('tiempo',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(tiempo=t, link=A('clic aquí', _href=request.url))
``:code

La salida de ``lambda: time.ctime()`` se guarda en caché en el disco (usando el módulo shelve) y luego en RAM por 5 segundos. web2py busca en el RAM primero y si no está allí busca en el disco. Si no está en RAM o en el disco, ``lambda: time.ctime()`` se ejecuta y se actualiza el caché. Esta técnica es de utilidad en un entorno de procesos múltiples (multiprocess). Los dos objetos tiempo no necesariamente deben ser iguales.

El siguiente ejemplo guarda en caché en RAM la salida de la función del controlador (pero no la vista):

``cache controller``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_del_controlador_en_ram():
    import time
    t = time.ctime()
    return dict(tiempo=t, link=A('clic aquí', _href=request.url))
``:code

El diccionario devuelto por ``cache_del_controlador_en_ram`` se guarda en caché dureante 5 segundos. Ten en cuenta que el resultado de un select de la base de datos no se puede guardar en caché sin una serialización previa. Una forma más apropiada es guardar el select de la base de datos directamente en caché por medio del argumento ``chache`` del método ``select``.

El siguiente ejemplo guarda en caché la salida de la función del controlador en el disco (pero no la vista):
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_del_controlador_en_disco():
    import time
    t = time.ctime()
    return dict(tiempo=t, link=A('clic para refrescar',
                              _href=request.url))
``:code

El diccionario devuelto por ``cache_del_controlador_en_disco`` se guarda en caché en el disco por 5 segundos. Recuerda que web2py no puede guardar en caché un diccionario que contenga objetos que no se puedan picklear.

Además es posible guardar la vista en el caché. El truco consiste en convertir (render) la vista en la función del controlador, para que el controlador devuelva una cadena. Esto se hace devolviendo ``response.render(d)``, donde ``d`` es el diccionario que queremos pasar a la vista. El siguiente ejemplo guarda en caché la salida de la función del controlador en RAM (incluyendo la vista convertida):

``cache view``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_de_controlador_y_vista():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('clic para refrescar', _href=request.url))
    return response.render(d)
``:code
``response.render(d)`` devuelve la vista convertida como cadena, que ahora se guarda en caché por 5 segundos. Esta es la mejor y la más rápida forma de usar el caché.

Ten en cuenta que ``time_expire`` se usa para comparar la hora actual con la hora en la que el objeto solicitado fue almacenado en caché por última vez. Esto permite a ``time_expire`` establecerse dinámicamente cuando se solicita un objeto en lugar en lugar de tomar un valor fijo cuando se guarda el objeto. Por ejemplo:
``
mensaje = cache.ram('mensaje', lambda: 'Hola', time_expire=5)
``:code

Ahora, supongamos que la siguiente llamada se hace 10 segundos después de la llamada de arriba:
``
mensaje = cache.ram('mensaje', lambda: 'Adiós', time_expire=20)
``:code

Como ``time_expire`` se establece en 20 segundos en la segunda llamada y sólo han transcurrido 10 segundos desde la primera vez que se ha guardado el mensaje, se recuperará el valor "Hola" de el caché, y no se actualizará con "Adiós". El valor de ``time_expire`` de 5 segundos en la primera llamada no tiene impacto en la segunda llamada.

Al configurar ``time_expire=0`` (o usando un valor negativo), se fuerza la actualización del ítem en caché (porque el tiempo transcurrido desde el último almacenamiento será siempre > 0), y si se configura ``time_expire=None`` se fuerza la recuperación del valor en caché, sin importar el tiempo transcurrido desde la última vez que se guardó (si ``time_expire`` es siempre ``None``, se impide efectivamente el vencimiento del ítem en caché).

Puedes borrar una o más variables de caché con
``cache clear``:inxx

``
cache.ram.clear(regex='...')
``:code

donde ``regex`` es una expresion regular (regular expression) que especifica todas las palabras que quieras eliminar del caché. También puedes eliminar un sólo ítem con:
``
cache.ram(clave, None)
``:code

donde ``clave`` es la palabra asociada al ítem en caché.

Además es posible definir otros mecanismos de caché como memcache. Memcache está disponible con ``gluon.contrib.memcache`` y se trata con más detalle en el Capítulo 14.

------
Ten cuidado con el caché porque usualmente trabaja en el nivel de la aplicación, no en el nivel de usuario. Si necesitas, por ejemplo, guardar en caché contenido específico del usuario, utiliza una clave que incluya el id de ese usuario.
------


### ``URL``
``URL``:inxx
La función ``URL`` es una de las más importantes de web2py. Genera URL de rutas internas para las acciones y los archivos estáticos.

Aquí hay un ejemplo:

``
URL('f')
``:code

se asocia (map) a

``
/[aplicación]/[controlador]/f
``:code

Ten en cuenta que la salida de la función ``URL`` depende del nombre de la aplicación actual, el controlador que se llamó y otros parámetros. web2py soporta URL mapping y URL mapping inverso. El URL mapping te permite redefinir el formato de las URL externas. Si usas la función ``URL`` para generar todas las URL internas, entonces los agregados o modificaciones no presentarán vínculos incorrectos (broken link) en el ámbito de la aplicación.

Puedes pasar parámetros adicionales a la función ``URL``, por ejemplo, palabras extra en la ruta del URL (arg) y variables de consulta (query variable):

``
URL('f', args=['x', 'y'], vars=dict(z='t'))
``:code

se asocia (map) a

``
/[aplicación]/[controlador]/f/x/y?z=t
``:code

Los atributos ``arg`` son leídos (parse), decodificados y finalmente almacenados automáticamente en ``request.args`` por web2py. De forma similar ocurre con las variables de consulta que se almacenan en ``request.vars``.
``args`` y ``vars`` proveen de un mecanismo básico usado por web2py para el intercambio de información con el navegador cliente.

Si args contiene sólo un elemento, no hace falta que se pase como lista.

Además puedes usar la función ``URL`` para generar las URL de acciones en otros controladores o aplicaciones:

``
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
``:code

se asocia (map) a

``
/a/c/f/x/y?z=t
``

Además es posible especificar una aplicación, controlador y función usando argumentos con nombre (named argument):

``
URL(a='a', c='c', f='f')
``:code

Si no se especifica el nombre de la aplicación se asume la app actual.

``
URL('c', 'f')
``:code

If the controller name is missing, the current one is assumed.

``
URL('f')
``:code

En lugar de pasar el nombre de una función del controlador también es posible pasar la función en sí

``
URL(f)
``:code

Por las razones expuestas más arriba, deberías utilizar siempre la función ``URL`` para generar los URL de archivos estáticos para tus aplicaciones. Los archivos estáticos se almacenana en la subcarpeta ``static`` de la aplicación (es ese el lugar que se les asigna cuando se suben a través de la interfaz administrativa). web2py provee de un controlador virtual 'static' que tiene la tarea de recuperar los archivos de la subcarpeta ``static``, determinar su tipo de contenido, y crear el stream del archivo para el cliente. El siguiente ejemplo genera una URL para la imágen estática "imagen.png":

``
URL('static', 'imagen.png')
``:code

se asocia (map) a

``
/[aplicación]/static/imagen.png
``:code

Si la imagen estática está en una subcarpeta incluida en la carpeta ``static``, puedes incluir la/s subcarpeta/s como parte del nombre del archivo. Por ejemplo, para generar:

``
/[aplicación]/static/imagenes/iconos/flecha.png
``

uno debería usar:

``
URL('static', 'imagenes/iconos/flecha.png')
``:code

No es necesario que codifiques o escapes los argumentos en ``args`` o ``vars``; esto se realiza automáticamente por tí.

Por defecto, la extensión correspondiente a la solicitud actual (que se puede encontrar en ``request.extension``) se agrega a la función, a menos que request.extension sea html, el valor por defecto. Este comportamiento se puede sobreescribir incluyendo explícitamente una extensión como parte del nombre de la función ``URL(f='nombre.ext')`` o con el argumento extension:
``
URL(..., extension='css')
``:code

La extensión actual se puede omitir explícitamente:
``
URL(..., extension=False)
``:code

#### Absolute urls

Por defecto, ``URL`` genera URL relativas. Sin embargo, puedes además generar URL absolutas especificando los argumentos ``scheme`` y ``host`` (esto es de utilidad, por ejemplo, cuando se insertan URL en mensajes de email):

``
URL(..., scheme='http', host='www.misitio.com')
``:code

Puedes incluir automáticamente el scheme y host de la solicitud corriente simplemente estableciendo los argumentos como ``True``.

``
URL(..., scheme=True, host=True)
``:code

La función ``URL`` además acepta un argumento ``port`` para especificar el puerto del servidor si es necesario.

#### URL con firma digital
``digitally signed URL``:inxx

Cuando generas una URL, tienes la opción de firmarlas digitalmente. Esto añadirá una variable ``_signature`` tipo GET que se puede ser verificada por el servidor. Esto se puede realizar de dos formas distintas.

Puedes pasar los siguientes argumentos a la función URL:
- ``hmac_key``: la clave para la firma dle URL (una cadena)
- ``salt``: una cadena opcional para utilizar la técnica salt antes de la firma
- ``hash_vars``: una lista opcional de nombres de variables de la cadena de la consulta URL (query string variables, por ejemplo, variables GET) a incluir en la firma. También se puede establecer como ``True`` (por defecto) para incluir todas las variables, o ``False`` para no variables.

Aquí se muestra un ejemplo de uso:

``
KEY = 'miclave'

def uno():
    return dict(link=URL('dos', vars=dict(a=123), hmac_key=KEY))

def dos():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # hacer algo
    return locals()
``:code

Esto hace que se pueda acceder a la acción ``dos`` sólo por medio de una URL firmada digitalmente. Una URL firmada digitalmente se ve así:
``
'/welcome/default/dos?a=123&_signature=4981bc70e13866bb60e52a09073560ae822224e9'
``

Ten en cuenta que la firma digital se verifica a través de la función ``URL.verify``. ``URL.verify`` además toma los parámetros ``hmac_key``, ``salt``, y ``hash_vars`` descriptos anteriormente, y sus valores deben coincidir con los que se pasaron a la función ``URL`` cuando se creó la firma digital para poder verificar la URL.

Una segunda forma más sofisticada y más usual de URL firmadas digitalmente es la combinación con Auth. Esto se explica más fácilmente por medio de un ejemplo:

``
@auth.requires_login()
def uno():
    return dict(link=URL('dos', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def dos():
    # hacer algo
    return locals()
``:code

En este caso la ``hmac_key`` se genera automáticamente y se comparte en la sesión. Esto permite que la acción ``dos`` delegue todo control de acceso a la acción ``uno``. Si se genera el link y se firma, este es válido; de lo contrario no lo es. Si otro usuario se apropia del link, este no será válido.

Es una buena práctica la firma digital de todo callback de Ajax. Si usas la función ``LOAD``, esta también tiene un argumento ``user_signature`` que se puede usar con ese fin:

``
{{=LOAD('default', 'dos', vars=dict(a=123), ajax=True, user_signature=True)}}
``

### ``HTTP`` y ``redirect``
``HTTP``:inxx ``redirect``:inxx

web2py define sólo una excepción llamada ``HTTP``. Esta excepción se puede generar en cualquier parte de un modelo, controlador o vista con el comando:

``
raise HTTP(400, "mi mensaje")
``:code

Esto hace que el flujo del control (control flow) se salga del código del usuario, de vuelta a web2py y que devuelva una respuesta HTTP como esta:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

mi mensaje
``:code

El primer argumento de ``HTTP`` es el código de estado HTTP. El segundo argumento es la cadena que se devolverá como cuerpo de la respuesta. Se pueden pasar otros argumentos por nombre adicionales para crear el encabezado de la respuesta HTTP.
Por ejemplo:
``
raise HTTP(400, 'mi mensaje', test='hola')
``:code

genera:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hola

mi mensaje
``:code

Si no deseas aplicar los cambios (commit) de la transacción abierta de la base de datos, puedes anularlos (rollback) antes de generar la excepción.

Toda excepción que no sea ``HTTP`` hace que web2py anule (rollback) toda transacción de base de datos abierta, registre el error, envíe un ticket al visitante y devuelva una página de error estándar.

Esto significa que el flujo de control entre páginas sólo es posible con ``HTTP``. Las otras excepciones se deben manejar en la aplicación, de lo contrario, web2py generará un ticket.

El comando:
``
redirect('http://www.web2py.com')
``:code

es básicamente un atajo de:
``
raise HTTP(303,
           'Estás siendo redirigido a esta <a href="%s">página web</a>' % ubicacion,
           Location='http://www.web2py.com')
``:code

Los argumentos por nombre del método de inicialización ``HTTP`` se traducen en directivas de encabezado HTTP, en este caso, la ubicación de destino de la redirección (target location). ``redirect`` toma un segundo argumento opcional, que es el código de estado HTTP para la redirección (por defecto 303). Para una redirección temporaria cambia ese valor a 307 o a 301 para una redirección permanente.

La forma más usual para redirigir es la redirección a otras páginas en la misma app y (opcionalmente) pasar parámetros:

``
redirect(URL('index', args=(1,2,3), vars=dict(a='b')))
``:code

En el Capítulo 12 trataremos sobre los componentes de web2py. Ellos hacen solicitudes Ajax a acciones de web2py. Si la acción llamada hace un redirect, podrías necesitar que la solicitud Ajax siga la redirección o que la página completa cambie de dirección. Para el último caso, se puede establecer:

``
redirect(...,type='auto')
``:code


### ``T`` e Internacionalización
``T``:inxx ``internationalization``:inxx

El objeto ``T`` es el traductor de idiomas. Se compone de una única instancia global de la clase de web2py ``gluon.language.translator``. Todas las cadenas fijas (string constants, y sólo ellas) deberían marcarse con ``T``, por ejemplo:
``
a = T("hola mundo")
``:code

Las cadenas que se marcan con ``T`` son detectadas por web2py como traducibles y se traducirán cuando el código (en el modelo, controlador o vista) se ejecuta. Si la cadena a traducir no es constante, sino que es variable, se agregará al archivo de traducción en tiempo de ejecución (runtime, salvo en GAE) para su traducción posterior.

El objeto ``T`` también admite interpolación de variables y soporta múltiples sintaxis equivalentes:
``
a = T("hola %s", ('Tim',))
a = T("hola %(nombre)s", dict(nombre='Tim'))
a = T("hola %s") % ('Tim',)
a = T("hola %(nombre)s") % dict(nombre='Tim')
``:code

La última de las sintaxis es la recomendada porque hace la traducción más fácil.
La primera cadena se traduce según el archivo de idioma solicitado y la variable ``nombre`` se reemplaza independientemente del idioma.

Es posible la concatenación de cadenas traducidas y cadenas normales:
``
T("bla ") + nombre + T("bla")   # correcto!
``:code

pero no al revés:

``
nombre + T(" bla")   # ¡incorrecto!
``:code

El siguiente código también está permitido y con frecuecia es preferible:

``
T("bla %(nombre)s bla", dict(nombre='Tim'))
``:code

o la sintaxis alternativa
``
T("bla %(nombre)s bla") % dict(nombre='Tim')
``:code

En ambos casos la traducción ocurre antes de que la variable nombre sea sustituida en la ubicación de "%(nombre)s". La alternativa siguiente NO SE DEBERÍA USAR:
``
T("bla %(nombre)s bla" % dict(nombre='Tim'))
``:code

porque la traducción ocurriría después de la sustitución.

El lenguaje solicitado se determina con el campo "Accepted-Language" en el encabezado HTTP, pero esta opción se puede sobreescribir programáticamente solicitando un archivo específico, por ejemplo:
``
T.force('it-it')
``:code

que lee el archivo de idioma "languages/it-it.py". Los archivos de idiomas se pueden crear y editar a través de la interfaz administrativa.

Además puedes forzar el uso de un idioma para cada cadena:

``
T("Hola Mundo", language="it-it")
``:code

Puedes deshabilitar las traducciones completamente por medio de

``
T.force(None)
``:code

Normalmente, las traducciones de cadenas se evalúan con pereza (lazily) cuando se convierte (render) la vista; por lo tanto, no se debería usar ``force`` dentro de una vista.

Es posible deshabilitar la evaluación perezosa con
``
T.lazy = False
``:code

De esta forma, las cadenas se traducen de inmediato con el operador ``T`` según el idioma establecido o forzado.

Además se puede deshabilitar la evaluación perezosa para cadenas individuales:

``
T("Hola Mundo", lazy=False)
``:code

El siguiente es un problema usual. La aplicación original está en Inglés. Supongamos que existe un archivo de traducción  (por ejemplo en Italiano, "it-it.py") y el cliente HTTP declara que acepta tanto Inglés como Italiano en ese orden. Ocurre la siguiente situación inesperada: web2py no sabe que por defecto la app se escribió en Inglés (en). Por lo tanto, prefiere traducir todo al Italiano (it-it) porque únicamente detectó el archivo de traducción al Italiano. Si no hubiera encontrado el archivo "it-it.py", hubiese usado las cadenas del idioma por defecto (Inglés).

Hay dos soluciones posibles para este problema: crear el archivo de traducción al Inglés, que sería algo redundante e innecesario, o mejor, decirle a web2py qué idiomas deberían usar las cadenas del idioma por defecto (las cadenas escritas en la aplicación). Esto se hace con:
``
T.set_current_languages('en', 'en-en')
``:code

Esto almacena una lista de idiomas en ``T.current_languages`` que no necesitan traducción y fuerza la recarga de los archivos de idiomas.

Ten en cuenta que "it" e "it-it" son idiomas diferentes desde el punto de vista de web2py. Para dar soporte para ambos, uno necesitaría dos archivos de traducción, siempre en minúsculas. Lo mismo para los demás idiomas.

El idioma aceptado actualmente se almacena en
``
T.accepted_language
``:code

Observa que T(...) no sólo traduce las cadenas sino que además puede traducir variables:
``
>>> a="test"
>>> print T(a)
``:code

En este caso se traduce la palabra "test" pero, si no se encuentra y el sistema de archivos permite la escritura, se agregará a la lista de palabras a traducir en el archivo del idioma.

### ''Cookies''
``cookies``:inxx

web2py utiliza los módulos de Python para el manejo de las cookie.

Las cookie del navegador se encuentran en ``request.cookies`` y las cookie enviadas por el servidor están en ``response.cookies``.

Puedes crear valores de cookie de la siguiente forma:
``
response.cookies['mycookie'] = 'unvalor'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
``:code

La segunda linea le dice al navegador que conserve la cookie por 24 horas. La tercer línea le dice al navegador que envíe una cookie de regreso a cualquier aplicación en el dominio actual (ruta URL). Ten en cuenta que si no especificas la ruta para la cookie, el navegador se configurará con la ruta del URL que se solicitó, por lo que la cookie sólo se enviará de regreso al servidor cuando se solicite la misma ruta URL.

La cookie se puede hacer segura con:
``
response.cookies['mycookie']['secure'] = True
``:code

Esto le dice al navegador que sólo devuelva la cookie sobre HTTPS, no sobre HTTP.

La cookie se puede recuperar con:
``
if request.cookies.has_key('mycookie'):
    valor = request.cookies['mycookie'].value
``:code

A menos que se deshabiliten las sesiones, web2py, como proceso interno, establece la siguiente cookie, que usa para el manejo de sesiones:
``
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
``:code

Ten en cuenta que si una aplicación determinada incluye subdominios múltiples, y quieres compartir las sesiones a través de esos subdominios (por ejemplo, sub1.tudominio.com, sub2.tudominio.com, etc.), debes establecer explícitamente el dominio de la cookie de sesión de esta forma:
``
if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".tudominio.com"
``:code

El comando descripto arriba puede ser útil si, por ejemplo, quisieras permitir al usuario que permanezca autenticado para distintos dominios.


### La aplicación **init**
``init``:inxx

Cuando desplieges (deploy) web2py, querrás establecer una aplicación por defecto, por ejemplo, la aplicación que se inicia cuando hay una ruta vacía en la URL, como en:
``
http://127.0.0.1:8000
``:code

Por defecto, cuando web2py se encuentra con una ruta vacía, busca una aplicación llamada **init**. Si no hay una aplicación init buscará una aplicación llamada **welcome**.

``default_application``:inxx
El nombre de la apliación por defecto se puede cambiar de **init** a otro nombre estableciendo el valor de ``default_application`` en routes.py:
``
default_application = "miapp"
``:code

Ten en cuenta que ``default_first`` se agregó en la versión 1.83 de web2y.

Aquí mostramos cuatro formas de establecer la aplicación por defecto:
- Establecer el nombre de la aplicación por defecto como "init".
- Establecer ``default_application`` con el nombre de la aplicación en routes.py
- Hacer un link simbólico de "applications/init" a la carpeta de la aplicación.
- Usar la reescritura de URL como se detalla en la próxima sección.

### Rescritura de URL
``url rewrite``:inxx
``routes_in``:inxx
``routes_out``:inxx

web2py tiene la habilidad de reescribir la ruta de la URL para solicitudes entrantes antes de llamar a la acción en el controlador (mapeo de URL o URL mapping), y en el otro sentido, web2py puede reescribir la ruta de la URL generada por la función ``URL`` (mapeo reverso de URL o reverse URL mapping). Una de las razones para esto es para el soporte de las URL heredadas (legacy), otra razón es la posibilidad de simplificar las rutas y hacerlas más cortas.

web2py incluye dos sistemas de reescritura de URL: un sistema basado en parámetros de fácil uso para la mayor parte de los casos posibles, y un sistema basado en patrones para los casos más complicados. Para especificar las reglas de reescritura de URL, crea un archivo nuevo en la carpeta "web2py" llamada ``routes.py`` (el contenido de ``routes.py`` dependerá del sistema de reescritura que elijas, como se describe en las siguientes secciones). Los dos sistemas no se pueden mezclar.

-------
Observa que si editas routes.py, debes volver a cargarlo. Esto se puede hacer en dos formas: reiniciando el servidor web o haciendo clic en el botón para cargar nuevamente routes en admin. Si hay un fallo en routes, no se recargará.
-------

#### Sistema basado en parámetros

El sistema basado en parámetros (paramétrico) provee de un acceso fácil a muchos métodos "enlatados". Entre sus posibilidades se puede enumerar:

* Omitir los nombres de la aplicación, controlador y función por defecto en las URL visibles desde afuera (las creadas por la función URL())

* Asociar (map) dominios (y/o puertos) a controladores de aplicaciones

* Embeber un selector de idioma en la URL

* Eliminar un prefijo determinado de las URL entrantes y añadirlo nuevamente a las URL salientes

* Asociar (map) archivos de la raíz como /robots.txt a un directorio estático de la aplicación

El router paramétrico también provee de una forma más flexible de validación para las URL entrantes.

Digamos que has creado una aplicación llamada ``miapp`` y deseas que sea la aplicación por defecto, de forma que el nombre de la aplicación no forme parte de la URL cuando la ve el usuario. Tu controlador por defecto sigue siendo ``default``, y también quieres eliminar su nombre de la URL que ve el usuario. Esto es entonces lo que debes poner en ``routes.py``:
``
routers = dict(
  BASE  = dict(default_application='miapp'),
)
``:code

Y eso es todo. El router paramétrico es lo suficientemente inteligente para hacer lo correcto con una URL como:
``
http://dominio.com/myapp/default/miapp
``:code
o
``
http://dominio.com/myapp/miapp/index
``:code
donde el acortamiento normal sería ambiguo. Si tienes dos aplicaciones, ``miapp``y ``miapp2``, obtendrás el mismo efecto, y adicionalmente, el controlador por defecto de ``miapp2`` se recortará de la URL cuando sea seguro (que es lo normal casi siempre).

Aquí hay otro caso: digamos que quieres dar soporte para lenguajes basados en URL, donde las URL son algo así:
``
http://miapp/es/una/ruta
``:code
o (reescrita)
``
http://es/una/ruta
``:code

Esta es la forma de hacerlo:
``
routers = dict(
  BASE  = dict(default_application='miapp'),
  miapp = dict(languages=['en', 'it', 'jp'], default_language='es'),
)
``:code

Ahora una URL entrante como esta:
``
http:/dominio.com/it/some/path
``:code
se enrutará a ``/miapp/una/ruta``, y request.uri_language se establecerá como 'it', para que puedas forzar la traducción. Además puedes tener archivos estáticos específicos por idioma.

``
http://dominio.com/it/static/archivo
``:code
se asociará (map) a:
``
applications/miapp/static/it/archivo
``:code
si el archivo existe. Si no, entonces las URL como:
``
http://dominio.com/it/static/base.css
``:code
seguirán siendo asociadas a:
``
applications/miapp/static/base.css
``:code
(porque no hay ``static/it/base.css``).

Por lo que ya tenemos archivos estáticos por idioma, incluyendo imágenes, si es necesario. También está soportado el mapeo de dominio (domain mapping):
``
routers = dict(
  BASE  = dict(
      domains = {
          'dominio1.com' : 'app1',
          'dominio2.com' : 'app2',
      }
  ),
)
``:code

Su funcionamiento se puede deducir fácilmente del ejemplo.

``
routers = dict(
  BASE  = dict(
      domains = {
          'dominio.com:80'  : 'app/inseguro',
          'dominio.com:443' : 'app/seguro',
      }
  ),
)
``:code
asocia (map) los accesos a ``http://dominio.com`` con el controlador de nombre ``inseguro``, mientras que los accesos por ``HTTPS`` se redirigen al controlador ``seguro``. Alternativamente, puedes asociar (map) diferentes puertos a diferentes app, siguiendo el mismo ejemplo anterior.

Para mayor información, consulta el archivo [[``router.example.py`` http://code.google.com/p/web2py/source/browse/router.example.py]] que viene en la carpeta de la distribución estándar de web2py.

Nota: El sistema basado en parámetros apareció por primera vez en la versión 1.92.1.


#### Sistema basado en patrones

Si bien el sistema basado en parámetros recién descripto debería de ser suficiente para la mayor parte de los casos, el sistema alternativo basado en patrones provee de flexibilidad adicional para casos más complejos. Para usar el sistema basado en patrones, en lugar de definir los enrutadores como diccionarios con parámetros de enrutamiento, se definen dos listas (o tuplas) de pares (2-tuplas), ``routes_in`` y ``routes_out``. Cada tupla contiene dos elementos: el patrón a reemplazar y la cadena que lo reemplaza. Por ejemplo:
``
routes_in = (
  ('/pruebame', '/ejemplos/default/index'),
)
routes_out = (
  ('/ejemplos/default/index', '/pruebame'),
)
``:code

Con estas rutas, la URL:
``
http://127.0.0.1:8000/pruebame
``:code

es asociada a:
``
http://127.0.0.1:8000/ejemplos/default/index
``:code

Para el visitante, todos los link a
la URL de la página se ven como ``/pruebame``.

Los patrones tienen la misma sintaxis que las expresiones regulares de Python. Por ejemplo:
``
  ('.*\.php', '/init/default/index'),
``:code

asocia toda URL que termine en ".php" a la página de inicio.

El segundo término de una regla también puede ser una redirección a otra página:
``
  ('.*\.php', '303->http://ejemplo.com/nuevapagina'),
``:code

Aquí 303 es el código HTTP para la respuesta de redirección.

A veces queremos deshacernos del prefijo de la aplicación  en las URL porque queremos exponer sólo una aplicación. Esto es posible con:
``
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
``:code

También hay una sintaxis alternativa que se puede mezclar con la notación anterior de expresiones regulares. Consiste en usar ``$nombre`` en lugar de 
There is also an alternative syntax that can be mixed with the regular expression notation above. It consists of using ``$name`` instead of ``(?P<nombre>\w+)`` o ``\g<nombre>``. Por ejemplo:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
``:code

también elimina el prefijo de la aplicación en todas las URL.

Si usas la notación ``$nombre``, puedes asociar automáticamente ``routes_in`` a ``routes_out``, siempre y cuando no uses expresiones regulares. Por ejemplo:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
``:code

Si existen múltiples rutas, se ejecuta la primera que coincida con la URL, si no hay coincidencias en el patrón, no se hacen cambios a la ruta.

Puedes usar ``$anything`` para comparar con cualquier cadena (``.*``) hasta el final de línea.

Aquí mostramos una versión mínima de "routes.py" para el manejo de solicitudes de favicon y robot:

``favicon``:inxx ``robots``:inxx
``
routes_in = (
  ('/favicon.ico', '/ejemplos/static/favicon.ico'),
  ('/robots.txt', '/ejemplos/static/robots.txt'),
)
routes_out = ()
``:code

Este es un ejemplo más complejo que expone una sola app, "miapp", sin prefijos innecesarios y que además expone **admin**, **appadmin** y static:

``
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/miapp/static/$anything'),
  ('/appadmin/$anything', '/miapp/appadmin/$anything'),
  ('/favicon.ico', '/miapp/static/favicon.ico'),
  ('/robots.txt', '/miapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
``:code

La sintaxis general para routes es más compleja que los ejemplos básicos que hemos visto hasta ahora. Este es un ejemplo más general y representativo:
``
routes_in = (
 ('140\.191\.\d+\.\d+:https?://www.web2py.com:post /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
``:code

Asocia las solicitudes ``http`` o ``https`` ``POST`` (ten en cuenta el uso de minúsculas en "post") a la máquina en ``www.web2py.com`` desde una IP remota que coincide con la expresión regular
``
'140\.191\.\d+\.\d+'
``:code

la solicitud de una página que coincida con la expresión
``
'/(?P<any>.*)\.php'
``:code

en
``
'/test/default/index?vars=\g<any>'
``:code

donde ``\g<any>`` es reemplazada por la expresión regular que coincida

La sintaxis general es
``
'[dirección remota]:[protocolo]://[equipo (host)]:[método] [ruta]'
``:code

Si falta la primer sección del patrón (todo excepto ``[ruta]``, web2py la reemplaza con un valor por defecto:
``
'.*?:https?://[^:/]+:[a-z]+'
``:code

La expresión completa se compara como expresión regular, por lo que "." debe escaparse (escape) y toda subexpresión que coincida se puede capturar usando ``(?P<...>...)``, con la notación de expresión regular de Pyhton. El método de la solicitud (típicamente GET o POST) debe ser en minúsculas. Se reemplazó (unquote) toda cadena de tipo ``%xx`` en la URL a comparar.

Esto permite re-enrutar las solicitudes basadas en la IP o dominio del cliente, según el tipo de solicitud, tipo de método y ruta. Además permite que web2py asocie distintas máquinas virtuales (virtual host) a distintas aplicaciones. Toda subexpresión que coincida se puede usar para armar la URL de destino (target) y, eventualmente, puede ser pasada como variable GET.

Los servidores más conocidos, como Apache y lighttpd, tienen además la posibilidad de reescribir las URL. En un entorno de producción se podría optar por esa opción en lugar de ``routes.py``. Sea cual sea tu decisión, te recomendamos que no escribas "a mano" (hardcode) las URL internas en tu app y que uses la función URL para generarlas.
Esto hará tu aplicación más portátil en caso de que se realicen cambios en routes.


##### Reescritura de URL específica de una aplicación
``routes_app``:inxx
Al usar el sistema basado en patrones, una aplicación puede configurar sus propias rutas en un archivo específico routes.py ubicado en la carpeta base de la aplicación. Esto se habilita configurando ``routes.py`` en el archivo routes.py base para determinar en una URL entrante el nombre de la aplicación seleccionada. Cuando esto ocurre, se usa el routes.py específico de la aplicación en lugar del routes.py base.

El formato de ``routes_app`` es idéntico al de ``routes_in``, excepto que el patrón de reemplazo es simplemente el nombre de la aplicación. Si al aplicar ``routes_app`` a la URL entrante no devuelve un nombre de aplicación, o el routes.py específico de la aplicación no se encuentra, se utiliza el routes.py base.

Nota: ``routes_app```se agregó desde la versión 1.83 de web2py.

##### Aplicación, controlador y función por defecto

``default_application``:inxx
``default_controller``:inxx
``default_function``:inxx

Cuando se usa el sistema basado en patrones, el nombre de la aplicación, controlador y función por defecto se puede cambiar de **init**, **default**, e **index** respectivamente por otro nombre configurando el valor apropiado en routes.py:
``
default_application = "miapp"
default_controller = "admin"
default_function = "comienzo"
``:code

Nota: Estos ítem aparecieron por primera vez en la versión 1.83.

### Enrutamiento y errores
``routes_onerror``:inxx

También puedes usar ``routes.py`` para re-enrutar las solicitudes hacia acciones especiales en caso de que ocurra un error en el servidor. Puedes especificar el mapeo (mapping) en forma global, por aplicación, por código de error o por tipo de error para cada app. Un ejemplo:
``
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/falla.html'),
  ('*/404', '/init/static/noseencuentra.html'),
  ('*/*', '/init/error/index')
]
``:code

Por cada tupla, la primera cadena es comparada con "[nombre de app]/[código de error]". Si hay una coincidencia, la solicitud fallida se re-enruta hacia la URL de la segunda cadena de la tupla que coincide. Si la URL de manejo de errores no es un archivo estático, se pasarán a la acción del error las siguientes variables GET:
- ``code``: el código de status HTTP (por ejemplo, 404, 500)
- ``ticket``: de la forma "[nombre de app]/[número de ticket]" (o "None" si no hay un ticket)
- ``requested_uri``: el equivalente de ``request.env.request_uri``
- ``request_url``: el equivalente de ``request.url``

Estas variables serán accesibles para la acción de manejo de error por medio de ``request.vars`` y se pueden usar para generar la respuesta con el error. En particular, es buena idea que la acción del error devuelva el código original de error HTTP en lugar del código de status 200 (OK) por defecto. Esto se puede hacer configurando ``response.status = request.vars.code``. También es posible hacer que la acción del error envíe (o encole) un correo a un administrador, incluyendo un link al ticket en ``admin``.

Los errores que no coinciden mostrarán una página de error por defecto. Esta página de error por defecto también se puede personalizar aquí (ver ``router.example.py`` y ``routes.example.py`` en la carpeta raíz de web2py):
``
error_message = '<html><body><h1>%s</h1></body></html>'
error_message_ticket = '''<html><body><h1>Error interno</h1>
     Ticket creado: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
``:code

La primera variable contiene el mensaje de error cuando se solicita una apliación o función inválida. La segunda variable contiene el mensaje de error cuando se crea un ticket.

-------
``routes_onerror`` funciona con ambos mecanismos de enrutamiento
-------

### Ejecutando tareas en segundo plano

En web2py, cada solicitud http se sirve en un hilo (thread) propio. Los hilos se reciclan para mayor eficiencia y son administrados por el servidor web. Por seguridad, el servidor establece un tiempo límite para cada solicitud. Esto significa que las acciones no deberían correr tareas que toman demasiado tiempo, ni deberían crear nuevos hilos y tampoco deberían bifurcarse (fork) en otros procesos (esto es posible pero no recomendable).

La forma adecuada para correr tareas prolongadas es hacerlo en segundo plano. No hay una única forma de hacerlo, pero aquí describiremos tres mecanismos que vienen incorporados en web2py: **cron**, **colas de tareas simples**, y el **programador de tareas** (scheduler).

Con respecto a **cron**, nos referimos a una funcionalidad de web2py y no al mecanismo Cron de Unix. El cron de web2py funciona también en Windows.

El cron de web2py es el método recomendado si necesitas tareas en segundo plano en tiempos programados y estas tareas toman un tiempo relativamente corto comparado con el tiempo transcurrido entre dos llamadas. Cada tarea corre en su proceso propio, y las distintas tareas pueden ejecutarse simultáneamente, pero no tienes control sobre la cantidad de tareas que se ejecutan. Si por accidente una de las tareas se superpone con sí misma, puede causar el bloqueo de la base de datos y un pico en el uso de memoria.

El programador de tareas de web2py tiene una metodología distinta. La cantidad de procesos corriendo es fija y estos pueden correr en distintos equipos. Cada proceso es llamado obrero (worker). Cada obrero toma una tarea cuando está disponible y la ejecuta lo antes posible a partir del tiempo programado, pero no necesariamente en el momento exacto para el que se programó. No puede haber más procesos corriendo que el número de tareas programadas y por lo tanto no habrá picos del uso de memoria. Las tareas del programador se pueden definir en modelos y se almacenan en la base de datos. El programador de web2py no implementa una cola distribuida (distributed queue) porque se asume que el tiempo para la distribución de tareas es insignificante comparado con el tiempo para la ejecución de las tareas. Los obreros toman las tareas de la base de datos.

Las colas de tareas simples (homemade task queues) pueden ser una alternativa más simple al programador en algunos casos.

#### ''Cron''
``cron``:inxx

El cron de web2py provee a las aplicaciones de la habilidad para ejecutar tareas en tiempos preestablecidos, de forma independiente con la plataforma.

Para cada aplicación, la funcionalidad de cron se define en un archivo crontab:

``
app/cron/crontab
``

Este sigue la sintaxis definida en ref. ``cron``:cite (con algunos agregados que son específicos de web2py).

Esto significa que cada aplicación puede tener una configuración de cron propia y separada y que esta configuración se puede cambiar desde web2py sin modificar el sistema operativo en sí.

Aquí se muestra un ejemplo:
``
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/limpieza_db.py
*/30    *  *  *  *  root **applications/admin/cron/algo.py
@reboot root    *mycontroller/mifuncion
@hourly root    *applications/admin/cron/expire_sessions.py
``:code

Las últimas dos líneas en este ejemplo usan extensiones a la sintaxis normal de cron que dan funcionalidad adicional de web2py.

-------
El archivo "applications/admin/cron/expire_sessions.py" en realidad existe y viene con la app **admin**. Busca sesiones vencidas y las elimina. "applications/admin/cron/crontab" corre esta tarea cada hora.
-------

Si la tarea/script tiene el prefijo asterisco (``*``) y termina en ``.py``, se ejecuta en el entorno de web2py. Esto quiere decir que tendrás todos los controladores y modelos a tu disposición. Si usas dos asteriscos (``**``), los ``MODELO``s no se ejecutarán. Este es el método recomendado para los llamados, ya que tiene una menor sobrecarga (overhead) y evita potenciales problemas de bloqueo.

Ten en cuenta que los script o funciones ejecutadas en el entorno de web2py requieren un ``db.commit()`` manual al final de la función o la transacción se revertirá.

web2py no genera ticket o trazas (traceback) significativas en modo consola (shell), que es el modo en el cual corre cron, por lo que debes procurar que tu código de web2py corra sin errores antes de configurarlo como tarea de cron, ya que posiblemente no podrás ver esos errores cuando se ejecuten en cron. Es más, ten cuidado con el uso de modelos: mientras que la ejecución ocurre en procesos separados, los bloqueos de base de datos se deben tener en cuenta para evitar que las páginas tengan que esperar a tareas de cron que podrían bloquear la base de datos. Utiliza la sintaxis ``**`` si no necesitas acceso a la base de datos en tu tarea de cron.

Además puedes llamar a una función de controlador en cron, en cuyo caso no hay necesidad de especificar una ruta. El controlador y la función serán los de la aplicación de origen. Se debe tener especial cuidado con los problemas listados arriba. Ejemplo:
``
*/30  *  *  *  *  root *mycontroller/mifuncion
``:code

Si especificas ``@reboot`` en el primer campo del archivo crontab, la tarea correspondiente se ejecuta sólo una vez, al inicio de web2py. Puedes usar esta funcionalidad si deseas hacer caché previo, comprobaciones o configuración inicial de datos para una aplicación al inicio de web2py. Ten en cuenta que las tareas de cron se ejecutan en paralelo con la aplicación --- si la aplicación no está lista para servir solicitudes antes de que la tarea cron haya finalizado, deberías implementar las comprobaciones adecuadas. Ejemplo:
``
@reboot  *  *  *  *  root *mycontroller/mifuncion
``:code

Según cómo estés corriendo web2py, hay cuatro modos de operación para el web2py cron.
- "soft cron": disponible en todos los modos de ejecución
- "hard cron": disponible si se usa el servidor web incorporado (directamente o a través de mod_proxy de Apache)
- "external cron": disponible si se tiene acceso al servicio de cron propio del sistema
- Sin cron

El modo por defecto es hard cron si utilizas el servidor incorporado; en el resto de los casos, es soft cron por defecto. El soft cron es el método por defecto si utilizas CGI, FASTCGI o WSGI (pero ten en cuenta que el soft cron no se ``habilita`` por defecto en el archivo ``wsgihandler.py`` provisto con web2py).

Tus tareas se ejecutarán al realizarse la primer llamada (carga de página) a web2py a partir de tiempo especificado en crontab; pero sólo luego del proceso de la página, por lo que el usuario no observará una demora. Obviamente, hay cierta incertidumbre con respecto al momento preciso en que se ejecutará la tarea, según el tráfico que reciba el servidor. Además, la tarea de cron podría interrumpirse si el servidor web tiene configurado un tiempo límite para la descarga de la página. Si estas limitaciones no son aceptables, puedes optar por "external cron" (cron externo). El soft cron es un útlimo recurso razonable, pero si tu servidor permite otros métodos cron, deberían tener prioridad.

El hard cron es el método por defecto si estás utilizando el servidor web incorporado (directamente o a través de Apache con mod_proxy). El hard cron se ejecuta en un hilo paralelo, por lo que a diferencia del soft cron, no existen limitaciones con respecto a la precisión en el tiempo o a la duración de la ejecución de la tarea.

El cron externo no es la opción por defecto en ninguna situación, pero requiere que tengas acceso a los servicios cron del sistema. Se ejecuta en un proceso paralelo, por lo que ninguna de las limitaciones de soft cron tienen lugar. Este es el modo recomendado de uso de cron bajo WSGI o FASTCGI.

Ejemplo de línea a agregar al crontab del sistema, (por lo general /etc/crontab):
``
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -J -C -D 1 >> /tmp/cron.output 2>&1
``:code

Si corres el cron externo, asegúrate de agregar el parámetro de línea de comandos -N a tu script de inicio de web2py o archivo de configuración para que no se produzcan colisiones con distintos tipos de cron. Además, con ``cron`` externo, asegúrate de agregar o bien ``-J`` o ``--cronjob``, que es lo mismo, como se indica arriba para que web2py sepa que esa tarea es ejecutada por cron. web2py establece esta opción internamente con soft y hard ``cron``.

En casos en los que no necesitas ninguna funcionalidad cron para un proceso particular, puedes usar el parámetro de línea de comandos -N para deshabilitarlo. Ten en cuenta que esto podría deshabilitar algunas tareas de mantenimiento (por ejemplo la limpieza automática de las carpetas de sesión). El uso más corriente de esta función es cuando:
- has configurado previamente un cron externo iniciado desde el sistema (comúnmente con la configuración de WSGI).
- quieres depurar tu aplicación sin que cron interfiera en las acciones o en la salida.

#### Colas de tareas simples

Si cron es útil para correr tareas en intervalos regulares de tiempo, no es siempre la mejor solución para correr tareas en segundo plano. Para este caso web2py provee la posibilidad de correr cualquier script de Python como si estuviera dentro de un controlador:
``
python web2py.py -S app -M -N -R applications/app/private/miscript.py -A a b c
``:code

donde ``-S app`` le dice a web2py que corra "miscript.py" como "app", ``-M`` le dice a web2py que ejecute los modelos, ``-N`` indica que no se debe correr cron, y ``-A a b c`` le pasa los argumentos opcionales de línea de comandos ``sys.args=['a', 'b', 'c']`` a "miscript.py".

Este tipo de proceso en segundo plano no debería ejecutarse con cron (a excepción quizás de cron y la opción @reboot) porque necesitas asegurarte de que no se correrá más de una instancia al mismo tiempo. Con cron es posible que un proceso comience en la iteración 1 y no se complete para la iteración 2, por lo que cron vuelve a comenzar, y nuevamente, y otra vez - atascando de este modo el servidor.

En el capitulo 8, damos un ejemplo de cómo usar el método anterior para enviar email.

#### Programador de tareas (Scheduler, experimental)

El programador de tareas de web2py funciona en forma muy similar a la cola de tareas descripta en la sub-sección anterior con algunas particularidades:
- Provee de un mecanismo estándar para crear y programar tareas.
- No hay un único proceso en segundo plano sino un conjunto de procesos obreros.
- El trabajo de un obrero se puede supervisar porque sus estados, así como también los estados de cada tarea, se almacenan en la base de datos.
- Funciona sin web2py pero los detalles no están documentados aquí.

El programador no usa cron, sin embargo se podría usar el @reboot de cron para iniciar los nodos de los obreros.

En el programador, una tarea es simplemente una función definida en un modelo (o en un módulo e importada en un modelo). Por ejemplo:

``
def agregar_tarea(a,b):
    return a+b
``:code

Las tareas siempre se llamarán en el mismo entorno configurado para los controladores y por lo tanto ven todas las variables globales definidas en los modelos, incluyendo las conexiones a bases de datos (``db``). Las tareas se diferencian de las acciones en controladores en que no están asociadas con una solicitud HTTP y por lo tanto no hay un objeto ``request.env``.

Una vez que se han definido las tareas, necesitas habilitar el programador agregando el siguiente código en tu modelo:

``
miprogramador = Scheduler(db, dict(agregar_tarea=agregar_tarea))
``

El primer argumento de la clase ``Scheduler`` debe ser la base de datos a usar por el programador para comunicarse con los obreros. Esta puede ser la ``db`` de la app u otra ``db`` dedicada para el programador, quizás una compartida por múltiples app. El Scheduler crea las tablas que necesita. El segundo argumento es un diccionario de Python de pares ``clave:valor`` donde ``clave`` es el nombre que quieres usar para exponer una tarea, y ``valor`` es el nombre real de la función que define la tarea.

Una vez que las tareas se han definido y el ``Scheduler`` se ha instanciado, sólo hace falta iniciar los obreros:
``
python web2py.py -K miapp
``

La opción ``-K`` comienza un obrero. El argumento de la opción ``-K`` es una lista de nombres de app, separadas por comas. Estas son las app para las que operará este obrero. Se pueden iniciar múltiples obreros.

Ahora tenemos la infraestructura preparada: definimos las tareas, se las informamos al programador, iniciamos los obreros. Lo que resta es programar las tareas en sí:

Las tareas se pueden crear en forma programática o a través de appadmin. De hecho, una tarea se programa simplemente agregando un registro en la tabla "scheduler_task", que se puede administrar con appadmin.:
``
http://127.0.0.1:8000/scheduler/appadmin/insert/db/scheduler_task
``

El significado de los campos en esta tabla es obvio. Los campos "args" y "vars" son los valores que se pasan a la tarea en formato JSON. En el caso de "agregar_tarea" de más arriba, un ejemplo de "args" y "vars" podría ser:
``
args = [3, 4]
vars = {}
``

o

``
args = []
vars = {'a':3, 'b':4}
``

Una tarea puede tener uno de los siguientes estados:
``
QUEUED, RUNNING, COMPLETED, FAILED, TIMEOUT
``

Una vez que una tarea se ha creado (existe un registro en la tabla "scheduler_task"), está ``QUEUED`` (en cola), y está preparada (cumple todas las condiciones especificadas en el registro), puede ser tomada por un obrero. En cuanto un obrero está disponible, este toma la primer tarea preparada programada para correr. El obrero crea un registro en otra tabla, "scheduler_run" (también creada por el programador de tareas).

La tabla "scheduler_run" almacena el status de todas las tareas que se corren. Cada registro enlaza a una tarea que ha sido tomada por un obrero. Una tarea puede tener mútiples ejecuciones. Por ejemplo, una tarea programada para repetirse 10 veces en una hora probablemente se ejecutará 10 veces (a menos que alguna falle o que superen la hora de duración).

Los status posibles de ejecución son:
``
RUNNING, COMPLETED, FAILED, TIMEOUT
``

Cuando una tarea ``QUEUED`` es tomada, se convierte en una tarea ``RUNNING`` y su status también es ``RUNNING``. Si la ejecución finalizó, no se generaron excepciones y no hay un vencimiento de tarea, la ejecución se marca como ``COMPLETED`` y la tarea se marca como ``QUEUED`` o ``COMPLETED`` según si se debe ejecutar nuevamente en otro momento. La salida de la tarea se codifica (serialize) con JSON y es almacenada en el registro de ejecución.

Cuando una tarea ``RUNNING`` genera una excepción, la ejecución se marca como ``FAILED`` y la tarea se marca también como ``FAILED``. La traza (traceback) se almacena en el registro de ejecución.

En forma similar, cuando una ejecución excede el tiempo de vencimiento, se detiene y se marca como ``TIMEOUT``, y la tarea se marca como ``TIMEOUT``.

En todo caso, la stdout se captura y además se guarda (log) en el registro de la ejecución.

Usando appadmin, uno puede comprobar las tareas ``RUNNING`` (en ejecución), la salida de las tareas ``COMPLETED`` (finalizadas) y los errores de las tareas ``FAILED``, etc.

El programador de tareas además crea una o más tablas llamadas "scheduled_worker", que almacenan los eventos (hartbeat) de los obreros y sus status. Los posibles status de los obreros son:
``
ACTIVE, INACTIVE, DISABLED
``

Los obreros se pueden deshabilitar cambiando su status por medio de appadmin.

Todo lo que se puede hacer a través de appadmin también se puede hacer en forma programática insertando y actualizando registros de estas tablas.

De todos modos, uno no debería actualizar los registros relacionados a tareas con status ``RUNNING`` porque esto podría crear un comportamiento inesperado. La mejor práctica es encolar las tareas por medio de "insert". Por ejemplo:
``
db.scheduler_task.insert(
    status='QUEUED',
    application_name='miapp',
    task_name='mi primer tarea',
    function_name='agregar_tarea',
    args='[]',
    vars="{'a':3,'b':4}",
    enabled=True,
    start_time = request.now,
    stop_time = request.now+datetime.timedelta(days=1),
    repeats = 10, # correr 10 veces
    period = 3600, # con una frecuencia de 1 hora
    timeout = 60, # debería durar menos de 60 segundos
    )
``:code

Observa que los campos "times_run", "last_run_time" y "assigned_worker_name" no se configuran al programar la tarea sino que son completados automáticamente por los obreros.

Además puedes recuperar la salida de las tareas finalizadas:
``
tareas_finalizadas = db(db.scheduler_run.status='COMPLETED').select()
``:code

------
El programador de tareas es experimental porque necesita mayores controles y pruebas y porque la estructura de tablas puede modificarse al agregar nuevas funcionalidades.
------

- Es recomendable tener un archivo de modelo separado para definir las tareas e instanciar ``Scheduler`` (después de que las tareas estén definidas).
- También se recomienda el uso de al menos un obrero por aplicación para tener un mejor control, aunque no sea estrictamente necesario.
- Si tus tareas se han definido en un módulo (en lugar de un modelo) puedes necesitar reiniciar los obreros.


### Módulos de terceros
``import``:inxx

web2py está desarrollado en Python, por lo que puede importar y utilizar cualquier módulo de Python, incluyendo los módulos de terceros. Sólo necesita poder hallarlos. Como con cualquier aplicación de Python, los módulos se pueden instalar en la carpeta oficial de Python "site-packages", y se pueden importar desde cualquier ubicación en tu código.

Los módulos en la carpeta "site-packages" son, como lo sugiere el nombre, paquetes del entorno/sistema. Las aplicaciones que requieren estos paquetes no son portables a menos que esos módulos se instalen por separado. La ventaja del uso de módulos en "site-packages" es que las distintas aplicaciones los pueden compartir. Consideremos, por ejemplo, un paquete para ploteo llamado "matplotlib". Puedes instalarlo desde la consola usando el comando ``easy_install`` de PEAK:
``
easy_install py-matplotlib
``:code

y luego puedes importarlo en un modelo/controlador/vista con:
``
import matplotlib
``:code

La distribución de código fuente de web2py y la distribución binaria de Windows tiene un site-packages en la carpeta raíz. La distribución binaria para Mac tiene una carpeta site-packages en la ruta:
``web2py.app/Contents/Resources/site-packages``:code

El problema al usar site-packages es que se torna difícil el uso de distintas versiones de un mismo módulo al mismo tiempo, por ejemplo podría haber dos aplicaciones que usen distintas versiones del mismo archivo. En este ejemplo, ``sys.path`` no se puede alterar porque afectaría a ambas aplicaciones.

Para estas situaciones, web2py provee de otra forma de importar módulos de forma que el ``sys.path`` global no se altere: ubicándolos en la carpeta "modules" de una aplicación determinada. Un beneficio adicional es que el módulo se copiará y distribuirá automáticamente con la aplicación.

------
Una vez que un módulo "mimodulo.py" se ubica en la carpeta "modules/" de una app, se puede importar desde cualquier ubicación dentro de una aplicación de web2py (sin necesidad de modificar ``sys.path``) con:
``
import mimodulo
``
------

### Entorno de ejecución
``exec_environment``:inxx

-----
Si bien todo lo descripto aquí funciona, es recomendable armar la aplicación usando componentes, como se detalla en el capítulo 12.
-----

Los archivos de modelo y controlador no son módulos de Python en el sentido de que no se pueden importar usando la instrucción ``import``. La razón es que los modelos y controladores están diseñados para ejecutarse en un entorno preparado que se ha pre-configurado con los objetos globales de web2py (request, response, session, cache y T) y funciones ayudantes. Esto es necesario porque Python es un lenguaje de espacios estáticos (statically -lexically- scoped language), mientras que el entorno de web2py se crea en forma dinámica.

web2py provee de una función ``exec_environment`` que te permite acceder a los modelos y controladores directamente. ``exec_evironment`` crea un entorno de ejecución de web2py, carga el archivo en él y devuelve un objeto Storage que contiene el entorno. El objeto Storage además sirve como mecanismo de espacio de nombres. Todo archivo de Python diseñado para que corra en el entorno de ejecución se puede cargar con ``exec_environment``. Los usos de ``exec_environment`` incluyen:
- Acceso a datos (modelos) desde otras aplicaciones.
- Acceso a objetos globales desde otros modelos o controladores.
- Ejecución de funciones de otros controladores.
- Carga de librerías de ayudantes para todo el sitio/sistema.

El siguiente ejemplo lee registros de la tabla ``user`` en la aplicación ``cas``:
``
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
``:code

Otro ejemplo: supongamos que tenemos un controlador "otro.py" que contiene:
``
def una_accion():
    return dict(direccion_remota=request.env.remote_addr)
``:code

Esto se puede llamar desde otra acción de la siguiente forma (o desde la consola de web2py):
``
from gluon.shell import exec_environment
otro = exec_environment('applications/app/controllers/otro.py', request=request)
resultado = otro.una_accion()
``:code

En la línea 2, ``request=request`` es opcional. Tiene el efecto de pasar la solicitud actual al entorno de "otro".
Sin ese argumento, el entorno contendría un objeto request nuevo y vacío (excepto por ``request.folder``). También es posible pasar un objeto response y session a ``exec_environment``. Ten cuidado al pasar los objetos request, response y session --- las modificaciones en la acción llamada o sus dependencias pueden dar lugar a efectos no esperados.

La llamada a la función en la línea 3 no ejecuta la vista; sólo devuelve el diccionario a menos que ``response.render`` se llame explícitamente por "una_accion".

Un detalle más a observar: no utilices ``exec_environment`` en forma inapropiada. Si quieres que los resultados de las acciones se recuperen en otra aplicación, probáblemente deberías implementar una API XML-RPC (la implementación de una API XML-RPC con web2py es prácticamente trivial). No utilices ``exec_environment`` como mecanismo de redirección; utiliza el ayudante ``redirect``.


### Cooperación
``cooperation``:inxx

Hay varias formas de cooperación entre aplicaciones:

- Las aplicaciones pueden contectarse a la misma base de datos y por lo tanto, compartir las tablas. No es necesario que todas las tablas en la base de datos se definan en cada aplicación, pero se deben definir en las aplicaciones que las usan. Todas las apliaciones que usan la misma tabla excepto una, deben definir la tabla con ``migrate=False``.
- Las aplicaciones pueden embeber componentes desde otras aplicaciones usando el ayudante LOAD (descripto en el capítulo 12).
- Las aplicaciones pueden compartir sesiones.
- Las aplicaciones pueden llamar a las acciones de otras aplicaciones en forma remota a través de XML-RPC.
- Las aplicaciones pueden acceder a los archivos de otras aplicaciones a través del sistema de archivos (se asume que las aplicaciones comparten el sistema de archivos).
- Las aplicaciones pueden llamar a las acciones de otras aplicaciones en forma local utilizando ``exec_environment`` como se detalla más arriba.
- Las aplicaciones pueden importar pueden importar módulos de otras aplicaciones usando la sintaxis:
``
from applications.nombreapp.modules import mimodulo
``:code

- Las aplicaciones pueden importar cualquier módulo en las rutas de búsqueda del ``PYTHONPATH`` y ``sys.path``.
- Applications can import any module in the ``PYTHONPATH`` search path, ``sys.path``.

Una app puede cargar la sesión de otra app usando el comando:
``
session.connect(request, response, masterapp='nombreapp', db=db)
``:code

Aquí "nombreapp" es el nombre de la aplicación maestra, es decir, la que establece la sesión_id inicial en la cookie. ``db`` es una conexión a la base de datos que contiene la tabla de la sesión (``web2py_session``). Todas las app que comparten sesiones deben usar las misma base de datos para almacenar las sesiones.

Una aplicación puede cargar un módulo desde otra app usando

``
import applications.otraapp.modules.otromodulo
``:code

### Historial (Logging)

Python provee de distintas API para historial o logging. web2py dispone de un mecanismo para configurarlo para
que las app lo puedan usar.

En tu aplicación, creas un logger, por ejemplo en un modelo:
``
import logging
logger = logging.getLogger("web2py.app.miapp")
logger.setLevel(logging.DEBUG)
``:code

y puedes usarlo para registrar (log) mensajes de distinta importancia

``
logger.debug("Sólo comprobando que %s" % detalles)
logger.info("Deberías saber que %s" % detalles)
logger.warn("Cuidado que %s" % detalles)
logger.error("Epa, algo malo ha ocurrido %s" % detalles)
``:code

``logging`` es un módulo estándar de Python que se detalla aquí:
``
http://docs.python.org/library/logging.html
``

La cadena "web2py.app.miapp" define un logger en el nivel de la aplicación.

Para que esto funcione adecuadamente, necesitas un archivo de configuración para el logger.
Un archivo viene con la instalación de web2py en la carpeta raíz, "logging.example.conf". Debes cambiar el nombre del archivo como "logging.conf" y personalizarlo según tus requerimientos.

Este archivo contiene documentación de uso, por lo que es conveniente que lo abras y lo leas.

Para crear un logger configurable para la aplicación "miapp", debes agregar miapp a la lista de claves [loggers]:
``
[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,miapp
``:code

y debes agregar una sección [logger_miapp], usando [logger_welcome] como ejemplo.

``
[logger_myapp]
level=WARNING
qualname=web2py.app.miapp
handlers=consoleHandler
propagate=0
``:code

La directiva "handlers" especifica el tipo de historial y para el ejemplo, la salida del historial para miapp se muestra por consola.


### ''WSGI''
``WSGI``:inxx

web2py y WSGI tienen una relación de amor-odio. Nuestra opinión es que WSGI fue desarrollado como protocolo para conectar servidores web a aplicaciones web en forma portable, y lo usamos con ese fin. web2py en su núcleo es una aplicación WSGI:
``gluon.main.wsgibase``. Algunos desarrolladores han llevado a WSGI a sus límites como protocolo para comunicaciones middleware y desarrollan aplicaciones web en forma de cebolla, con sus múltiples capas (cada capa es un middleware desarrollado en forma independiente de la totalidad del framework). web2py no adopta esta estructura en forma interna. Esto se debe a que creemos que las funcionalidades del núcleo de los framework (manejo de las cookie, sesión, errores, transacciones, manejo de las URL o dispatching) se pueden optimizar para que sean más seguras y veloces si son manejadas por una única capa que las incluya.

De todos modos, web2py te permite el uso de aplicaciones WSGI de terceros y middleware en tres formas (y sus combinaciones):
- Puedes editar el archivo "wsgihandler.py" e incluir cualquier middleware WSGI de terceros.
- Puedes conectar middleware WSGI de terceros a cualquier acción específica en tus app.
- Puedes llamar a una app WSGI de terceros desde tus acciones.

La única limitación es que no puedes usar middleware de terceros para reemplazar las funciones del núcleo de web2py.

#### Middleware externo

Consideremos el archivo "wsgibase.py":
``
#...
LOGGING = False
#...
if LOGGING:
    aplicacion = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    aplicacion = gluon.main.wsgibase
``:code

Cuando ``LOGGING`` se establece como ``True``, ``gluon.main.wsgibase`` es envuelto (wrapped) por la función middleware ``gluon.main.appfactory``. Esta provee de registro del historial en el archivo "httpserver.log". En forma similar puedes agregar cualquier middleware de terceros. Se puede encontrar más información sobre este tema en la documentación oficial de WSGI.

#### Middleware interno

Dada cualquier acción en tus controladores (por ejemplo ``index``) y cualquier aplicación middleware de terceros (por ejemplo ``MiMiddleware``, que convierte la salida a mayúsculas), puedes usar un decorador de web2py para aplicar el middleware a esa acción.
Este es un ejemplo:
``
class MyMiddleware:
    """Convertir la salida a mayúsculas"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hola mundo'
``:code

No podemos garantizar que todo middleware de terceros funcione con este mecanismo.

#### Llamando a aplicaciones ''WSGI''

Es fácil llamar a una app WSGI desde una acción en web2py. Este es un ejemplo:
``
def test_wsgi_app(environ, start_response):
    """Esta es una app WSGI para prueba"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['¡hola mundo!\n']

def index():
    """Una acción para prueba que llama a la app previa y escapa la salida"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()
``:code

En este caso, la acción ``index`` llama a ``test_wsgi_app`` y escapa el valor obtenido antes de devolverlo. Observa que ``index`` por sí mismo no es una app WSGI y debe usar la API normal de web2py (por ejemplo ``response.write`` para escribir en el socket).
